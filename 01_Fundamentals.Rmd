# Fundamentals

## Introduction

This chapter provides a rapid breakdown of the core functionality of R. There is a lot to cover in a very short time. Remember that you can only learn coding through repetition. Make the extra time and effort to actually type out the code and run it in your console.

**It is important that you physically participate and code along with the examples. Type everything out. The physical act of typing into R and troubleshooting any errors you get is a crucial part of the learning process.**

<br> 

*** 

<br>

## R Basics

Make comments inside your code. Very important (unless you are using R markdown or R notebooks)!

```{r}
# Use hastags to make comments - not read by the R console
# Use other characters and blank lines to improve readability:
# ------------------------- 
# My first R script 
# Today's Date
# -------------------------
# Add a summary description of what the script does
# This script will...
# And annotate individual parts of the script
```


### Basic Math

You can do basic mathematical equations in R. 

> Yes, type these out!

```{r}
10+2 # add
10-2 # subtract
10*2 # multiply
10/2 # divide
10^2 # exponent
```


### Functions

R uses **functions**. Each function has a name and is followed by brackets `function()`.

Inside the brackets we can define input values and parameters. 


### `c()

The **concatenate** function `c()` is a very important function in R that is used to group items together.

```{r}
c(1,2,3,5)
```


### Math Functions

Here are some basic mathematical functions:

```{r}
abs(-10) # absolute value
sqrt(10-1) # square root (with subtraction)
log(10) # natural log
log10(10) # log base 10
exp(1) # power of e
sin(pi/2) # sine function
asin(1) # inverse sine
cos(pi) # cosine
acos(-1) # inverse cosine
tan(0) # tangent
atan(0) # inverse tangent
```


### Round/Truncate

Rounding and truncating numbers:

```{r}
round(pi,digits=3) # standard rounding to 3 digits
floor(pi) # round down to closest whole number
ceiling(pi) # round up to closest whole number
signif(pi,digits=2) # round to keep 2 significant digits
```


### Logic Operators

An **operator** is used to compare values. 

```{r}
1 > 2 # greater than
1 < 2 # less than
1 <= 2 # less than or equal to
1 == 1 # equal to
1 == 2 | 1 == 1 # | means 'OR'
1 == 2 & 1 == 1 # & means 'AND' 
1 == 1 & 1 == 1
```

> Note: `!` is a negation/inverse operator

```{r}
1 != 1 # not equal to
```

### Group Comparison

Instead of `|`, you can us `%in%` with `c()` to check a large number of values.

```{r}
1 %in% c(1,2,3,4,5,6,7,8,9,10)
```

### Random Numbers

It is very easy to generate some random numbers from different distributions. This is very useful for modelling and testing your code. These are covered in more detail in the [Distributions Tutorial](https://colauttilab.github.io/RIntroStats/1_Distributions.html). But for now, it's just useful to know how to generate different kinds of random numbers.

The most basic random number is a whole number (i.e. no decimal) drawn from a **uniform distribution**, meaning that each number has an equal probability of being selected.

```{r}
runif(n=10, min=0, max=1)
```

One of the most common random numbers in statistics is a number drawn from a **random, normal distribution** with a given `mean` and `sd` (standard deviation). Rational numbers (i.e. with decimal) can be chosen and numbers closer to the mean are more likely to be chosen.

```{r}
rnorm(10, mean=0, sd=1)
```

Note that som

A **poisson distribution** includes only whole numbers but are include a parameter `lambda`, which is the equivalent of the mean in the normal distribution.

```{r}
rpois(10, lambda=10)
```

The **binomial distribution** is useful for binary outcomes, like a coin toss, coded as 0 or 1. The `size` parameter is the number of events (e.g. number of coin flips), and the `prob` parameter is the probability of getting a 1.

```{r}

rbinom(10,size=1,prob=0.5) 
rbinom(10,size=10,prob=0.5)
```

**Fun fact**: random numbers generated by a computer are not truly random. Instead, the numbers involve a calculation from a starting number called a **seed**. The seed might be the current Year/Month/Day/Hour/Minute/Second/Millisecond, which means the 'random' number could be determined by somebody who knows the equation and the time it eas executed. 

In practice, computer-generated random numbers are much better than human-generated random numbers. 

We can also set the seed number to help with testing and debugging our code.

We can recreate the exact random number using the `set.seed()` function.

Compare these outputs:

```{r}
runif(5)
runif(5)
set.seed(3)
runif(5)
set.seed(3)
runif(5)
set.seed(172834782)
runif(5)
set.seed(172834782)
runif(5)
runif(5)
```

### Combining objects

Use `c()` to concatenate single objects.

```{r}
Nums<-c(1,2,5)
c(Nums,"string")
```

Use `:` to include a range of numbers.

```{r}
1:10
100:90
-1:1
```

Use `cbind()` to bind columns and `rbind` to bind rows.

```{r}
cbind(1:10,10:1)
rbind(1:10,10:1)
```


<br>

*** 

<br>

## Data Types

Programming languages like R use different data types. 

It's very important to understand data types in order to properly encode and analyze data in R. It's very common to have errors in statistical analyses caused by the wrong kind of data. For example, if you have 3 experimental groups coded as 1, 2 and 3 then these should be coded and analyzed as **factors** not **numeric** variables.

Type | Example | Description
--------|-------|----------------------------------
`string` |`"String"`| Strings are the most common and versatile and can be defined with single `''` or double `""` quotation marks. The downside of strings is that you can't do any kind of equations.
`numeric` |`12.421`| Numeric variables are rational numbers.
`integer` |`12`| Integers are whole numbers and may be positive or negative (no decimal).
`complex` |`0+12.43i`| Complex numbers include real and imaginary numbers.
`boolean` | `T` or `TRUE` | Boolean or **logical** variables are either true or false (Note always capital).
`factors` Factors are a special type of data that may include strings and/or numbers but have a limited number of classes. Factors are often used to code groups in statistical models. 

Note that computers cannot store irrational numbers, they have to be rounded to some (tiny) decimal place.

<br>

*** 

<br>

## Objects

R supports **Object-Oriented Programming (OOP)**, which is a programming style that defines and manipulates **objects**

An **object** in R can be a lot of things, but an easy way is to think of a spreadsheet (example Microsoft Excel). 

A spreadsheet has columns organized into rows and columns, and may have multiple sheets.

### Cells

The most basic object is a single value. For example, a string:

```{r}
X<-"string"
```

> Why no output? 

When we wrote: `X<-"string"`

R created the object called **X**, so no output is produced. 

There are a few options To see the contents of **X**:

```{r}
print(X)
paste(X)
X
```

`print()` Is most generic and versatile for providing feedback while running complex scripts (e.g. during loops, Bash scripts, etc)

`paste()` Converts objects to a string, we'll come back to this.

Generally `print()` or `paste()` are preferred over calling the object directly.

### Vector 

A vector is a one-dimensional array of cells. This could be a row or column in our spreadsheet example.

Each cell within the vector has an 'address' -- a number corresponding to the cell ranging from 1 to N, where N is the number of cells.

The number of cells in a vector is called the **length** of the vector.

All items in a vector must be of the same type. If you mix numbers and text, then the whole vector will be formatted to the simplest type. For example, if you include a string with any other fomat, then the whole vector will be treated as a string:

```{r}
Xvec<-c(1.1829378, X, 1:10, "E", "Computational Biology", 100:90)
Xvec
```

> **Protip**: A common problem when importing data to R occurs when a column of numeric data includes at least one text value (e.g.  "missing" or "< 1"). R will treat the entire column as text rather than numeric values. Watch for this when working with real data!

#### Subset a vector

Use square brackets `[]` to subset a vector.

```{r}
Xvec[1]
Xvec[13]
Xvec[1:3]
```

### Matrices 

A matrix is a 2-D array of cells, equivalent to one sheet in a spreadsheet program. 

```{r}
Xmat<-matrix(Xvec,nrow=6)
Xmat
```

#### Subset

**Notice** the square brackets along the top and left side? 

These show the 'address' of each element in the matrix. We can subset with square brackets, just like we did with vectors. Since there are two dimensions, we need to specify two numbers:

`[row,column]`

```{r}
Xmat[1,3]
```

Or leave it blank if you want the whole row or column:

```{r}
Xmat[1,]
Xmat[,3]
```


### Tensors

**Tensors** are the general term for a grid with N dimensions. We've already seen a few different tensors:

Name | Tensor Dimension
--------|----
Cell | 0
Vector | 1
Matrix | 2
Array | 3+

Another common term for tensor is **array**. In R you can build tensors by adding as many dimensions as you need using the `array()` function.

```{r}
Xarray<-array(0, dim=c(3,3,2)) # 3 dimensions
Xarray
```

Notice how 3rd dimension is sliced to print out in 2D.

<br>

Higher-order arrays are possible, but a bit tricky to read on a 2-dimensional screen.

```{r}
Xarray<-array(rnorm(64), dim=c(2,2,2,2,2,2)) # 6 dimensions
```

Once you get the hang of it, it's easy to subset. Just think of each dimension, separated by commas.

```{r}
Xarray[1:2,1:2,1,1,1,1]
Xarray[1:2,1,1,1:2,1,1]
```

> Why are these numbers not the same?

Look at the `array[]` function and compare to the 6-D tensor to understand how this works.

## Matrix Algebra

R is pretty handy for matrix calculations that would be very time consuming to do by hand or even in a spreadsheet program.

As an example, let's create some numeric vectors that we can play with:

```{r}
X<-c(1:10)
X
Y<-c(1:10*0.5)
Y
```

### Basic operations

Probably the most common calculation is just to go through each element in each vector and multiply them together. For example, if X is a vector of leaf length measurements and Y is a vector of leaf width measurements, then we might want to calculate leaf area by multiplying each length by its corresponding width. 

In R we just use the standard multiplication operator `*` on a vector, just like we would do for two individual numbers.

```{r}
X*Y
```

Addition, subtraction, division, and exponents are similar.

```{r}
X+Y
X/Y
X^Y
```

Just as we apply operators to vectors, we can also apply functions to vectors. When we do this, the same function is applied to each individual cell of the vector.

```{r}
log(X)
exp(Y)
```

### Matrix Algebra

In matrix algebra, we can 'multiply' two vectors together in a different way. First, we multiply each pair of cells together, as above, but then we sum the products together (e.g.  `X[1]*Y[1]+X[2]*Y[2]...`).

This is matrix multiplication operator `%*%` in R.

```{r}
X%*%Y # Matrix multiplication 
sum(X*Y) == X%*%Y
```

There are a few other important matrix operations:

```{r}
Z<-X[1:4]%o%Y[1:3] # Outer product
Z
t(Z) # Transpose
crossprod(X[1:4],Z) # Cross product
crossprod(Z) # Cross product of Z and t(Z)
diag(4) # Identity matrix, 4x4 in this case
diag(Z) # Diagonal elements of Z 
```

These calculations can get a bit tricky -- especially when we move to 2D matrices instead of vectors. You'll want to consult or review a matrix algebra textbook if you are going to apply these. For now, the important thing is just to know that these options are available if you need them in the future. 

Operator | Name
----|------------
`*` | Pairwise multiplicaiton
`%*%` | Matrix multiplication
`%o%` | Outer product
`t()` | Transpose
`crossprod()` | Cross-product
`diag(4)` | Identity of 4x4 matrix
`diag(M)` | Diagonal elements of matrix M


### PCA

One popular use-case for matrix calculation is the principal components analysis (PCA). The PCA is covered in more detail in the [PCA Tutorial](https://colauttilab.github.io/RIntroML/2_PCA.html), but it is a method to rescale a bunch of **correlated** vectors (e.g. measurements) so that they can be remapped to an equal number of **independent** PC axes.

PCA is widely used in biology, from community ecology and metagenomics to gene expression and morphometrics. It also has many applications outside of biology. For now, just know that it is easy to run a PCA using the `prcomp()` function. In most cases, we would want to scale the vectors to have a mean of 0 and standard deviation of 1. Equivalently, we can use the `cor=T` parameter to use the correlation matrix in the calculations.

```{r}
prcomp(Z, cor=T) 
```

## Lists 

Tensors generally all have the same data type and sub-dimension. For example, if you want to combine two separate 2D matrices into a single tensor (3rd dimension) then the individual matrices have to have the same number of rows and columns, and the same data type.

But often we want to group different types of information together. Think of a record in a database where you may have information about an individual's hight, weight, eye colour, adn maybe a photograph and a set of DNA sequences. This wouldn't fit neatly into a tensor format. Instead, we can use a list.

Lists are useful for mixing data types, and can combine different dimensions cells, vectors, and higher-order arrays.

Each element needs a name:

```{r}
MyList<-list(name="SWC",potpourri=Xvec,numbers=1:10)
MyList
```

**Important**: Many of the statistical functions and other tools in R use list objects to store output. Taking some time now to understand how lists work will help you save a lot of time interpreting statistical output in R.

### Subset

There are a few different ways to subset a list object.

```{r}
MyList$numbers # Use $ to subset by name
MyList[3] # A 'slice' of MyList
MyList[[3]] # An 'extract' of MyList
```

> What's the difference between `[]` and `[[]]`?

Look carefully at the output above; notice how the `[]` includes `$numbers` but the `[[]]` includes only the values? This is important if you want to use the slice:

```{r, error=TRUE}
2*MyList[[3]]
2*MyList[3]
```

### Output

> **Protip**: Many analysis functions in R output as lists (e.g. statistical packages).

For example, the output of `prcomp`:

```{r}
prcomp(Z) 
names(prcomp(Z))
prcomp(Z)$center
prcomp(Z)$scale
```

## `print()` and `paste()`

The `print` function is the go-to function for printing output to the user. The `paste` function is for combining things together. 

Paste is a versatile function for manipulating output:

```{r}
paste("Hello World!") # Basic string
paste("Hello","World!") # Concatenate two strings
```

Sometimes we need to convert numbers to strings. `paste` is an easy way to do this:

```{r}
paste(1:10) # Paste numbers as strings
paste(1:10)[4]
```

Note above how each number is a separate cell in a vector of strings.

Use `as.numeric` to convert strings back to numbers.

```{r}
as.numeric(paste(1:10)) # Convert back to numbers
```

Finally, use the `collapse` parameter to condense a multi-cell vector into a single cell.

```{r}
paste(1:10,collapse=".")
```

Note what happens if we combine objects of different length?

```{r}
paste("Hello",1:10,sep="-") 
```

It is not uncommon to nest a paste function within a print function when communicating output in a more complex R script.

```{r}
print(paste("Hello",1:10,sep="-"))
```

This would be useful inside of a `for` loop (see below) where the output of `paste` is not shown on the screen if used inside of a loop, whereas the output of `print` is.

### ? for HELP

Whenever you are learning a new function, you should use `?` and carefully read about all the parameters and outputs. The explanations can be a bit technical, which is intimidating at first. But after enough practice you will start to understand more and more of the descriptions.

```{r eval=F}
?paste
```

<br>

*** 

<br>


## Data

So far we've done everything within the R environment. If we quit R then everything we have made will be removed from memory and we'll have to start all over. Therefore, it can be useful to save and load data from external files.

### Working Directory

The **working directory** is the place where R looks to load or save your files. You can figure out what your current working directory is with the `getwd()` function.

```{r, eval=F}
getwd()
```

Or you can set a specific working directory. Here's one example:

```{r, eval=F}
setwd("C:/Users/ColauttiLab/Documents")
```

Did you type out the above line? You should! Remember, going through and typing everything out is one of the most effective ways to learn to code. So do it now

Okay, so you probably have an error unless you are working in Windows and for some reason have a ColauttiLab username on your computer. Now try changing to a different directory on your computer.

If you are a mac user, you can just ignore the `C:` part:

```{r, eval=F}
setwd("/Users/ColauttiLab/Documents")
```

#### Relative Path

The above examples of `setwd()` us an **absolute** path. You can also use a **relative** path. For example, if we have a folder called `Data` inside our `Documents` folder, and our current working directory is one of the two examples above, we can use a relative path name to set the `Data` folder as the working directory. Before you type this out, you should make a folder called `Data` inside of your current working directory.

```{r, eval=F}
setwd("./Data")
```

The `.` means "Inside of my current directory" and the `/Data` means "find the Data folder".

now try this:

```{r, eval=F}
getwd()
setwd("..")
getwd()
```

Compare the working directories. The `..` means "Go to the parent directory."

The neat thing about relative directories is that it makes it easy to share code between Windows, MacOS and Linux/Unix. In fact, these commands come from Linux. You can check out the [Linux Crash Course](https://colauttilab.github.io/LinuxCrashCourse/Linux-Fundamentals.html) for more detail.

### Import

Download [This Data File](https://colauttilab.github.io/RCrashCourse/FallopiaData.csv) and save in a folder called `Data` inside of your current working directory.

We can use the `read.csv` to read a 'comma-delimited file' and import it into an object called `MyData`. Often we have column names as the first row, so we include the parameter `header=T` to convert the first row to column names. 

Data without column names would have data on the first row, so we would want `header=F` or else our first row of data would be treated as column names.

```{r,eval=F}
MyData<-read.csv("Data/FallopiaData.csv",header=T)
```

```{r,echo=F}
MyData<-read.csv(
  "https://colauttilab.github.io/RCrashCourse/FallopiaData.csv")
```

A `.csv` file is just a text file with special formatting that can be read into a program like Microsoft Excel or R to translate the text file into a data matrix.

**Important**: In R, objects created by `read.csv` and other `read.?` functions are special objects called `data.frame` objects.

### `data.frame`

A `data.frame` is a special type of 2D matrix with additional indexing information for rows/columns of data.

This format is partly why R is so useful for data analysis.

<br>

There are a number of useful functions for inspecting a `data.frame` object.

```{r}
names(MyData) # See column names
head(MyData) #  Show first six rows of data
tail(MyData) #  Show last six rows of data
dim(MyData) # Number of dimension (rows columns)
nrow(MyData) # Number of rows only
ncol(MyData) # Number of columns only
```

One more function is particularly useful for inspecting the **structure** of the data. We can use this to see column headers, types of data contained in each column, and the first few values in each column.

```{r}
str(MyData) 
```

> Protip: `str()` is very important for functions that use data.frames including statistical analysis and plotting

Pay careful attention to integer `int` vs numeric `num` vs `factor` columns. These are the data types, and we'll look at these in more detail later.

One common source of error students make when starting to analyzing data is using the wrong data *type*.

Here's an example of data types gone rogue: In an analysis of variance (ANOVA), you want a `factor` as a predictor and a `num` or `int` as a response. But in linear regression you want `int` or `num` as a predictor instead of `factor`. If you code your factor (e.g. treatment) as a number (e.g. 1-4) then R will treat it as an integer when you import the data. When you run a linear model with the `lm` function, you will be running a regression rather than ANOVA! As a result, you will estimate a slope rather than the difference between group means.

### Subset

The `data.frame` object can be subset, just like a matrix.

```{r}
MyData[1,] # Returns first row of data.frame
MyData[1,1] # Returns first value of data.frame
```

In addition, you can define the column names.

```{r}
MyData[,"PotNum"] # Returns values in "PotNum" column
MyData$PotNum # Another way to get the same output
```

We can also subset the data based on particular row values. For example, we can find only the records in the *extreme* treatment scenario.

```{r}
levels(MyData$Scenario)
subset(MyData,Scenario=="extreme") # Subset
```

### New Columns

It's easy to add new columns to a data frame. For example, to add a new column that is the sum of two others:

```{r}
MyData$Total<-MyData$Symphytum + MyData$Silene + MyData$Urtica
names(MyData)
print(MyData$Total)      
```


<br>

*** 

<br>


## Other Functions

There are a few more useful functions for inspecting your data.

### `unique`

Find all the unique values within a vector using `unique`.

```{r}
unique(MyData$Nutrients)
```

### `duplicated`

Look at each value in a vector and return a `TRUE` if it is duplicated and `FALSE` if it is unique.

```{r}
duplicated(MyData$Nutrients)
```

This is a good example of a Boolean vector, which can be used to subset your data.

```{r}
MyData$Nutrients[duplicated(MyData$Nutrients)]
```

Note that only the `TRUE` values are returned (duplicated).

### `aggregate`

Quickly calculate means of one vector (Total) for each value of a grouping variable (Nutrients).

```{r}
aggregate(MyData$Total,list(MyData$Nutrients), mean) 
```

The `~` provides an alternative way to write this function. In R the `~` usually means 'by' and is often used in statistical models. Here we can say aggregate Total 'by' Nutrients grouping.

```{r}
aggregate(Total ~ Nutrients, data=MyData, mean)
```

The nice thing about doing it this way is that we preserve the column name (Total instead of x).

You can also use this to calculate means across different grouping variables.

```{r}
aggregate(Total ~ Nutrients*Taxon*Scenario, data=MyData, mean)
```

Note that `mean` is just the `mean()` function in R. We can use other functions, like the standard deviation `sd`:

```{r}
aggregate(Total ~ Nutrients, data=MyData, sd) 
```

### tapply

The `tapply` function is a more general way to replicate functions. 

```{r}
tapply(MyData$Total, list(MyData$Nutrients), mean) # calculate means

```

Compare the two outputs with `aggregate` above

## Tidyverse

Most of the methods above for managing and summarizing data are the *classic* or *base R* functions. More recently, the **tidyverse** group of functions was introduced and has a lot of advantages over the classic tools, particularly for complex data management. For example, it is easy to string together multiple steps into a single 'pipe' of data reorganization. The [Data Science Tutorial](https://colauttilab.github.io/RCrashCourse/5_datascience.html) introduces `dplyr` -- one of the tools in the `tidyverse`.


## Save

Just as we can load FROM external files, we can save TO external files

```{r, eval=F}
## Calulate means
NutrientMeans<-tapply(MyData$Total,list(MyData$Nutrients),mean)
## Save means as .csv file
write.csv(NutrientMeans,"MyData_Nutrient_Means.csv")
```

You should see this file in your working directory.

<br>

*** 

<br>

## Flow control

Think of your data analysis as a stream flowing from the raw data at the headwaters and flowing down to the end, exiting as a full analysis with graphics, stats, and interpretation.

There are different ways we can control the flow of the water. The simplest is just to write a sequence of lines of code, with the output of one line of code forming the input of the next. There are several examples of this above:

```
A<-functionA()
B<-functionB(A)
C<-functionC(B)
```

But sometimes we may want to do the same function or analysis only if the input meets certain criteria. Or we may want to reiterate the same analysis multiple times on different inputs. This is where more advanced flow control comes in handy.

To start, let's make up a couple of objects to play with:

```{r}
X<-21
Xvec<-c(1:10,"string")
```

### `if`

The `if` statement uses an **operator** (see above) to asses whether the value is `TRUE` or `FALSE`:

```{r}
if(X > 100){ # Is X greater than 100?
  print("X > 100") # If TRUE
} else { 
  print("X <= 100") # If FALSE
}
```

> **NOTE**: A common 'rookie' mistake is to leave out a bracket or use the wrong type. 

Use regular brackets for the if function `if()` followed by two sets of curly brackets `{}else{}`.

Break up across multiple lines to improve readability. Note that you don't need an `else{}` part if you just want to 'do nothing' when `FALSE`.

```{r}
if(1 > 0){print ("yup")}
```

### ifelse

The `ifelse` is a more compact version for simple comparisons. The following code does the same as above.

```{r}
ifelse(X > 100, print("X > 100"), print("X <= 100"))
```


### `for` loop

A loop does the same thing over and over again until some condition is met. In the case of a `for` loop, we set a 'counter' variable and loop through each value of the counter variable. Here are a few examples:

```{r}
# Loop through numbers from 1 to X
for (i in 1:X){
  print(paste(X,i,sep=":"))
}
# Loop through elements of a vector directly
for (i in Xvec){
  print(i)
}
# Use an index to loop through the elements
for (i in 1:length(Xvec)){
  print(Xvec[i])
}
```

Note that in each case there is a vector and we loop through each cell in the vector. The `i` keeps track of the cell value in each iteration of the loop.

Loops can be tricky, and the only way to really learn them is to try to write a bunch. Whenever you find yourself writing similar code more than 2 or 3 times, challenge yourself to try to do it as a loop.

In addition to looping through a vector, it can often be useful to include a counter variable. 

One thing to watch out for is what part of the loop you want to update the counter variable. USUALLY it will be at the beginning

```{r}
count1<-1
count10<-1

for(i in 1:10){
  print(paste("count1 =",count1))
  print(paste("count10 =",count10))
  count1<-count1+1
  count10<-count10*10
}
```

or at the end. 

```{r}
countbefore<-0
countafter<-0
for(i in 1:10){
  countbefore<-countbefore+1
  print(paste("before =",countbefore))
  print(paste("after =",countafter))
  countafter<-countafter+1
}
```

Read through the outputs above carefully to make sure you understand how the loops work. When you are confident you understand, then write a new for loop and write down the predicted output. Run the loop to check if you were right.

### Nested Loops

Counters are particularly valuable when you have a nested loop, which is just one loop inside of another.

In the example below, we are first looping through a vector of length 3, tracked with `i`. Then **for each i** we do a second loop, tracked by `j`.

This time, try to predict the output BEFORE you run the loop. Write it down, then run the loop to check your answer.

```{r}
LoopCount<-0
for(i in 1:3){
  for(j in 1:4){
    LoopCount<-LoopCount+1
    print(paste("i = ",i))
    print(paste("j = ",j))
    print(paste("Loop =",LoopCount))
  }
}
```


### `while` loop

The `while` is another kind of loop, but instead of looping through a predefined set of variables, we iterate until some condition is met inside of the loop. This is called the **exit condition**.

Often, the `while` loop is used in optimization algorithms, where many calculations are run until some optimum or threshold value is reached.

One common coding error associated with `while` loops is that the exit condition is never reached, causing your computer to run an infinite loop.

Here's a simple while loop, which will continue until `count` is greater than or equal to `X`.

```{r}
count<-0
while (count < X){
  print(count)
  count<-count+1
}
```

## Packages

As noted above, **functions** in R use brackets `()` and generally have **input** and **output** objects as well as **parameters** that affect their behaviour.

All of the functions in this tutorial are automatically loaded when you start R. There are many more functions available from developers. For example, our lab developed the `baRcodeR` package for creating unique identifier codes with printable barcodes and data sheets to help with sample management and data collection. 

A **package** in R is a set of functions grouped together. For example, the `stats` package is automatically loaded when you run R and contains many useful functions. You can see what package a function belongs to at the beginning of the help file:

```{r, eval=F}
?cor
```

### Installing

Before you can use a new function from a package that isn't installed with R, you first have to install the package on your computer. You only have to do this once per computer. However, it is a good idea to update the package frequently, especially when you update your version of R. This ensures that you are using the most recent version of the package.

Note that **installing** a package just downloads it from an online '**repository**' and saves to your computer.

Packages are installed with `install.packages()`, with the package indicated with single or double quotation marks. You may be asked for a repository, in which case choose one that is geographically close to you.

```{r, eval=F}
install.packages('baRcoeR')
```

### Loading

Once you have installed a package, you can access it two ways. 

#### 1. Library

You can load the package using the `library()` function, giving you access to functions contained within it:

```{r, eval=F}
library(baRcodeR)
make_labels()
```

#### 2. Function

You can run a function without loading the whole package:

```{r, eval=F}
baRcodeR::make_labels()
```

This translates to "Run the `make_labels` function from the `baRcodeR` library.

The first method is more common, especially for the commonly used functions covered in these self-tutorials. However, the second method is convenient if you just want to use one function from a large library that take up a lot of space. 

More importantly, some packages have **functions with the same names**. Let's say you load two packages `pkgA` and `pkgB` that have different functions but both are called `cor`. When you run the `cor` function, R will assume you want the one from the package that was most recently loaded using the `library()` function. However, you can over-ride this with the second method:

```{r, eval=F}
pkgA::cor()
pkgB::cor()
```


#### Library vs Package

The terms **library** and **package** are often used interchangeably. Technically, the **package** is the collection of functions whereas the **library** is the specific folder where the R packages are stored. A library may contain more than one package.

For the most part, you just need to know that a package and a library are a collection of functions.

## Readable code

It's important to make your code readable and interpretable by collaborators, peer reviewers, and yourself 6 months from now. There are lots of opinions on this but here are a few basic suggestions:

  1. Add documentation to explain what you are doing
  2. Add spacing between parameters to improve readability
  3. Add spacing on either side of `<-` when making objects
  3. Break long functions into multiple lines; add the line break after a `,` or `+`
  2. Follow these suggestions for object/column/file names
    a. Try to keep your names short and concise but meaningful 
    b. Use underscore `_` to improve readability and avoid `.`
    c. Always start with a letter
    d. Avoid symbols
  
  Bad | Good
  ------------|---------------
  `sum(X,na.rm=T)` | `sum(X, na.rm=T)`
  `data.frame(X, Y, ..., data=...)` | `data.frame(X, Y,` <br> ` ..., data=...)`
  `X` | `Mass`
  `Days.To.First.Flower` | `Flwr_Days` or `FDays`
  `10d.Height` | `Ht10d`
  `Length*Width` | `LxW`

To take your code to the next level, look into the [Tidyverse Style Guide](https://style.tidyverse.org/index.html)

## TEST yourself:

Are you ready to test your knowledge?

If so, click [HERE](https://colauttilab.github.io/RCrashCourse/1_fundamentals_test.html)



