# Fundamentals

## Introduction

This chapter provides a rapid breakdown of the core functionality of R. There is a lot to cover in a very short time. Remember that you can only learn coding through repetition.

Before you begin, you should have R and R Studio installed.

**It is important that you physically participate and code along with the examples. Type everything out. The physical act of typing into R and troubleshooting any errors you get is a crucial part of the learning process.**

<br> 

*** 

<br>

## R Basics

Make comments inside your code. Very important (unless you are using R markdown or R notebooks)!

```{r}
# Use hastags to make comments - not read by the R console
# Use other characters and blank lines to improve readability:
# ------------------------- 
# My first R script 
# Today's Date
# -------------------------
# Add a summary description of what the script does
# This script will...
# And annotate individual parts of the script
```


### Basic Math

You can do basic mathematical equations in R. 

> Yes, type these out!

```{r}
10+2 # add
10-2 # subtract
10*2 # multiply
10/2 # divide
10^2 # exponent
```


### Functions

R uses **functions**. Each function has a name and is followed by brackets `function()`.

Inside the brackets we can define input values and parameters. 


### `c()

The **concatenate** function `c()` is a very important function in R that is used to group items together:

```{r}
c(1,2,3,5)
```


### Math Functions

Here are some basic mathematical functions

```{r}
abs(-10) # absolute value
sqrt(10-1) # square root (with subtraction)
log(10) # natural log
log10(10) # log base 10
exp(1) # power of e
sin(pi/2) # sine function
asin(1) # inverse sine
cos(pi) # cosine
acos(-1) # inverse cosine
tan(0) # tangent
atan(0) # inverse tangent
```


### Round/Truncate

Rounding and truncating numbers 

```{r}
round(pi,digits=3) # standard rounding to 3 digits
floor(pi) # round down to closest whole number
ceiling(pi) # round up to closest whole number
signif(pi,digits=2) # round to keep 2 significant digits
```


### Logic Operators

An **operator** is used to compare values. 

```{r}
1 > 2 # greater than
1 < 2 # less than
1 <= 2 # less than or equal to
1 == 1 # equal to
1 == 2 | 1 == 1 # | means 'OR'
1 == 2 & 1 == 1 # & means 'AND' 
1 == 1 & 1 == 1
```

> Note: `!` is a negation/inverse operator

```{r}
1 != 1 # not equal to
```

### Group Comparison

Instead of `|`, you can us `%in%` with `c()` to check a large number of values.

```{r}
1 %in% c(1,2,3,4,5,6,7,8,9,10)
```

### Random Numbers

It is very easy to generate some random numbers from different distributions. This is very useful for modelling and testing your code.

```{r}
runif(10,min=0,max=1) # random numbers from a uniform distribution (each number equally likely to be chosen)
rnorm(10,mean=0,sd=1) # random numbers from a normal distribution
rpois(10,lambda=10) # poisson distribution
rbinom(10,size=1,prob=0.5) # binomial sampling (e.g. 10 coin tosses where heads=1 tails=0)
rbinom(10,size=10,prob=0.5) # binomial repeated sampling  (e.g. number of heads in 10 coin tosses, repeated 10 times)
```

Fun fact, random numbers generated by a computer are generated by a calculation from a 'seed' number, so they are never truly random. They act random because the seed number might be something like the remainder of a calculation involving the current year/day/hour/minute/millisecond of your computer's internal clock.

It's not just philosophical, it is also useful for testing and debugging since you can set the seed to generate the same 'random' numbers.

We can recreate the exact random number using the `set.seed()` function.

Compare these outputs:

```{r}
runif(5)
runif(5)
set.seed(3)
runif(5)
set.seed(3)
runif(5)
set.seed(172834782)
runif(5)
set.seed(172834782)
runif(5)
runif(5)
```

### Combining objects

Use `c()` to concatenate single objects

```{r}
Nums<-c(1,2,5)
c(Nums,"string")
```

Use `:` to include a range of numbers

```{r}
1:10
100:90
-1:1
```

Use `cbind()` to bind columns and `rbind` to bind rows

```{r}
cbind(1:10,10:1)
rbind(1:10,10:1)
```


<br>

*** 

<br>

## Data Types

Programming languages like R use different data types. 

It's very important to understand data types in order to properly encode and analyze data in R. It's very common to have errors in statistical analyses caused by the wrong kind of data. For example, if you have 3 experimental groups coded as 1, 2 and 3 then these should be coded and analyzed as **factors** not **numeric** variables.

Type | Example | Description
--------|-------|----------------------------------
`string` |`"String"`| Strings are the most common and versatile and can be defined with single `''` or double `""` quotation marks. The downside of strings is that you can't do any kind of equations.
`numeric` |`12.421`| Numeric variables are rational numbers
`integer` |`12`| Integers are whole numbers and may be positive or negative (no decimal)
`complex` |`0+12.43i`| Complex numbers include real and imaginary numbers
`boolean` | `T` or `TRUE` | Boolean or **logical** variables are either true or false (Note always capital)
`factors` Factors are a special type of data that may include strings and/or numbers but have a limited number of classes. Factors are often used to code groups in statistical models. 

Note that computers cannot store irrational numbers, they have to be rounded to some (tiny) decimal place.

<br>

*** 

<br>

## Objects

R supports **Object-Oriented Programming (OOP)**, which is a programming style that defines and manipulates **objects**

An **object** in R can be a lot of things, but an easy way is to think of a spreadsheet (example Microsoft Excel). 

A spreadsheet has columns organized into rows and columns, and may have multiple sheets.

### Cells

The most basic object is a single value. For example, a string

```{r}
X<-"string"
```

> Why no output? 

When we wrote: `X<-"string"`

R created the object called **X**, so no output is produced. 

There are a few options To see the contents of **X**:

```{r}
print(X)
paste(X)
X
```

`print()` Is most generic and versatile for providing feedback while running complex scripts (e.g. during loops, Bash scripts, etc)

`paste()` Converts objects to a string, we'll come back to this.

Generally `print()` or `paste()` are preferred over calling the object directly.

### Vector 

A vector is a one-dimensional array of cells. This could be a row or column in our spreadsheet example.

Each cell within the vector has an 'address' -- a number corresponding to the cell ranging from 1 to N, where N is the number of cells.

The number of cells in a vector is called the **length** of the vector.

All items in a vector must be of the same type. If you mix numbers and text, then the whole vector will be formatted to the simplest type. For example, if you include a string with any other fomat, then the whole vector will be treated as a string:

```{r}
Xvec<-c(1.1829378,X,1:10,"E", "Computational Biology", 100:90)
Xvec
```

> **Protip**: A common problem when importing data to R occurs when a column of numeric data includes at least one text value (e.g.  "missing" or "< 1"). R will treat the entire column as text rather than numeric values. Watch for this when working with real data!

#### Subset a vector

Use square brackets `[]` to subset a vector

```{r}
Xvec[1]
Xvec[13]
Xvec[1:3]
```

### Matrices 

A matrix is a 2-D array of cells, equivalent to one sheet in a spreadsheet program. 

```{r}
Xmat<-matrix(Xvec,nrow=6)
Xmat
```

#### Subset

**Notice** the square brackets along the top and left side? 

These show the 'address' of each element in the matrix. We can subset with square brackets, just like we did with vectors. Since there are two dimensions, we need to specify two numbers:

`[row,column]`

```{r}
Xmat[1,3]
```

Or leave it blank if you want the whole row or column:

```{r}
Xmat[1,]
Xmat[,3]
```


### Tensors

**Tensors** are the general term for a grid with N dimensions. We've already seen a few different tensors:

Name | Tensor Dimension
--------|----
Cell | 0
Vector | 1
Matrix | 2
Array | 3+

Another common term for tensor is **array**. In R you can build tensors by adding as many dimensions as you need using the `array()` function

```{r}
Xarray<-array(0, dim=c(3,3,2)) # 3 dimensions
Xarray
```

Notice how 3rd dimension is sliced to print out in 2D

<br>

Higher-order arrays are possible, but a bit tricky to read on a 2-dimensional screen

```{r}
Xarray<-array(rnorm(64), dim=c(2,2,2,2,2,2)) # 6 dimensions
```

Once you get the hang of it, it's easy to subset. Just think of each dimension, separated by commas.

```{r}
Xarray[1:2,1:2,1,1,1,1]
Xarray[1:2,1,1,1:2,1,1]
```

> Why are these numbers not the same?

Look at the `array[]` function and compare to the 6-D tensor to understand how this works

## Matrix Algebra

R is pretty handy for matrix calculations that are very time consuming to do by hand or in a spreadsheet program

```{r}
## Create some vectors to play with
X<-c(1:10)
X
Y<-c(1:10*0.5)
Y

## Use pretty much any standard operator for element-by element calculations
X*Y # Multiply corresponding element (e.g. X[1]*Y[1], then X[2]*Y[2], etc)
X+Y
X/Y
X^Y
log(X)
exp(Y)

## More advanced matrix algebra
X%*%Y # Matrix multiplication (e.g.  X[1]*Y[1]+X[2]*Y[2]...)
sum(X*Y) == X%*%Y
Z<-X[1:4]%o%Y[1:3] # Outer product
Z
t(Z) # Transpose
crossprod(X[1:4],Z) # Cross product
crossprod(Z) # Cross product of Z and t(Z) a.k.a. Z'Z
diag(4) # Identity matrix, 4x4 in this case
diag(Z) # Diagonal elements of Z 
```

### PCA

One example of a matrix calculation is principal components analysis. This is covered in more detail in the [PCA Tutorial](https://colauttilab.github.io/RIntroML/2_PCA.html).

PCA is widely used in biology, from community ecology and metagenomics to gene expression and morphometrics. It also has many applications outside of biology. For now, just know that it is easy to run a PCA using the `prcomp()` function:

```{r}
prcomp(Z, cor=T) 
```

## Lists 

Tensors generally all have the same data type and sub-dimension. For example, if you want to combine two 2-d matrices into a single tensor (3rd dimension) then the individual matrices have to have the same number of rows and columns, and the same data type.

Lists are useful for mixxing data types, and can combine different dimensions cells, vectors, and higher-order arrays

Each element needs a name

```{r}
MyList<-list(name="SWC",potpourri=Xvec,numbers=1:10)
MyList
```

### Subset

There are a few different ways to subset a list object

```{r}
MyList$numbers # Use $ to subset by name
MyList[3] # A 'slice' of MyList
MyList[[3]] # An 'extract' of MyList
```

> What's the difference between `[]` and `[[]]`?

Look carefully at the output above; notice how the `[]` includes `$numbers` but the `[[]]` includes only the values? This is important if you want to use the slice:

```{r, error=TRUE}
2*MyList[[3]]
2*MyList[3]
```

### Output

> **Protip**: Many analysis functions in R output as lists (e.g. statistical packages)

For example, the output of `prcomp`:

```{r}
prcomp(Z) 
names(prcomp(Z))
prcomp(Z)$center
prcomp(Z)$scale
```

## `print()` and `paste()`

The `print` function is the go-to function for printing output to the user. The `paste` function is for combining things together. 

Paste is a versatile function for manipulating output:

```{r}
paste("Hello World!") # Basic string
paste("Hello","World!") # Concatenate two strings
paste(1:10) # Paste numbers as strings
paste(1:10)[4] # Note that each number is a separate cell in a vector of strings
as.numeric(paste(1:10)) # Convert back to numbers
paste(1:10,collapse=".") # Collapse separate cells to produce a single string
```

Note what happens if we combine objects of different length:

```{r}
paste("Hello",1:10,sep="-") # Note 
```

It is not uncommon to nest a paste function within a print:

```{r}
print(paste("Hello",1:10,sep="-"))
```

This would be useful inside of a `for` loop (see below) where the output of `paste` is not shown on the screen if used inside of a loop, whereas the output of `print` is.

### ? for HELP

Whenever you are learning a new function, you should use `?` and carefully read about all the parameters and outputs. The explanations can be a bit technical, which is intimidating at first. But after enough practice you will start to understand more and more of the descriptions.

```{r eval=F}
?paste
```

<br>

*** 

<br>


## Data

So far we've done everything within the R environment. If we quit R then everything we have made will be removed from memory and we'll have to start all over. Therefore, it can be useful to save and load data from external files.

### Working Directory

The **working directory** is the place where R looks to load or save your files. You can figure out what your current working directory is with the `getwd()` function

```{r, eval=F}
getwd()
```

Or you can set a specific working directory. Here's one example:

```{r, eval=F}
setwd("C:/Users/ColauttiLab/Documents")
```

Did you type out the above line? You should! Remember, going through and typing everything out is one of the most effective ways to learn to code. So do it now

Okay, so you probably have an error unless you are working in Windows and for some reason have a ColauttiLab username on your computer. Now try changing to a different directory on your computer.

If you are a mac user, you can just ignore the `C:` part:

```{r, eval=F}
setwd("/Users/ColauttiLab/Documents")
```

#### Relative Path

The above examples of `setwd()` us an **absolute** path. You can also use a **relative** path. For example, if we have a folder called `Data` inside our `Documents` folder, and our current working directory is one of the two examples above, we can use a relative path name to set the `Data` folder as the working directory. Before you type this out, you should make a folder called `Data` inside of your current working directory:

```{r, eval=F}
setwd("./Data")
```

The `.` means "Inside of my current directory" and the `/Data` means "find the Data folder"

now try this:

```{r, eval=F}
getwd()
setwd("..")
getwd()
```

Compare the working directories. The `..` means "Go to the parent directory"

The neat thing about relative directories is that it makes it easy to share code between Windows, MacOS and Linux/Unix. In fact, these commands come from Linux. You can check out the [Linux Crash Course](https://colauttilab.github.io/LinuxCrashCourse/Linux-Fundamentals.html) for more detail.

### Import

Download [This Data File](https://colauttilab.github.io/RCrashCourse/FallopiaData.csv) and save in a folder called `Data` inside of your current working directory.

We can use the `read.csv` to read a 'comma-delimited file' and import it into an object called `MyData`

```{r,eval=F}
MyData<-read.csv("Data/FallopiaData.csv",header=T) # Header=T tells read.csv to interpret first row as column labels
```

```{r,echo=F}
MyData<-read.csv("https://colauttilab.github.io/RCrashCourse/FallopiaData.csv",header=T)
```

A `.csv` file is just a text file with special formatting that can be read into a program like Microsoft Excel or R to translate the text file into a data matrix.

**Important**: In R, objects created by `read.csv` and other `read.?` functions are special objects called `data.frame` objects.

### `data.frame`

A `data.frame` is a special type of 2D matrix with additional indexing information for rows/columns of data

This format is partly why R is so useful for data analysis

<br>

There are a number of useful functions for inspecting a `data.frame` object

```{r}
names(MyData) # See column names
head(MyData) #  Show first six rows of data
tail(MyData) #  Show last six rows of data
dim(MyData) # Number of rows x columns (or 'dimension') of the data object
nrow(MyData) # Number of rows only
ncol(MyData) # Number of columns only
str(MyData) #  Data 'structure' - types of variables
```

> Protip: `str()` is very important for functions that use data.frames including statistical analysis and plotting

Pay careful attention to 'int' vs 'num' vs 'factor'. These are the data types, as noted above. 

Here's an example of data types gone rogue: In an analysis of variance (ANOVA), you want a 'factor' as a predictor. But in linear regression you want 'int' or 'num' as a predictor. If you code your factor (e.g. treatment) as a number (e.g. 1-4) then your `data.frame` will treat it as an integer. When you run a linear model, you will be running a regression rather than ANOVA.

### Subset

The `data.frame` object can be subset, just like a matrix

```{r}
MyData[1,] # Returns first row of data.frame
MyData[1,1] # Returns first value of data.frame
```

In addition, you can define the column names

```{r}
MyData[,"PotNum"] # Returns values in "PotNum" column
MyData$PotNum # Another way to get the same output
subset(MyData,Scenario=="extreme") # Subset data where the Scenario column == 'extreme'
levels(MyData$Scenario)
```

### New Columns

It's easy to add new columns to a data frame. For example, to add a new column that is the sum of two others

```{r}
MyData$Total<-MyData$Symphytum + MyData$Silene + MyData$Urtica
names(MyData)
print(MyData$Total)      
```

<br>

*** 

<br>


## Other Functions

There are a few more useful functions for inspecting your data.

### `unique`

Find all the unique values within a vector using `unique`

```{r}
unique(MyData$Nutrients)
```

### `duplicated`

Look at each value in a vector and return a `TRUE` if it is duplicated and `FALSE` if it is unique

```{r}
duplicated(MyData$Nutrients)
```

This is a good example of a Boolean vector, which can be used to subset your data.

```{r}
MyData$Nutrients[duplicated(MyData$Nutrients)]
```

Note that only the `TRUE` values are returned (duplicated)

### `aggregate`

Quickly calculate means of one vector (Total) for each value of a grouping variable (Nutrients)

```{r}
aggregate(MyData$Total,list(MyData$Nutrients), mean) 
```

The `~` provides an alternative way to write this function. In R the `~` usually means 'by' and is often used in statistical models. Here we can say aggregate Total 'by' Nutrients grouping

```{r}
aggregate(Total ~ Nutrients, data=MyData, mean)
```

The nice thing about doing it this way is that we preserve the column name (Total instead of x).

You can also use this to calculate means across different grouping variables

```{r}
aggregate(Total ~ Nutrients*Taxon*Scenario, data=MyData, mean)
```

Note that `mean` is just the `mean()` function in R. We can use other functions, like the standard deviation `sd`:


```{r}
aggregate(Total ~ Nutrients, data=MyData, sd) 
```

### tapply

The `tapply` function is a more general way to replicate functions. 

```{r}
tapply(MyData$Total, list(MyData$Nutrients), mean) # calculate means

```

Compare the two outputs with `aggregate` above

### Save

Just as we can load FROM external files, we can save TO external files

```{r, eval=F}
## Calulate means
NutrientMeans<-tapply(MyData$Total,list(MyData$Nutrients),mean)
## Save means as .csv file
write.csv(NutrientMeans,"MyData_Nutrient_Means.csv")
```

You should see this file in your working directory.

<br>

*** 

<br>

## Flow control

Think of your data analysis as a stream flowing from the raw data at the headwaters and flowing down to the end, exiting as a full analysis with graphics, stats, and interpretation.

There are different ways we can control the flow of the water. The simplest is just to write a sequence of lines of code, with the output of one line of code forming the input of the next. There are several examples of this above:

```
A<-functionA()
B<-functionB(A)
C<-functionC(B)
```

But sometimes we may want to do the same function or analysis only if the input meets certain criteria. Or we may want to reiterate the same analysis multiple times on different inputs. This is where more advanced flow control comes in handy.

To start, let's make up a couple of objects to play with:

```{r}
X<-21
Xvec<-c(1:10,"string")
```

### `if`

The `if` statement uses an **operator** (see above) to asses whether the value is `TRUE` or `FALSE`:

```{r}
if(X > 100){ # Greater-than operator assessing whether X is greater than 100
  print("X > 100") # What to do if TRUE (X greater than 100)
} else { 
  print("X <= 100") # What do do if FALSE (X less than 100)
}
```

> **NOTE**: A common 'rookie' mistake is to leave out a bracket or use the wrong type. 

Use regular brackets for the if function `if()` followed by two sets of curly brackets `{}else{}`.

Break up across multiple lines to improve readability. Note that you don't need an `else{}` part if you just want to 'do nothing' when `FALSE`.

```{r}
if(1 > 0){print ("yup")}
```

### ifelse

The `ifelse` is a more compact version for simple comparisons. The following code does the same as above

```{r}
ifelse(X > 100, print("X > 100"), print("X <= 100"))
```


### `for` loop

A loop does the same thing over and over again until some condition is met. In the case of a `for` loop, we set a 'counter' variable and loop through each value of the counter variable. Here are a few examples:

```{r}
# Loop through numbers from 1 to X
for (i in 1:X){
  print(paste(X,i,sep=":"))
}
# Loop through elements of a vector directly
for (i in Xvec){
  print(i)
}
# Use an index to loop through the elements
for (i in 1:length(Xvec)){
  print(Xvec[i])
}
```

Note that in each case there is a vector and we loop through each cell in the vector. The `i` keeps track of the cell value in each iteration of the loop.

Loops can be tricky, and the only way to really learn them is to try to write a bunch. Whenever you find yourself writing similar code more than 2 or 3 times, challenge yourself to try to do it as a loop.

In addition to looping through a vector, it can often be useful to include a counter variable. 

One thing to watch out for is what part of the loop you want to update the counter variable. USUALLY it will be at the beginning

```{r}
count1<-1
count10<-1

for(i in 1:10){
  print(paste("count1 =",count1))
  print(paste("count10 =",count10))
  count1<-count1+1
  count10<-count10*10
}
```

or at the end. 

```{r}
countbefore<-0
countafter<-0
for(i in 1:10){
  countbefore<-countbefore+1
  print(paste("before =",countbefore))
  print(paste("after =",countafter))
  countafter<-countafter+1
}
```

Read through the outputs above carefully to make sure you understand how the loops work. When you are confident you understand, then write a new for loop and write down the predicted output. Run the loop to check if you were right.

### Nested Loops

Counters are particularly valuable when you have a nested loop, which is just one loop inside of another.

In the example below, we are first looping through a vector of length 3, tracked with `i`. Then **for each i** we do a second loop, tracked by `j`.

This time, try to predict the output BEFORE you run the loop. Write it down, then run the loop to check your answer.

```{r}
LoopCount<-0
for(i in 1:3){
  for(j in 1:4){
    LoopCount<-LoopCount+1
    print(paste("i = ",i))
    print(paste("j = ",j))
    print(paste("Loop =",LoopCount))
  }
}
```


### `while` loop

The `while` is another kind of loop, but instead of looping through a predefined set of variables, we iterate until some condition is met inside of the loop. This is called the **exit condition**.

Often, the `while` loop is used in optimization algorithms, where many calculations are run until some optimum or threshold value is reached.

One common coding error associated with `while` loops is that the exit condition is never reached, causing your computer to run an infinite loop.

Here's a simple while loop, which will continue until `count` is greater than or equal to `X`.

```{r}
count<-0
while (count < X){
  print(count)
  count<-count+1
}
```

## Packages

As noted above, **functions** in R use brackets `()` and generally have **input** and **output** objects as well as **parameters** that affect their behaviour.

All of the functions in this tutorial are automatically loaded when you start R. There are many more functions available from developers. For example, our lab developed the `baRcodeR` package for creating unique identifier codes with printable barcodes and data sheets to help with sample management and data collection. 

A **package** in R is a set of functions grouped together. For example, the `stats` package is automatically loaded when you run R and contains many useful functions. You can see what package a function belongs to at the beginning of the help file:

```{r, eval=F}
?cor
```

### Installing

Before you can use a new function from a package that isn't installed with R, you first have to install the package on your computer. You only have to do this once per computer. However, it is a good idea to update the package frequently, especially when you update your version of R. This ensures that you are using the most recent version of the package.

Note that **installing** a package just downloads it from an online '**repository**' and saves to your computer.

Packages are installed with `install.packages()`, with the package indicated with single or double quotation marks. You may be asked for a repository, in which case choose one that is geographically close to you.

```{r, eval=F}
install.packages('baRcoeR')
```

### Loading

Once you have installed a package, you can access it two ways. 

#### 1. Library

You can load the package using the `library()` function, giving you access to functions contained within it:

```{r, eval=F}
library(baRcodeR)
make_labels()
```

#### 2. Function

You can run a function without loading the whole package:

```{r, eval=F}
baRcodeR::make_labels()
```

This translates to "Run the `make_labels` function from the `baRcodeR` library.

The first method is more common, especially for the commonly used functions covered in these self-tutorials. However, the second method is convenient if you just want to use one function from a large library that take up a lot of space. 

More importantly, some packages have **functions with the same names**. Let's say you load two packages `pkgA` and `pkgB` that have different functions but both are called `cor`. When you run the `cor` function, R will assume you want the one from the package that was most recently loaded using the `library()` function. However, you can over-ride this with the second method:

```{r, eval=F}
pkgA::cor()
pkgB::cor()
```


#### Library vs Package

The terms **library** and **package** are often used interchangeably. Technically, the **package** is the collection of functions whereas the **library** is the specific folder where the R packages are stored. A library may contain more than one package.

For the most part, you just need to know that a package and a library are a collection of functions.

## Readable code

It's important to make your code readable and interpretable by collaborators, peer reviewers, and yourself 6 months from now. There are lots of opinions on this but here are a few basic suggestions:

  1. Add documentation to explain what you are doing
  2. Add spacing between parameters to improve readability
  3. Add spacing on either side of `<-` when making objects
  3. Break long functions into multiple lines; add the line break after a `,` or `+`
  2. Follow these suggestions for object/column/file names
    a. Try to keep your names short and concise but meaningful 
    b. Use underscore `_` to improve readability and avoid `.`
    c. Always start with a letter
    d. Avoid symbols
  
  Bad | Good
  ------------|---------------
  `sum(X,na.rm=T)` | `sum(X, na.rm=T)`
  `data.frame(X, Y, ..., data=...)` | `data.frame(X, Y,` <br> ` ..., data=...)`
  `X` | `Mass`
  `Days.To.First.Flower` | `Flwr_Days` or `FDays`
  `10d.Height` | `Ht10d`
  `Length*Width` | `LxW`

To take your code to the next level, look into the [Tidyverse Style Guide](https://style.tidyverse.org/index.html)

## TEST yourself:

Are you ready to test your knowledge?

If so, click [HERE](https://colauttilab.github.io/RCrashCourse/1_fundamentals_test.html)



