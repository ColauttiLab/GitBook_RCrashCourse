# Fundamentals

## Introduction

This chapter provides a rapid breakdown of the core functionality of R. There is a lot to cover in a very short time. Remember that you can only learn coding through repetition.

Before you begin, you should have R and R Studio installed.

**It is important that you physically participate and code along with the examples. Type everything out. The physical act of typing into R and troubleshooting any errors you get is a crucial part of the learning process.**

<br> 

*** 

<br>

## R Basics

Make comments inside your code. Very important (unless you are using R markdown or R notebooks)!


```r
# Use hastags to make comments - not read by the R console
# Use other characters and blank lines to improve readability:
# ------------------------- 
# My first R script 
# Today's Date
# -------------------------
# Add a summary description of what the script does
# This script will...
# And annotate individual parts of the script
```


### Basic Math

You can do basic mathematical equations in R. 

> Yes, type these out!


```r
10+2 # add
```

```
## [1] 12
```

```r
10-2 # subtract
```

```
## [1] 8
```

```r
10*2 # multiply
```

```
## [1] 20
```

```r
10/2 # divide
```

```
## [1] 5
```

```r
10^2 # exponent
```

```
## [1] 100
```


### Functions

R uses **functions**. Each function has a name and is followed by brackets `function()`.

Inside the brackets we can define input values and parameters. 


### `c()

The **concatenate** function `c()` is a very important function in R that is used to group items together:


```r
c(1,2,3,5)
```

```
## [1] 1 2 3 5
```


### Math Functions

Here are some basic mathematical functions


```r
abs(-10) # absolute value
```

```
## [1] 10
```

```r
sqrt(10-1) # square root (with subtraction)
```

```
## [1] 3
```

```r
log(10) # natural log
```

```
## [1] 2.302585
```

```r
log10(10) # log base 10
```

```
## [1] 1
```

```r
exp(1) # power of e
```

```
## [1] 2.718282
```

```r
sin(pi/2) # sine function
```

```
## [1] 1
```

```r
asin(1) # inverse sine
```

```
## [1] 1.570796
```

```r
cos(pi) # cosine
```

```
## [1] -1
```

```r
acos(-1) # inverse cosine
```

```
## [1] 3.141593
```

```r
tan(0) # tangent
```

```
## [1] 0
```

```r
atan(0) # inverse tangent
```

```
## [1] 0
```


### Round/Truncate

Rounding and truncating numbers 


```r
round(pi,digits=3) # standard rounding to 3 digits
```

```
## [1] 3.142
```

```r
floor(pi) # round down to closest whole number
```

```
## [1] 3
```

```r
ceiling(pi) # round up to closest whole number
```

```
## [1] 4
```

```r
signif(pi,digits=2) # round to keep 2 significant digits
```

```
## [1] 3.1
```


### Logic Operators

An **operator** is used to compare values. 


```r
1 > 2 # greater than
```

```
## [1] FALSE
```

```r
1 < 2 # less than
```

```
## [1] TRUE
```

```r
1 <= 2 # less than or equal to
```

```
## [1] TRUE
```

```r
1 == 1 # equal to
```

```
## [1] TRUE
```

```r
1 == 2 | 1 == 1 # | means 'OR'
```

```
## [1] TRUE
```

```r
1 == 2 & 1 == 1 # & means 'AND' 
```

```
## [1] FALSE
```

```r
1 == 1 & 1 == 1
```

```
## [1] TRUE
```

> Note: `!` is a negation/inverse operator


```r
1 != 1 # not equal to
```

```
## [1] FALSE
```

### Group Comparison

Instead of `|`, you can us `%in%` with `c()` to check a large number of values.


```r
1 %in% c(1,2,3,4,5,6,7,8,9,10)
```

```
## [1] TRUE
```

### Random Numbers

It is very easy to generate some random numbers from different distributions. This is very useful for modelling and testing your code.


```r
runif(10,min=0,max=1) # random numbers from a uniform distribution (each number equally likely to be chosen)
```

```
##  [1] 0.1388931 0.2776045 0.7852248 0.9423432 0.4907170 0.3168890 0.6232029
##  [8] 0.5839645 0.2872892 0.2574184
```

```r
rnorm(10,mean=0,sd=1) # random numbers from a normal distribution
```

```
##  [1] -1.2379441  1.5559149  2.1739250 -0.8888026  0.1812213  0.5298556
##  [7]  0.3341936  0.6536453 -0.5992498  0.5675925
```

```r
rpois(10,lambda=10) # poisson distribution
```

```
##  [1] 13  8 12 12  8 10  9 12 10 10
```

```r
rbinom(10,size=1,prob=0.5) # binomial sampling (e.g. 10 coin tosses where heads=1 tails=0)
```

```
##  [1] 1 0 1 0 1 1 1 0 0 1
```

```r
rbinom(10,size=10,prob=0.5) # binomial repeated sampling  (e.g. number of heads in 10 coin tosses, repeated 10 times)
```

```
##  [1] 2 7 2 3 8 4 5 7 6 4
```

Fun fact, random numbers generated by a computer are generated by a calculation from a 'seed' number, so they are never truly random. They act random because the seed number might be something like the remainder of a calculation involving the current year/day/hour/minute/millisecond of your computer's internal clock.

It's not just philosophical, it is also useful for testing and debugging since you can set the seed to generate the same 'random' numbers.

We can recreate the exact random number using the `set.seed()` function.

Compare these outputs:


```r
runif(5)
```

```
## [1] 0.7604204 0.5491574 0.5501070 0.8136757 0.7006903
```

```r
runif(5)
```

```
## [1] 0.2736914 0.9224710 0.2831013 0.8192767 0.5443611
```

```r
set.seed(3)
runif(5)
```

```
## [1] 0.1680415 0.8075164 0.3849424 0.3277343 0.6021007
```

```r
set.seed(3)
runif(5)
```

```
## [1] 0.1680415 0.8075164 0.3849424 0.3277343 0.6021007
```

```r
set.seed(172834782)
runif(5)
```

```
## [1] 0.13729290 0.18587365 0.01860484 0.88440060 0.21414154
```

```r
set.seed(172834782)
runif(5)
```

```
## [1] 0.13729290 0.18587365 0.01860484 0.88440060 0.21414154
```

```r
runif(5)
```

```
## [1] 0.19787402 0.84870074 0.27303904 0.12225215 0.08365613
```

### Combining objects

Use `c()` to concatenate single objects


```r
Nums<-c(1,2,5)
c(Nums,"string")
```

```
## [1] "1"      "2"      "5"      "string"
```

Use `:` to include a range of numbers


```r
1:10
```

```
##  [1]  1  2  3  4  5  6  7  8  9 10
```

```r
100:90
```

```
##  [1] 100  99  98  97  96  95  94  93  92  91  90
```

```r
-1:1
```

```
## [1] -1  0  1
```

Use `cbind()` to bind columns and `rbind` to bind rows


```r
cbind(1:10,10:1)
```

```
##       [,1] [,2]
##  [1,]    1   10
##  [2,]    2    9
##  [3,]    3    8
##  [4,]    4    7
##  [5,]    5    6
##  [6,]    6    5
##  [7,]    7    4
##  [8,]    8    3
##  [9,]    9    2
## [10,]   10    1
```

```r
rbind(1:10,10:1)
```

```
##      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]
## [1,]    1    2    3    4    5    6    7    8    9    10
## [2,]   10    9    8    7    6    5    4    3    2     1
```


<br>

*** 

<br>

## Data Types

Programming languages like R use different data types. 

It's very important to understand data types in order to properly encode and analyze data in R. It's very common to have errors in statistical analyses caused by the wrong kind of data. For example, if you have 3 experimental groups coded as 1, 2 and 3 then these should be coded and analyzed as **factors** not **numeric** variables.

Type | Example | Description
--------|-------|----------------------------------
`string` |`"String"`| Strings are the most common and versatile and can be defined with single `''` or double `""` quotation marks. The downside of strings is that you can't do any kind of equations.
`numeric` |`12.421`| Numeric variables are rational numbers
`integer` |`12`| Integers are whole numbers and may be positive or negative (no decimal)
`complex` |`0+12.43i`| Complex numbers include real and imaginary numbers
`boolean` | `T` or `TRUE` | Boolean or **logical** variables are either true or false (Note always capital)
`factors` Factors are a special type of data that may include strings and/or numbers but have a limited number of classes. Factors are often used to code groups in statistical models. 

Note that computers cannot store irrational numbers, they have to be rounded to some (tiny) decimal place.

<br>

*** 

<br>

## Objects

R supports **Object-Oriented Programming (OOP)**, which is a programming style that defines and manipulates **objects**

An **object** in R can be a lot of things, but an easy way is to think of a spreadsheet (example Microsoft Excel). 

A spreadsheet has columns organized into rows and columns, and may have multiple sheets.

### Cells

The most basic object is a single value. For example, a string


```r
X<-"string"
```

> Why no output? 

When we wrote: `X<-"string"`

R created the object called **X**, so no output is produced. 

There are a few options To see the contents of **X**:


```r
print(X)
```

```
## [1] "string"
```

```r
paste(X)
```

```
## [1] "string"
```

```r
X
```

```
## [1] "string"
```

`print()` Is most generic and versatile for providing feedback while running complex scripts (e.g. during loops, Bash scripts, etc)

`paste()` Converts objects to a string, we'll come back to this.

Generally `print()` or `paste()` are preferred over calling the object directly.

### Vector 

A vector is a one-dimensional array of cells. This could be a row or column in our spreadsheet example.

Each cell within the vector has an 'address' -- a number corresponding to the cell ranging from 1 to N, where N is the number of cells.

The number of cells in a vector is called the **length** of the vector.

All items in a vector must be of the same type. If you mix numbers and text, then the whole vector will be formatted to the simplest type. For example, if you include a string with any other fomat, then the whole vector will be treated as a string:


```r
Xvec<-c(1.1829378,X,1:10,"E", "Computational Biology", 100:90)
Xvec
```

```
##  [1] "1.1829378"             "string"                "1"                    
##  [4] "2"                     "3"                     "4"                    
##  [7] "5"                     "6"                     "7"                    
## [10] "8"                     "9"                     "10"                   
## [13] "E"                     "Computational Biology" "100"                  
## [16] "99"                    "98"                    "97"                   
## [19] "96"                    "95"                    "94"                   
## [22] "93"                    "92"                    "91"                   
## [25] "90"
```

> **Protip**: A common problem when importing data to R occurs when a column of numeric data includes at least one text value (e.g.  "missing" or "< 1"). R will treat the entire column as text rather than numeric values. Watch for this when working with real data!

#### Subset a vector

Use square brackets `[]` to subset a vector


```r
Xvec[1]
```

```
## [1] "1.1829378"
```

```r
Xvec[13]
```

```
## [1] "E"
```

```r
Xvec[1:3]
```

```
## [1] "1.1829378" "string"    "1"
```

### Matrices 

A matrix is a 2-D array of cells, equivalent to one sheet in a spreadsheet program. 


```r
Xmat<-matrix(Xvec,nrow=6)
```

```
## Warning in matrix(Xvec, nrow = 6): data length [25] is not a sub-multiple or
## multiple of the number of rows [6]
```

```r
Xmat
```

```
##      [,1]        [,2] [,3]                    [,4] [,5]       
## [1,] "1.1829378" "5"  "E"                     "96" "90"       
## [2,] "string"    "6"  "Computational Biology" "95" "1.1829378"
## [3,] "1"         "7"  "100"                   "94" "string"   
## [4,] "2"         "8"  "99"                    "93" "1"        
## [5,] "3"         "9"  "98"                    "92" "2"        
## [6,] "4"         "10" "97"                    "91" "3"
```

#### Subset

**Notice** the square brackets along the top and left side? 

These show the 'address' of each element in the matrix. We can subset with square brackets, just like we did with vectors. Since there are two dimensions, we need to specify two numbers:

`[row,column]`


```r
Xmat[1,3]
```

```
## [1] "E"
```

Or leave it blank if you want the whole row or column:


```r
Xmat[1,]
```

```
## [1] "1.1829378" "5"         "E"         "96"        "90"
```

```r
Xmat[,3]
```

```
## [1] "E"                     "Computational Biology" "100"                  
## [4] "99"                    "98"                    "97"
```


### Tensors

**Tensors** are the general term for a grid with N dimensions. We've already seen a few different tensors:

Name | Tensor Dimension
--------|----
Cell | 0
Vector | 1
Matrix | 2
Array | 3+

Another common term for tensor is **array**. In R you can build tensors by adding as many dimensions as you need using the `array()` function


```r
Xarray<-array(0, dim=c(3,3,2)) # 3 dimensions
Xarray
```

```
## , , 1
## 
##      [,1] [,2] [,3]
## [1,]    0    0    0
## [2,]    0    0    0
## [3,]    0    0    0
## 
## , , 2
## 
##      [,1] [,2] [,3]
## [1,]    0    0    0
## [2,]    0    0    0
## [3,]    0    0    0
```

Notice how 3rd dimension is sliced to print out in 2D

<br>

Higher-order arrays are possible, but a bit tricky to read on a 2-dimensional screen


```r
Xarray<-array(rnorm(64), dim=c(2,2,2,2,2,2)) # 6 dimensions
```

Once you get the hang of it, it's easy to subset. Just think of each dimension, separated by commas.


```r
Xarray[1:2,1:2,1,1,1,1]
```

```
##           [,1]       [,2]
## [1,] -1.718987  0.3487603
## [2,]  1.779268 -0.3523615
```

```r
Xarray[1:2,1,1,1:2,1,1]
```

```
##           [,1]      [,2]
## [1,] -1.718987 0.8664164
## [2,]  1.779268 1.2394975
```

> Why are these numbers not the same?

Look at the `array[]` function and compare to the 6-D tensor to understand how this works

## Matrix Algebra

R is pretty handy for matrix calculations that are very time consuming to do by hand or in a spreadsheet program


```r
## Create some vectors to play with
X<-c(1:10)
X
```

```
##  [1]  1  2  3  4  5  6  7  8  9 10
```

```r
Y<-c(1:10*0.5)
Y
```

```
##  [1] 0.5 1.0 1.5 2.0 2.5 3.0 3.5 4.0 4.5 5.0
```

```r
## Use pretty much any standard operator for element-by element calculations
X*Y # Multiply corresponding element (e.g. X[1]*Y[1], then X[2]*Y[2], etc)
```

```
##  [1]  0.5  2.0  4.5  8.0 12.5 18.0 24.5 32.0 40.5 50.0
```

```r
X+Y
```

```
##  [1]  1.5  3.0  4.5  6.0  7.5  9.0 10.5 12.0 13.5 15.0
```

```r
X/Y
```

```
##  [1] 2 2 2 2 2 2 2 2 2 2
```

```r
X^Y
```

```
##  [1] 1.000000e+00 2.000000e+00 5.196152e+00 1.600000e+01 5.590170e+01
##  [6] 2.160000e+02 9.074927e+02 4.096000e+03 1.968300e+04 1.000000e+05
```

```r
log(X)
```

```
##  [1] 0.0000000 0.6931472 1.0986123 1.3862944 1.6094379 1.7917595 1.9459101
##  [8] 2.0794415 2.1972246 2.3025851
```

```r
exp(Y)
```

```
##  [1]   1.648721   2.718282   4.481689   7.389056  12.182494  20.085537
##  [7]  33.115452  54.598150  90.017131 148.413159
```

```r
## More advanced matrix algebra
X%*%Y # Matrix multiplication (e.g.  X[1]*Y[1]+X[2]*Y[2]...)
```

```
##       [,1]
## [1,] 192.5
```

```r
sum(X*Y) == X%*%Y
```

```
##      [,1]
## [1,] TRUE
```

```r
Z<-X[1:4]%o%Y[1:3] # Outer product
Z
```

```
##      [,1] [,2] [,3]
## [1,]  0.5    1  1.5
## [2,]  1.0    2  3.0
## [3,]  1.5    3  4.5
## [4,]  2.0    4  6.0
```

```r
t(Z) # Transpose
```

```
##      [,1] [,2] [,3] [,4]
## [1,]  0.5    1  1.5    2
## [2,]  1.0    2  3.0    4
## [3,]  1.5    3  4.5    6
```

```r
crossprod(X[1:4],Z) # Cross product
```

```
##      [,1] [,2] [,3]
## [1,]   15   30   45
```

```r
crossprod(Z) # Cross product of Z and t(Z) a.k.a. Z'Z
```

```
##      [,1] [,2] [,3]
## [1,]  7.5   15 22.5
## [2,] 15.0   30 45.0
## [3,] 22.5   45 67.5
```

```r
diag(4) # Identity matrix, 4x4 in this case
```

```
##      [,1] [,2] [,3] [,4]
## [1,]    1    0    0    0
## [2,]    0    1    0    0
## [3,]    0    0    1    0
## [4,]    0    0    0    1
```

```r
diag(Z) # Diagonal elements of Z 
```

```
## [1] 0.5 2.0 4.5
```

### PCA

One example of a matrix calculation is principal components analysis. This is covered in more detail in the [PCA Tutorial](https://colauttilab.github.io/RIntroML/2_PCA.html).

PCA is widely used in biology, from community ecology and metagenomics to gene expression and morphometrics. It also has many applications outside of biology. For now, just know that it is easy to run a PCA using the `prcomp()` function:


```r
prcomp(Z, cor=T) 
```

```
## Warning: In prcomp.default(Z, cor = T) :
##  extra argument 'cor' will be disregarded
```

```
## Standard deviations (1, .., p=3):
## [1] 2.415229 0.000000 0.000000
## 
## Rotation (n x k) = (3 x 3):
##            PC1        PC2        PC3
## [1,] 0.2672612  0.0000000  0.9636241
## [2,] 0.5345225 -0.8320503 -0.1482499
## [3,] 0.8017837  0.5547002 -0.2223748
```

## Lists 

Tensors generally all have the same data type and sub-dimension. For example, if you want to combine two 2-d matrices into a single tensor (3rd dimension) then the individual matrices have to have the same number of rows and columns, and the same data type.

Lists are useful for mixxing data types, and can combine different dimensions cells, vectors, and higher-order arrays

Each element needs a name


```r
MyList<-list(name="SWC",potpourri=Xvec,numbers=1:10)
MyList
```

```
## $name
## [1] "SWC"
## 
## $potpourri
##  [1] "1.1829378"             "string"                "1"                    
##  [4] "2"                     "3"                     "4"                    
##  [7] "5"                     "6"                     "7"                    
## [10] "8"                     "9"                     "10"                   
## [13] "E"                     "Computational Biology" "100"                  
## [16] "99"                    "98"                    "97"                   
## [19] "96"                    "95"                    "94"                   
## [22] "93"                    "92"                    "91"                   
## [25] "90"                   
## 
## $numbers
##  [1]  1  2  3  4  5  6  7  8  9 10
```

### Subset

There are a few different ways to subset a list object


```r
MyList$numbers # Use $ to subset by name
```

```
##  [1]  1  2  3  4  5  6  7  8  9 10
```

```r
MyList[3] # A 'slice' of MyList
```

```
## $numbers
##  [1]  1  2  3  4  5  6  7  8  9 10
```

```r
MyList[[3]] # An 'extract' of MyList
```

```
##  [1]  1  2  3  4  5  6  7  8  9 10
```

> What's the difference between `[]` and `[[]]`?

Look carefully at the output above; notice how the `[]` includes `$numbers` but the `[[]]` includes only the values? This is important if you want to use the slice:


```r
2*MyList[[3]]
```

```
##  [1]  2  4  6  8 10 12 14 16 18 20
```

```r
2*MyList[3]
```

```
## Error in 2 * MyList[3]: non-numeric argument to binary operator
```

### Output

> **Protip**: Many analysis functions in R output as lists (e.g. statistical packages)

For example, the output of `prcomp`:


```r
prcomp(Z) 
```

```
## Standard deviations (1, .., p=3):
## [1] 2.415229 0.000000 0.000000
## 
## Rotation (n x k) = (3 x 3):
##            PC1        PC2        PC3
## [1,] 0.2672612  0.0000000  0.9636241
## [2,] 0.5345225 -0.8320503 -0.1482499
## [3,] 0.8017837  0.5547002 -0.2223748
```

```r
names(prcomp(Z))
```

```
## [1] "sdev"     "rotation" "center"   "scale"    "x"
```

```r
prcomp(Z)$center
```

```
## [1] 1.25 2.50 3.75
```

```r
prcomp(Z)$scale
```

```
## [1] FALSE
```

## `print()` and `paste()`

The `print` function is the go-to function for printing output to the user. The `paste` function is for combining things together. 

Paste is a versatile function for manipulating output:


```r
paste("Hello World!") # Basic string
```

```
## [1] "Hello World!"
```

```r
paste("Hello","World!") # Concatenate two strings
```

```
## [1] "Hello World!"
```

```r
paste(1:10) # Paste numbers as strings
```

```
##  [1] "1"  "2"  "3"  "4"  "5"  "6"  "7"  "8"  "9"  "10"
```

```r
paste(1:10)[4] # Note that each number is a separate cell in a vector of strings
```

```
## [1] "4"
```

```r
as.numeric(paste(1:10)) # Convert back to numbers
```

```
##  [1]  1  2  3  4  5  6  7  8  9 10
```

```r
paste(1:10,collapse=".") # Collapse separate cells to produce a single string
```

```
## [1] "1.2.3.4.5.6.7.8.9.10"
```

Note what happens if we combine objects of different length:


```r
paste("Hello",1:10,sep="-") # Note 
```

```
##  [1] "Hello-1"  "Hello-2"  "Hello-3"  "Hello-4"  "Hello-5"  "Hello-6" 
##  [7] "Hello-7"  "Hello-8"  "Hello-9"  "Hello-10"
```

It is not uncommon to nest a paste function within a print:


```r
print(paste("Hello",1:10,sep="-"))
```

```
##  [1] "Hello-1"  "Hello-2"  "Hello-3"  "Hello-4"  "Hello-5"  "Hello-6" 
##  [7] "Hello-7"  "Hello-8"  "Hello-9"  "Hello-10"
```

This would be useful inside of a `for` loop (see below) where the output of `paste` is not shown on the screen if used inside of a loop, whereas the output of `print` is.

### ? for HELP

Whenever you are learning a new function, you should use `?` and carefully read about all the parameters and outputs. The explanations can be a bit technical, which is intimidating at first. But after enough practice you will start to understand more and more of the descriptions.


```r
?paste
```

<br>

*** 

<br>


## Data

So far we've done everything within the R environment. If we quit R then everything we have made will be removed from memory and we'll have to start all over. Therefore, it can be useful to save and load data from external files.

### Working Directory

The **working directory** is the place where R looks to load or save your files. You can figure out what your current working directory is with the `getwd()` function


```r
getwd()
```

Or you can set a specific working directory. Here's one example:


```r
setwd("C:/Users/ColauttiLab/Documents")
```

Did you type out the above line? You should! Remember, going through and typing everything out is one of the most effective ways to learn to code. So do it now

Okay, so you probably have an error unless you are working in Windows and for some reason have a ColauttiLab username on your computer. Now try changing to a different directory on your computer.

If you are a mac user, you can just ignore the `C:` part:


```r
setwd("/Users/ColauttiLab/Documents")
```

#### Relative Path

The above examples of `setwd()` us an **absolute** path. You can also use a **relative** path. For example, if we have a folder called `Data` inside our `Documents` folder, and our current working directory is one of the two examples above, we can use a relative path name to set the `Data` folder as the working directory. Before you type this out, you should make a folder called `Data` inside of your current working directory:


```r
setwd("./Data")
```

The `.` means "Inside of my current directory" and the `/Data` means "find the Data folder"

now try this:


```r
getwd()
setwd("..")
getwd()
```

Compare the working directories. The `..` means "Go to the parent directory"

The neat thing about relative directories is that it makes it easy to share code between Windows, MacOS and Linux/Unix. In fact, these commands come from Linux. You can check out the [Linux Crash Course](https://colauttilab.github.io/LinuxCrashCourse/Linux-Fundamentals.html) for more detail.

### Import

Download [This Data File](https://colauttilab.github.io/RCrashCourse/FallopiaData.csv) and save in a folder called `Data` inside of your current working directory.

We can use the `read.csv` to read a 'comma-delimited file' and import it into an object called `MyData`


```r
MyData<-read.csv("Data/FallopiaData.csv",header=T) # Header=T tells read.csv to interpret first row as column labels
```



A `.csv` file is just a text file with special formatting that can be read into a program like Microsoft Excel or R to translate the text file into a data matrix.

**Important**: In R, objects created by `read.csv` and other `read.?` functions are special objects called `data.frame` objects.

### `data.frame`

A `data.frame` is a special type of 2D matrix with additional indexing information for rows/columns of data

This format is partly why R is so useful for data analysis

<br>

There are a number of useful functions for inspecting a `data.frame` object


```r
names(MyData) # See column names
```

```
##  [1] "PotNum"       "Scenario"     "Nutrients"    "Taxon"        "Symphytum"   
##  [6] "Silene"       "Urtica"       "Geranium"     "Geum"         "All_Natives" 
## [11] "Fallopia"     "Total"        "Pct_Fallopia"
```

```r
head(MyData) #  Show first six rows of data
```

```
##   PotNum Scenario Nutrients Taxon Symphytum Silene Urtica Geranium Geum
## 1      1      low       low japon      9.81  36.36  16.08     4.68 0.12
## 2      2      low       low japon      8.64  29.65   5.59     5.75 0.55
## 3      3      low       low japon      2.65  36.03  17.09     5.13 0.09
## 4      5      low       low japon      1.44  21.43  12.39     5.37 0.31
## 5      6      low       low japon      9.15  23.90   5.19     0.00 0.17
## 6      7      low       low japon      6.31  24.40   7.00     9.05 0.97
##   All_Natives Fallopia Total Pct_Fallopia
## 1       67.05     0.01 67.06         0.01
## 2       50.18     0.04 50.22         0.08
## 3       60.99     0.09 61.08         0.15
## 4       40.94     0.77 41.71         1.85
## 5       38.41     3.40 41.81         8.13
## 6       47.73     0.54 48.27         1.12
```

```r
tail(MyData) #  Show last six rows of data
```

```
##     PotNum     Scenario Nutrients Taxon Symphytum Silene Urtica Geranium Geum
## 118    143 fluctuations      high bohem      5.06  12.81  23.82     3.64 0.16
## 119    144 fluctuations      high bohem     19.93  21.07   6.08     2.80 0.43
## 120    145 fluctuations      high bohem      4.89  32.93   6.30     9.64 0.00
## 121    147 fluctuations      high bohem      7.84  31.16  13.61     6.58 0.03
## 122    148 fluctuations      high bohem      4.15  38.70  23.59     5.11 1.36
## 123    149 fluctuations      high bohem      1.72  10.41  23.48     8.51 0.43
##     All_Natives Fallopia Total Pct_Fallopia
## 118       45.49    21.31 66.80        31.90
## 119       50.31     0.00 50.31         0.00
## 120       53.76     2.36 56.12         4.21
## 121       59.22     3.74 62.96         5.94
## 122       72.91     5.89 78.80         7.47
## 123       44.55    19.70 64.25        30.66
```

```r
dim(MyData) # Number of rows x columns (or 'dimension') of the data object
```

```
## [1] 123  13
```

```r
nrow(MyData) # Number of rows only
```

```
## [1] 123
```

```r
ncol(MyData) # Number of columns only
```

```
## [1] 13
```

```r
str(MyData) #  Data 'structure' - types of variables
```

```
## 'data.frame':	123 obs. of  13 variables:
##  $ PotNum      : int  1 2 3 5 6 7 8 9 10 11 ...
##  $ Scenario    : chr  "low" "low" "low" "low" ...
##  $ Nutrients   : chr  "low" "low" "low" "low" ...
##  $ Taxon       : chr  "japon" "japon" "japon" "japon" ...
##  $ Symphytum   : num  9.81 8.64 2.65 1.44 9.15 ...
##  $ Silene      : num  36.4 29.6 36 21.4 23.9 ...
##  $ Urtica      : num  16.08 5.59 17.09 12.39 5.19 ...
##  $ Geranium    : num  4.68 5.75 5.13 5.37 0 9.05 3.51 9.64 7.3 6.36 ...
##  $ Geum        : num  0.12 0.55 0.09 0.31 0.17 0.97 0.4 0.01 0.47 0.33 ...
##  $ All_Natives : num  67 50.2 61 40.9 38.4 ...
##  $ Fallopia    : num  0.01 0.04 0.09 0.77 3.4 0.54 2.05 0.26 0 0 ...
##  $ Total       : num  67.1 50.2 61.1 41.7 41.8 ...
##  $ Pct_Fallopia: num  0.01 0.08 0.15 1.85 8.13 1.12 3.7 0.61 0 0 ...
```

> Protip: `str()` is very important for functions that use data.frames including statistical analysis and plotting

Pay careful attention to 'int' vs 'num' vs 'factor'. These are the data types, as noted above. 

Here's an example of data types gone rogue: In an analysis of variance (ANOVA), you want a 'factor' as a predictor. But in linear regression you want 'int' or 'num' as a predictor. If you code your factor (e.g. treatment) as a number (e.g. 1-4) then your `data.frame` will treat it as an integer. When you run a linear model, you will be running a regression rather than ANOVA.

### Subset

The `data.frame` object can be subset, just like a matrix


```r
MyData[1,] # Returns first row of data.frame
```

```
##   PotNum Scenario Nutrients Taxon Symphytum Silene Urtica Geranium Geum
## 1      1      low       low japon      9.81  36.36  16.08     4.68 0.12
##   All_Natives Fallopia Total Pct_Fallopia
## 1       67.05     0.01 67.06         0.01
```

```r
MyData[1,1] # Returns first value of data.frame
```

```
## [1] 1
```

In addition, you can define the column names


```r
MyData[,"PotNum"] # Returns values in "PotNum" column
```

```
##   [1]   1   2   3   5   6   7   8   9  10  11  12  14  16  17  18  19  20  22
##  [19]  23  24  25  26  28  29  30  31  33  34  35  36  38  39  40  41  42  44
##  [37]  45  47  48  49  50  52  53  54  55  57  58  60  61  62  63  65  66  67
##  [55]  68  69  70  72  73  74  76  77  78  79  80  81  83  84  85  86  87  88
##  [73]  90  91  92  93  94  95  96  97  98 100 101 102 103 104 105 107 108 110
##  [91] 111 112 113 114 116 117 118 119 120 121 122 124 125 126 127 128 129 131
## [109] 132 133 134 135 136 138 139 140 142 143 144 145 147 148 149
```

```r
MyData$PotNum # Another way to get the same output
```

```
##   [1]   1   2   3   5   6   7   8   9  10  11  12  14  16  17  18  19  20  22
##  [19]  23  24  25  26  28  29  30  31  33  34  35  36  38  39  40  41  42  44
##  [37]  45  47  48  49  50  52  53  54  55  57  58  60  61  62  63  65  66  67
##  [55]  68  69  70  72  73  74  76  77  78  79  80  81  83  84  85  86  87  88
##  [73]  90  91  92  93  94  95  96  97  98 100 101 102 103 104 105 107 108 110
##  [91] 111 112 113 114 116 117 118 119 120 121 122 124 125 126 127 128 129 131
## [109] 132 133 134 135 136 138 139 140 142 143 144 145 147 148 149
```

```r
subset(MyData,Scenario=="extreme") # Subset data where the Scenario column == 'extreme'
```

```
##    PotNum Scenario Nutrients Taxon Symphytum Silene Urtica Geranium Geum
## 74     91  extreme      high japon      6.77  29.29  17.58     1.20 0.98
## 75     92  extreme      high japon      9.19  16.76   7.32     4.84 0.21
## 76     93  extreme      high japon      6.55  48.19   0.00     9.21 0.05
## 77     94  extreme      high japon      5.22  18.21  21.51     6.53 0.58
## 78     95  extreme      high japon      4.92  25.93  40.33     4.92 0.07
## 79     96  extreme      high japon      9.51   3.15  36.16    10.16 0.62
## 80     97  extreme      high japon     14.98  33.34   2.56     7.38 0.16
## 81     98  extreme      high japon     17.37   4.38   2.73    16.41 0.00
## 82    100  extreme      high japon      7.36  24.90   3.21     7.30 0.46
## 83    101  extreme      high japon     10.54  31.97   7.37     4.62 0.54
## 84    102  extreme      high japon      9.51   0.00  17.56     6.97 0.00
## 85    103  extreme      high japon      6.92  49.38   0.00    10.33 0.42
## 86    104  extreme      high japon     12.42  18.36   4.44     6.42 0.42
## 87    105  extreme      high japon      5.89  37.92   4.71     5.18 0.09
## 88    107  extreme      high bohem      0.00  43.85   8.10     8.18 0.36
## 89    108  extreme      high bohem     10.29  27.47   5.47     0.00 0.40
## 90    110  extreme      high bohem     17.39  24.42  10.71     8.34 0.00
## 91    111  extreme      high bohem     12.59   0.00  41.08     4.81 1.38
## 92    112  extreme      high bohem     15.27   1.66  25.77     8.79 0.50
## 93    113  extreme      high bohem     12.52  21.52   0.00     5.71 1.11
## 94    114  extreme      high bohem     11.33  31.61   6.95    10.14 0.86
## 95    116  extreme      high bohem     14.89   0.00  10.16    10.28 0.18
## 96    117  extreme      high bohem     14.12  24.57  12.59     8.46 0.63
## 97    118  extreme      high bohem     14.21  25.15  12.69     8.06 0.29
## 98    119  extreme      high bohem      0.00  36.79   8.69     3.38 1.20
## 99    120  extreme      high bohem      9.85  15.71  15.56     3.89 1.46
##    All_Natives Fallopia Total Pct_Fallopia
## 74       55.82     1.98 57.80         3.43
## 75       38.32     3.40 41.72         8.15
## 76       64.00     3.44 67.44         5.10
## 77       52.05     6.73 58.78        11.45
## 78       76.17     1.57 77.74         2.02
## 79       59.60     6.08 65.68         9.26
## 80       58.42     0.00 58.42         0.00
## 81       40.89    14.46 55.35        26.12
## 82       43.23     7.05 50.28        14.02
## 83       55.04     0.00 55.04         0.00
## 84       34.04     5.52 39.56        13.95
## 85       67.05     4.02 71.07         5.66
## 86       42.06     3.17 45.23         7.01
## 87       53.79     3.41 57.20         5.96
## 88       60.49     7.21 67.70        10.65
## 89       43.63     8.83 52.46        16.83
## 90       60.86     0.00 60.86         0.00
## 91       59.86     2.33 62.19         3.75
## 92       51.99    13.54 65.53        20.66
## 93       40.86     7.33 48.19        15.21
## 94       60.89     0.00 60.89         0.00
## 95       35.51    12.62 48.13        26.22
## 96       60.37     0.00 60.37         0.00
## 97       60.40     7.46 67.86        10.99
## 98       50.06     6.34 56.40        11.24
## 99       46.47     2.66 49.13         5.41
```

```r
levels(MyData$Scenario)
```

```
## NULL
```

### New Columns

It's easy to add new columns to a data frame. For example, to add a new column that is the sum of two others


```r
MyData$Total<-MyData$Symphytum + MyData$Silene + MyData$Urtica
names(MyData)
```

```
##  [1] "PotNum"       "Scenario"     "Nutrients"    "Taxon"        "Symphytum"   
##  [6] "Silene"       "Urtica"       "Geranium"     "Geum"         "All_Natives" 
## [11] "Fallopia"     "Total"        "Pct_Fallopia"
```

```r
print(MyData$Total)      
```

```
##   [1] 62.25 43.88 55.77 35.26 38.24 37.71 49.46 32.77 45.76 39.20 49.84 36.28
##  [13] 40.52 35.78 39.26 45.33 38.54 33.27 50.09 48.55 49.25 31.36 36.56 37.21
##  [25] 57.06 48.48 39.32 28.03 47.19 57.63 53.27 37.79 43.56 45.47 56.68 43.88
##  [37] 47.03 47.41 50.64 34.74 54.40 48.46 64.48 49.31 48.97 54.00 55.71 64.35
##  [49] 38.73 41.31 52.31 56.77 50.10 47.22 38.61 59.73 75.59 36.33 53.57 54.94
##  [61] 39.21 45.22 25.39 57.10 38.00 37.51 56.86 43.48 51.86 67.97 16.43 58.13
##  [73] 52.64 53.64 33.27 54.74 44.94 71.18 48.82 50.88 24.48 35.47 49.88 27.07
##  [85] 56.30 35.22 48.52 51.95 43.23 52.52 53.67 42.70 34.04 49.89 25.05 51.28
##  [97] 52.05 45.48 41.12 45.67 38.18 53.30 40.52 36.70 58.78 37.31 14.48 43.19
## [109] 65.25 30.79 54.97 62.96 38.64 37.08 41.39 38.85 39.34 41.69 47.08 44.12
## [121] 52.61 66.44 35.61
```

<br>

*** 

<br>


## Other Functions

There are a few more useful functions for inspecting your data.

### `unique`

Find all the unique values within a vector using `unique`


```r
unique(MyData$Nutrients)
```

```
## [1] "low"  "high"
```

### `duplicated`

Look at each value in a vector and return a `TRUE` if it is duplicated and `FALSE` if it is unique


```r
duplicated(MyData$Nutrients)
```

```
##   [1] FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE
##  [13]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE
##  [25]  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE
##  [37]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE
##  [49]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE
##  [61]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE
##  [73]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE
##  [85]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE
##  [97]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE
## [109]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE
## [121]  TRUE  TRUE  TRUE
```

This is a good example of a Boolean vector, which can be used to subset your data.


```r
MyData$Nutrients[duplicated(MyData$Nutrients)]
```

```
##   [1] "low"  "low"  "low"  "low"  "low"  "low"  "low"  "low"  "low"  "low" 
##  [11] "low"  "low"  "low"  "low"  "low"  "low"  "low"  "low"  "low"  "low" 
##  [21] "low"  "low"  "low"  "low"  "high" "high" "high" "high" "high" "high"
##  [31] "high" "high" "high" "high" "high" "high" "high" "high" "high" "high"
##  [41] "high" "high" "high" "high" "high" "high" "high" "high" "high" "high"
##  [51] "high" "high" "high" "high" "high" "high" "high" "high" "high" "high"
##  [61] "high" "high" "high" "high" "high" "high" "high" "high" "high" "high"
##  [71] "high" "high" "high" "high" "high" "high" "high" "high" "high" "high"
##  [81] "high" "high" "high" "high" "high" "high" "high" "high" "high" "high"
##  [91] "high" "high" "high" "high" "high" "high" "high" "high" "high" "high"
## [101] "high" "high" "high" "high" "high" "high" "high" "high" "high" "high"
## [111] "high" "high" "high" "high" "high" "high" "high" "high" "high" "high"
## [121] "high"
```

Note that only the `TRUE` values are returned (duplicated)

### `aggregate`

Quickly calculate means of one vector (Total) for each value of a grouping variable (Nutrients)


```r
aggregate(MyData$Total,list(MyData$Nutrients), mean) 
```

```
##   Group.1        x
## 1    high 46.51173
## 2     low 42.76800
```

The `~` provides an alternative way to write this function. In R the `~` usually means 'by' and is often used in statistical models. Here we can say aggregate Total 'by' Nutrients grouping


```r
aggregate(Total ~ Nutrients, data=MyData, mean)
```

```
##   Nutrients    Total
## 1      high 46.51173
## 2       low 42.76800
```

The nice thing about doing it this way is that we preserve the column name (Total instead of x).

You can also use this to calculate means across different grouping variables


```r
aggregate(Total ~ Nutrients*Taxon*Scenario, data=MyData, mean)
```

```
##    Nutrients Taxon     Scenario    Total
## 1       high bohem      extreme 45.24833
## 2       high japon      extreme 45.31500
## 3       high bohem fluctuations 43.89545
## 4       high japon fluctuations 44.77692
## 5       high bohem      gradual 45.36923
## 6       high japon      gradual 50.43417
## 7       high bohem         high 52.04273
## 8       high japon         high 45.69417
## 9        low bohem          low 41.75231
## 10       low japon          low 43.86833
```

Note that `mean` is just the `mean()` function in R. We can use other functions, like the standard deviation `sd`:



```r
aggregate(Total ~ Nutrients, data=MyData, sd) 
```

```
##   Nutrients     Total
## 1      high 11.175885
## 2       low  8.227402
```

### tapply

The `tapply` function is a more general way to replicate functions. 


```r
tapply(MyData$Total, list(MyData$Nutrients), mean) # calculate means
```

```
##     high      low 
## 46.51173 42.76800
```

Compare the two outputs with `aggregate` above

### Save

Just as we can load FROM external files, we can save TO external files


```r
## Calulate means
NutrientMeans<-tapply(MyData$Total,list(MyData$Nutrients),mean)
## Save means as .csv file
write.csv(NutrientMeans,"MyData_Nutrient_Means.csv")
```

You should see this file in your working directory.

<br>

*** 

<br>

## Flow control

Think of your data analysis as a stream flowing from the raw data at the headwaters and flowing down to the end, exiting as a full analysis with graphics, stats, and interpretation.

There are different ways we can control the flow of the water. The simplest is just to write a sequence of lines of code, with the output of one line of code forming the input of the next. There are several examples of this above:

```
A<-functionA()
B<-functionB(A)
C<-functionC(B)
```

But sometimes we may want to do the same function or analysis only if the input meets certain criteria. Or we may want to reiterate the same analysis multiple times on different inputs. This is where more advanced flow control comes in handy.

To start, let's make up a couple of objects to play with:


```r
X<-21
Xvec<-c(1:10,"string")
```

### `if`

The `if` statement uses an **operator** (see above) to asses whether the value is `TRUE` or `FALSE`:


```r
if(X > 100){ # Greater-than operator assessing whether X is greater than 100
  print("X > 100") # What to do if TRUE (X greater than 100)
} else { 
  print("X <= 100") # What do do if FALSE (X less than 100)
}
```

```
## [1] "X <= 100"
```

> **NOTE**: A common 'rookie' mistake is to leave out a bracket or use the wrong type. 

Use regular brackets for the if function `if()` followed by two sets of curly brackets `{}else{}`.

Break up across multiple lines to improve readability. Note that you don't need an `else{}` part if you just want to 'do nothing' when `FALSE`.


```r
if(1 > 0){print ("yup")}
```

```
## [1] "yup"
```

### ifelse

The `ifelse` is a more compact version for simple comparisons. The following code does the same as above


```r
ifelse(X > 100, print("X > 100"), print("X <= 100"))
```

```
## [1] "X <= 100"
```

```
## [1] "X <= 100"
```


### `for` loop

A loop does the same thing over and over again until some condition is met. In the case of a `for` loop, we set a 'counter' variable and loop through each value of the counter variable. Here are a few examples:


```r
# Loop through numbers from 1 to X
for (i in 1:X){
  print(paste(X,i,sep=":"))
}
```

```
## [1] "21:1"
## [1] "21:2"
## [1] "21:3"
## [1] "21:4"
## [1] "21:5"
## [1] "21:6"
## [1] "21:7"
## [1] "21:8"
## [1] "21:9"
## [1] "21:10"
## [1] "21:11"
## [1] "21:12"
## [1] "21:13"
## [1] "21:14"
## [1] "21:15"
## [1] "21:16"
## [1] "21:17"
## [1] "21:18"
## [1] "21:19"
## [1] "21:20"
## [1] "21:21"
```

```r
# Loop through elements of a vector directly
for (i in Xvec){
  print(i)
}
```

```
## [1] "1"
## [1] "2"
## [1] "3"
## [1] "4"
## [1] "5"
## [1] "6"
## [1] "7"
## [1] "8"
## [1] "9"
## [1] "10"
## [1] "string"
```

```r
# Use an index to loop through the elements
for (i in 1:length(Xvec)){
  print(Xvec[i])
}
```

```
## [1] "1"
## [1] "2"
## [1] "3"
## [1] "4"
## [1] "5"
## [1] "6"
## [1] "7"
## [1] "8"
## [1] "9"
## [1] "10"
## [1] "string"
```

Note that in each case there is a vector and we loop through each cell in the vector. The `i` keeps track of the cell value in each iteration of the loop.

Loops can be tricky, and the only way to really learn them is to try to write a bunch. Whenever you find yourself writing similar code more than 2 or 3 times, challenge yourself to try to do it as a loop.

In addition to looping through a vector, it can often be useful to include a counter variable. 

One thing to watch out for is what part of the loop you want to update the counter variable. USUALLY it will be at the beginning


```r
count1<-1
count10<-1

for(i in 1:10){
  print(paste("count1 =",count1))
  print(paste("count10 =",count10))
  count1<-count1+1
  count10<-count10*10
}
```

```
## [1] "count1 = 1"
## [1] "count10 = 1"
## [1] "count1 = 2"
## [1] "count10 = 10"
## [1] "count1 = 3"
## [1] "count10 = 100"
## [1] "count1 = 4"
## [1] "count10 = 1000"
## [1] "count1 = 5"
## [1] "count10 = 10000"
## [1] "count1 = 6"
## [1] "count10 = 1e+05"
## [1] "count1 = 7"
## [1] "count10 = 1e+06"
## [1] "count1 = 8"
## [1] "count10 = 1e+07"
## [1] "count1 = 9"
## [1] "count10 = 1e+08"
## [1] "count1 = 10"
## [1] "count10 = 1e+09"
```

or at the end. 


```r
countbefore<-0
countafter<-0
for(i in 1:10){
  countbefore<-countbefore+1
  print(paste("before =",countbefore))
  print(paste("after =",countafter))
  countafter<-countafter+1
}
```

```
## [1] "before = 1"
## [1] "after = 0"
## [1] "before = 2"
## [1] "after = 1"
## [1] "before = 3"
## [1] "after = 2"
## [1] "before = 4"
## [1] "after = 3"
## [1] "before = 5"
## [1] "after = 4"
## [1] "before = 6"
## [1] "after = 5"
## [1] "before = 7"
## [1] "after = 6"
## [1] "before = 8"
## [1] "after = 7"
## [1] "before = 9"
## [1] "after = 8"
## [1] "before = 10"
## [1] "after = 9"
```

Read through the outputs above carefully to make sure you understand how the loops work. When you are confident you understand, then write a new for loop and write down the predicted output. Run the loop to check if you were right.

### Nested Loops

Counters are particularly valuable when you have a nested loop, which is just one loop inside of another.

In the example below, we are first looping through a vector of length 3, tracked with `i`. Then **for each i** we do a second loop, tracked by `j`.

This time, try to predict the output BEFORE you run the loop. Write it down, then run the loop to check your answer.


```r
LoopCount<-0
for(i in 1:3){
  for(j in 1:4){
    LoopCount<-LoopCount+1
    print(paste("i = ",i))
    print(paste("j = ",j))
    print(paste("Loop =",LoopCount))
  }
}
```

```
## [1] "i =  1"
## [1] "j =  1"
## [1] "Loop = 1"
## [1] "i =  1"
## [1] "j =  2"
## [1] "Loop = 2"
## [1] "i =  1"
## [1] "j =  3"
## [1] "Loop = 3"
## [1] "i =  1"
## [1] "j =  4"
## [1] "Loop = 4"
## [1] "i =  2"
## [1] "j =  1"
## [1] "Loop = 5"
## [1] "i =  2"
## [1] "j =  2"
## [1] "Loop = 6"
## [1] "i =  2"
## [1] "j =  3"
## [1] "Loop = 7"
## [1] "i =  2"
## [1] "j =  4"
## [1] "Loop = 8"
## [1] "i =  3"
## [1] "j =  1"
## [1] "Loop = 9"
## [1] "i =  3"
## [1] "j =  2"
## [1] "Loop = 10"
## [1] "i =  3"
## [1] "j =  3"
## [1] "Loop = 11"
## [1] "i =  3"
## [1] "j =  4"
## [1] "Loop = 12"
```


### `while` loop

The `while` is another kind of loop, but instead of looping through a predefined set of variables, we iterate until some condition is met inside of the loop. This is called the **exit condition**.

Often, the `while` loop is used in optimization algorithms, where many calculations are run until some optimum or threshold value is reached.

One common coding error associated with `while` loops is that the exit condition is never reached, causing your computer to run an infinite loop.

Here's a simple while loop, which will continue until `count` is greater than or equal to `X`.


```r
count<-0
while (count < X){
  print(count)
  count<-count+1
}
```

```
## [1] 0
## [1] 1
## [1] 2
## [1] 3
## [1] 4
## [1] 5
## [1] 6
## [1] 7
## [1] 8
## [1] 9
## [1] 10
## [1] 11
## [1] 12
## [1] 13
## [1] 14
## [1] 15
## [1] 16
## [1] 17
## [1] 18
## [1] 19
## [1] 20
```

## Packages

As noted above, **functions** in R use brackets `()` and generally have **input** and **output** objects as well as **parameters** that affect their behaviour.

All of the functions in this tutorial are automatically loaded when you start R. There are many more functions available from developers. For example, our lab developed the `baRcodeR` package for creating unique identifier codes with printable barcodes and data sheets to help with sample management and data collection. 

A **package** in R is a set of functions grouped together. For example, the `stats` package is automatically loaded when you run R and contains many useful functions. You can see what package a function belongs to at the beginning of the help file:


```r
?cor
```

### Installing

Before you can use a new function from a package that isn't installed with R, you first have to install the package on your computer. You only have to do this once per computer. However, it is a good idea to update the package frequently, especially when you update your version of R. This ensures that you are using the most recent version of the package.

Note that **installing** a package just downloads it from an online '**repository**' and saves to your computer.

Packages are installed with `install.packages()`, with the package indicated with single or double quotation marks. You may be asked for a repository, in which case choose one that is geographically close to you.


```r
install.packages('baRcoeR')
```

### Loading

Once you have installed a package, you can access it two ways. 

#### 1. Library

You can load the package using the `library()` function, giving you access to functions contained within it:


```r
library(baRcodeR)
make_labels()
```

#### 2. Function

You can run a function without loading the whole package:


```r
baRcodeR::make_labels()
```

This translates to "Run the `make_labels` function from the `baRcodeR` library.

The first method is more common, especially for the commonly used functions covered in these self-tutorials. However, the second method is convenient if you just want to use one function from a large library that take up a lot of space. 

More importantly, some packages have **functions with the same names**. Let's say you load two packages `pkgA` and `pkgB` that have different functions but both are called `cor`. When you run the `cor` function, R will assume you want the one from the package that was most recently loaded using the `library()` function. However, you can over-ride this with the second method:


```r
pkgA::cor()
pkgB::cor()
```


#### Library vs Package

The terms **library** and **package** are often used interchangeably. Technically, the **package** is the collection of functions whereas the **library** is the specific folder where the R packages are stored. A library may contain more than one package.

For the most part, you just need to know that a package and a library are a collection of functions.

## Readable code

It's important to make your code readable and interpretable by collaborators, peer reviewers, and yourself 6 months from now. There are lots of opinions on this but here are a few basic suggestions:

  1. Add documentation to explain what you are doing
  2. Add spacing between parameters to improve readability
  3. Add spacing on either side of `<-` when making objects
  3. Break long functions into multiple lines; add the line break after a `,` or `+`
  2. Follow these suggestions for object/column/file names
    a. Try to keep your names short and concise but meaningful 
    b. Use underscore `_` to improve readability and avoid `.`
    c. Always start with a letter
    d. Avoid symbols
  
  Bad | Good
  ------------|---------------
  `sum(X,na.rm=T)` | `sum(X, na.rm=T)`
  `data.frame(X, Y, ..., data=...)` | `data.frame(X, Y,` <br> ` ..., data=...)`
  `X` | `Mass`
  `Days.To.First.Flower` | `Flwr_Days` or `FDays`
  `10d.Height` | `Ht10d`
  `Length*Width` | `LxW`

To take your code to the next level, look into the [Tidyverse Style Guide](https://style.tidyverse.org/index.html)

## TEST yourself:

Are you ready to test your knowledge?

If so, click [HERE](https://colauttilab.github.io/RCrashCourse/1_fundamentals_test.html)



