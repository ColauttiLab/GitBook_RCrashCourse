[["index.html", "R Crash Course Preface", " R Crash Course Robert I. Colautti 2021-12-02 Preface This book is targeted at the senior undergraduate or junior graduate student with limited training in math, statistics, and computer science. We focus on biological examples in ecology, evolution, genetics, and pathology. I focus on these topics for two reasons. The first is to show how to apply programming tools and techniques to curate, analyze, and visualize biological data. The second is that these are the areas in which I have researched and published papers, and the examples often use the same data. This is not just a matter of convenience but as a demonstration that the tools presented are the very same tools used for rigorous, peer-reviewed research. This book contains everything I wish I knew when I started programming in R, as a PhD student. In truth, many of the functions and packages provided herein were not available when I was a graduate student in Botany. I continue to add new tricks and techniques that I find useful. That said, you cant learn to code just by reading this text and the examples. You need to take control of your education. Consider that R is a programming language Question: How did you become fluent in a second language? Study, read, listen Try something new, fail, correct errors, repeat How do you become fluent in a programming language? Study, read, TYPE! Try something new, fail, correct errors, repeat TYPE! Dont just sit there, follow along and type out the same commands into your R console Here are a few more tips for successful 1. Get organized and PLAN. You wont stick to the plan but at least youll have a blueprint 2. Set aside large blocks of time (2+ hours), ideally without interruption 3. Get some good headphones with white noise or instrumental sounds (no lyrics), depending on mood: a. Baroque/Classical b. Smooth Jazz c. Electronic (ambient, house, lofi) e. https://coffitivity.com/ If you get stuck, Google: How do I ______ in R If you cant figure out what an error means, paste it into Google. Read other peoples code carefully to see how they tackle problems. Only rarely is there one single right way to code something. When you are starting out, the right way to code is whatever it takes to get the code to do what you want. EMBRACE FAILURE!  even after ~2 decades of programming experience, most of my algorithms do not work on the first try, and most of my time is spent dealing with errors (typos, mis-specified objects, etc.)! Learn By Doing! As you work through these self-tutorials, dont just read them. type them out in your R (Studio) console and see what the output looks like. The simple act of typing it out will help you learn to code! If you get an error, even better! Read the error carefully, then compare what you typed to what is in the tutorial. Once you find what is different, you will learn what that error means. About 70-90% of coding is dealing with errors, and the same is true for learning to code. "],["setup.html", "Chapter 1 Setup", " Chapter 1 Setup Before you begin, you should install the latest version of R: https://cran.r-project.org/ And then install the latest version of RStudio: https://rstudio.com/products/rstudio/download/#download Finally, make sure you are connected to the internet, then open RStudio and locate the console tab. Then install some additional packages WARNING! This may take a long time to run Make sure you are able to leave your computer to update for up to an hour before doing this. To install the packages, type this into your console: install.packages(&quot;tidyverse&quot;) "],["fundamentals.html", "Chapter 2 Fundamentals 2.1 Introduction 2.2 R Basics 2.3 Data Types 2.4 Objects 2.5 Matrix Algebra 2.6 Lists 2.7 print() and paste() 2.8 Data 2.9 Other Functions 2.10 Flow control 2.11 Packages 2.12 Readable code 2.13 TEST yourself:", " Chapter 2 Fundamentals 2.1 Introduction This chapter provides a rapid breakdown of the core functionality of R. There is a lot to cover in a very short time. Remember that you can only learn coding through repetition. Before you begin, you should have R and R Studio installed. It is important that you physically participate and code along with the examples. Type everything out. The physical act of typing into R and troubleshooting any errors you get is a crucial part of the learning process. 2.2 R Basics Make comments inside your code. Very important (unless you are using R markdown or R notebooks)! # Use hastags to make comments - not read by the R console # Use other characters and blank lines to improve readability: # ------------------------- # My first R script # Today&#39;s Date # ------------------------- # Add a summary description of what the script does # This script will... # And annotate individual parts of the script 2.2.1 Basic Math You can do basic mathematical equations in R. Yes, type these out! 10+2 # add ## [1] 12 10-2 # subtract ## [1] 8 10*2 # multiply ## [1] 20 10/2 # divide ## [1] 5 10^2 # exponent ## [1] 100 2.2.2 Functions R uses functions. Each function has a name and is followed by brackets function(). Inside the brackets we can define input values and parameters. 2.2.3 `c() The concatenate function c() is a very important function in R that is used to group items together: c(1,2,3,5) ## [1] 1 2 3 5 2.2.4 Math Functions Here are some basic mathematical functions abs(-10) # absolute value ## [1] 10 sqrt(10-1) # square root (with subtraction) ## [1] 3 log(10) # natural log ## [1] 2.302585 log10(10) # log base 10 ## [1] 1 exp(1) # power of e ## [1] 2.718282 sin(pi/2) # sine function ## [1] 1 asin(1) # inverse sine ## [1] 1.570796 cos(pi) # cosine ## [1] -1 acos(-1) # inverse cosine ## [1] 3.141593 tan(0) # tangent ## [1] 0 atan(0) # inverse tangent ## [1] 0 2.2.5 Round/Truncate Rounding and truncating numbers round(pi,digits=3) # standard rounding to 3 digits ## [1] 3.142 floor(pi) # round down to closest whole number ## [1] 3 ceiling(pi) # round up to closest whole number ## [1] 4 signif(pi,digits=2) # round to keep 2 significant digits ## [1] 3.1 2.2.6 Logic Operators An operator is used to compare values. 1 &gt; 2 # greater than ## [1] FALSE 1 &lt; 2 # less than ## [1] TRUE 1 &lt;= 2 # less than or equal to ## [1] TRUE 1 == 1 # equal to ## [1] TRUE 1 == 2 | 1 == 1 # | means &#39;OR&#39; ## [1] TRUE 1 == 2 &amp; 1 == 1 # &amp; means &#39;AND&#39; ## [1] FALSE 1 == 1 &amp; 1 == 1 ## [1] TRUE Note: ! is a negation/inverse operator 1 != 1 # not equal to ## [1] FALSE 2.2.7 Group Comparison Instead of |, you can us %in% with c() to check a large number of values. 1 %in% c(1,2,3,4,5,6,7,8,9,10) ## [1] TRUE 2.2.8 Random Numbers It is very easy to generate some random numbers from different distributions. This is very useful for modelling and testing your code. runif(10,min=0,max=1) # random numbers from a uniform distribution (each number equally likely to be chosen) ## [1] 0.1388931 0.2776045 0.7852248 0.9423432 0.4907170 0.3168890 0.6232029 ## [8] 0.5839645 0.2872892 0.2574184 rnorm(10,mean=0,sd=1) # random numbers from a normal distribution ## [1] -1.2379441 1.5559149 2.1739250 -0.8888026 0.1812213 0.5298556 ## [7] 0.3341936 0.6536453 -0.5992498 0.5675925 rpois(10,lambda=10) # poisson distribution ## [1] 13 8 12 12 8 10 9 12 10 10 rbinom(10,size=1,prob=0.5) # binomial sampling (e.g. 10 coin tosses where heads=1 tails=0) ## [1] 1 0 1 0 1 1 1 0 0 1 rbinom(10,size=10,prob=0.5) # binomial repeated sampling (e.g. number of heads in 10 coin tosses, repeated 10 times) ## [1] 2 7 2 3 8 4 5 7 6 4 Fun fact, random numbers generated by a computer are generated by a calculation from a seed number, so they are never truly random. They act random because the seed number might be something like the remainder of a calculation involving the current year/day/hour/minute/millisecond of your computers internal clock. Its not just philosophical, it is also useful for testing and debugging since you can set the seed to generate the same random numbers. We can recreate the exact random number using the set.seed() function. Compare these outputs: runif(5) ## [1] 0.7604204 0.5491574 0.5501070 0.8136757 0.7006903 runif(5) ## [1] 0.2736914 0.9224710 0.2831013 0.8192767 0.5443611 set.seed(3) runif(5) ## [1] 0.1680415 0.8075164 0.3849424 0.3277343 0.6021007 set.seed(3) runif(5) ## [1] 0.1680415 0.8075164 0.3849424 0.3277343 0.6021007 set.seed(172834782) runif(5) ## [1] 0.13729290 0.18587365 0.01860484 0.88440060 0.21414154 set.seed(172834782) runif(5) ## [1] 0.13729290 0.18587365 0.01860484 0.88440060 0.21414154 runif(5) ## [1] 0.19787402 0.84870074 0.27303904 0.12225215 0.08365613 2.2.9 Combining objects Use c() to concatenate single objects Nums&lt;-c(1,2,5) c(Nums,&quot;string&quot;) ## [1] &quot;1&quot; &quot;2&quot; &quot;5&quot; &quot;string&quot; Use : to include a range of numbers 1:10 ## [1] 1 2 3 4 5 6 7 8 9 10 100:90 ## [1] 100 99 98 97 96 95 94 93 92 91 90 -1:1 ## [1] -1 0 1 Use cbind() to bind columns and rbind to bind rows cbind(1:10,10:1) ## [,1] [,2] ## [1,] 1 10 ## [2,] 2 9 ## [3,] 3 8 ## [4,] 4 7 ## [5,] 5 6 ## [6,] 6 5 ## [7,] 7 4 ## [8,] 8 3 ## [9,] 9 2 ## [10,] 10 1 rbind(1:10,10:1) ## [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] ## [1,] 1 2 3 4 5 6 7 8 9 10 ## [2,] 10 9 8 7 6 5 4 3 2 1 2.3 Data Types Programming languages like R use different data types. Its very important to understand data types in order to properly encode and analyze data in R. Its very common to have errors in statistical analyses caused by the wrong kind of data. For example, if you have 3 experimental groups coded as 1, 2 and 3 then these should be coded and analyzed as factors not numeric variables. Type Example Description string \"String\" Strings are the most common and versatile and can be defined with single '' or double \"\" quotation marks. The downside of strings is that you cant do any kind of equations. numeric 12.421 Numeric variables are rational numbers integer 12 Integers are whole numbers and may be positive or negative (no decimal) complex 0+12.43i Complex numbers include real and imaginary numbers boolean T or TRUE Boolean or logical variables are either true or false (Note always capital) factors Factors are a special type of data that may include strings and/or numbers but have a limited number of classes. Factors are often used to code groups in statistical models. Note that computers cannot store irrational numbers, they have to be rounded to some (tiny) decimal place. 2.4 Objects R supports Object-Oriented Programming (OOP), which is a programming style that defines and manipulates objects An object in R can be a lot of things, but an easy way is to think of a spreadsheet (example Microsoft Excel). A spreadsheet has columns organized into rows and columns, and may have multiple sheets. 2.4.1 Cells The most basic object is a single value. For example, a string X&lt;-&quot;string&quot; Why no output? When we wrote: X&lt;-\"string\" R created the object called X, so no output is produced. There are a few options To see the contents of X: print(X) ## [1] &quot;string&quot; paste(X) ## [1] &quot;string&quot; X ## [1] &quot;string&quot; print() Is most generic and versatile for providing feedback while running complex scripts (e.g. during loops, Bash scripts, etc) paste() Converts objects to a string, well come back to this. Generally print() or paste() are preferred over calling the object directly. 2.4.2 Vector A vector is a one-dimensional array of cells. This could be a row or column in our spreadsheet example. Each cell within the vector has an address  a number corresponding to the cell ranging from 1 to N, where N is the number of cells. The number of cells in a vector is called the length of the vector. All items in a vector must be of the same type. If you mix numbers and text, then the whole vector will be formatted to the simplest type. For example, if you include a string with any other fomat, then the whole vector will be treated as a string: Xvec&lt;-c(1.1829378,X,1:10,&quot;E&quot;, &quot;Computational Biology&quot;, 100:90) Xvec ## [1] &quot;1.1829378&quot; &quot;string&quot; &quot;1&quot; ## [4] &quot;2&quot; &quot;3&quot; &quot;4&quot; ## [7] &quot;5&quot; &quot;6&quot; &quot;7&quot; ## [10] &quot;8&quot; &quot;9&quot; &quot;10&quot; ## [13] &quot;E&quot; &quot;Computational Biology&quot; &quot;100&quot; ## [16] &quot;99&quot; &quot;98&quot; &quot;97&quot; ## [19] &quot;96&quot; &quot;95&quot; &quot;94&quot; ## [22] &quot;93&quot; &quot;92&quot; &quot;91&quot; ## [25] &quot;90&quot; Protip: A common problem when importing data to R occurs when a column of numeric data includes at least one text value (e.g. missing or &lt; 1). R will treat the entire column as text rather than numeric values. Watch for this when working with real data! 2.4.2.1 Subset a vector Use square brackets [] to subset a vector Xvec[1] ## [1] &quot;1.1829378&quot; Xvec[13] ## [1] &quot;E&quot; Xvec[1:3] ## [1] &quot;1.1829378&quot; &quot;string&quot; &quot;1&quot; 2.4.3 Matrices A matrix is a 2-D array of cells, equivalent to one sheet in a spreadsheet program. Xmat&lt;-matrix(Xvec,nrow=6) ## Warning in matrix(Xvec, nrow = 6): data length [25] is not a sub-multiple or ## multiple of the number of rows [6] Xmat ## [,1] [,2] [,3] [,4] [,5] ## [1,] &quot;1.1829378&quot; &quot;5&quot; &quot;E&quot; &quot;96&quot; &quot;90&quot; ## [2,] &quot;string&quot; &quot;6&quot; &quot;Computational Biology&quot; &quot;95&quot; &quot;1.1829378&quot; ## [3,] &quot;1&quot; &quot;7&quot; &quot;100&quot; &quot;94&quot; &quot;string&quot; ## [4,] &quot;2&quot; &quot;8&quot; &quot;99&quot; &quot;93&quot; &quot;1&quot; ## [5,] &quot;3&quot; &quot;9&quot; &quot;98&quot; &quot;92&quot; &quot;2&quot; ## [6,] &quot;4&quot; &quot;10&quot; &quot;97&quot; &quot;91&quot; &quot;3&quot; 2.4.3.1 Subset Notice the square brackets along the top and left side? These show the address of each element in the matrix. We can subset with square brackets, just like we did with vectors. Since there are two dimensions, we need to specify two numbers: [row,column] Xmat[1,3] ## [1] &quot;E&quot; Or leave it blank if you want the whole row or column: Xmat[1,] ## [1] &quot;1.1829378&quot; &quot;5&quot; &quot;E&quot; &quot;96&quot; &quot;90&quot; Xmat[,3] ## [1] &quot;E&quot; &quot;Computational Biology&quot; &quot;100&quot; ## [4] &quot;99&quot; &quot;98&quot; &quot;97&quot; 2.4.4 Tensors Tensors are the general term for a grid with N dimensions. Weve already seen a few different tensors: Name Tensor Dimension Cell 0 Vector 1 Matrix 2 Array 3+ Another common term for tensor is array. In R you can build tensors by adding as many dimensions as you need using the array() function Xarray&lt;-array(0, dim=c(3,3,2)) # 3 dimensions Xarray ## , , 1 ## ## [,1] [,2] [,3] ## [1,] 0 0 0 ## [2,] 0 0 0 ## [3,] 0 0 0 ## ## , , 2 ## ## [,1] [,2] [,3] ## [1,] 0 0 0 ## [2,] 0 0 0 ## [3,] 0 0 0 Notice how 3rd dimension is sliced to print out in 2D Higher-order arrays are possible, but a bit tricky to read on a 2-dimensional screen Xarray&lt;-array(rnorm(64), dim=c(2,2,2,2,2,2)) # 6 dimensions Once you get the hang of it, its easy to subset. Just think of each dimension, separated by commas. Xarray[1:2,1:2,1,1,1,1] ## [,1] [,2] ## [1,] -1.718987 0.3487603 ## [2,] 1.779268 -0.3523615 Xarray[1:2,1,1,1:2,1,1] ## [,1] [,2] ## [1,] -1.718987 0.8664164 ## [2,] 1.779268 1.2394975 Why are these numbers not the same? Look at the array[] function and compare to the 6-D tensor to understand how this works 2.5 Matrix Algebra R is pretty handy for matrix calculations that are very time consuming to do by hand or in a spreadsheet program ## Create some vectors to play with X&lt;-c(1:10) X ## [1] 1 2 3 4 5 6 7 8 9 10 Y&lt;-c(1:10*0.5) Y ## [1] 0.5 1.0 1.5 2.0 2.5 3.0 3.5 4.0 4.5 5.0 ## Use pretty much any standard operator for element-by element calculations X*Y # Multiply corresponding element (e.g. X[1]*Y[1], then X[2]*Y[2], etc) ## [1] 0.5 2.0 4.5 8.0 12.5 18.0 24.5 32.0 40.5 50.0 X+Y ## [1] 1.5 3.0 4.5 6.0 7.5 9.0 10.5 12.0 13.5 15.0 X/Y ## [1] 2 2 2 2 2 2 2 2 2 2 X^Y ## [1] 1.000000e+00 2.000000e+00 5.196152e+00 1.600000e+01 5.590170e+01 ## [6] 2.160000e+02 9.074927e+02 4.096000e+03 1.968300e+04 1.000000e+05 log(X) ## [1] 0.0000000 0.6931472 1.0986123 1.3862944 1.6094379 1.7917595 1.9459101 ## [8] 2.0794415 2.1972246 2.3025851 exp(Y) ## [1] 1.648721 2.718282 4.481689 7.389056 12.182494 20.085537 ## [7] 33.115452 54.598150 90.017131 148.413159 ## More advanced matrix algebra X%*%Y # Matrix multiplication (e.g. X[1]*Y[1]+X[2]*Y[2]...) ## [,1] ## [1,] 192.5 sum(X*Y) == X%*%Y ## [,1] ## [1,] TRUE Z&lt;-X[1:4]%o%Y[1:3] # Outer product Z ## [,1] [,2] [,3] ## [1,] 0.5 1 1.5 ## [2,] 1.0 2 3.0 ## [3,] 1.5 3 4.5 ## [4,] 2.0 4 6.0 t(Z) # Transpose ## [,1] [,2] [,3] [,4] ## [1,] 0.5 1 1.5 2 ## [2,] 1.0 2 3.0 4 ## [3,] 1.5 3 4.5 6 crossprod(X[1:4],Z) # Cross product ## [,1] [,2] [,3] ## [1,] 15 30 45 crossprod(Z) # Cross product of Z and t(Z) a.k.a. Z&#39;Z ## [,1] [,2] [,3] ## [1,] 7.5 15 22.5 ## [2,] 15.0 30 45.0 ## [3,] 22.5 45 67.5 diag(4) # Identity matrix, 4x4 in this case ## [,1] [,2] [,3] [,4] ## [1,] 1 0 0 0 ## [2,] 0 1 0 0 ## [3,] 0 0 1 0 ## [4,] 0 0 0 1 diag(Z) # Diagonal elements of Z ## [1] 0.5 2.0 4.5 2.5.1 PCA One example of a matrix calculation is principal components analysis. This is covered in more detail in the PCA Tutorial. PCA is widely used in biology, from community ecology and metagenomics to gene expression and morphometrics. It also has many applications outside of biology. For now, just know that it is easy to run a PCA using the prcomp() function: prcomp(Z, cor=T) ## Warning: In prcomp.default(Z, cor = T) : ## extra argument &#39;cor&#39; will be disregarded ## Standard deviations (1, .., p=3): ## [1] 2.415229 0.000000 0.000000 ## ## Rotation (n x k) = (3 x 3): ## PC1 PC2 PC3 ## [1,] 0.2672612 0.0000000 0.9636241 ## [2,] 0.5345225 -0.8320503 -0.1482499 ## [3,] 0.8017837 0.5547002 -0.2223748 2.6 Lists Tensors generally all have the same data type and sub-dimension. For example, if you want to combine two 2-d matrices into a single tensor (3rd dimension) then the individual matrices have to have the same number of rows and columns, and the same data type. Lists are useful for mixxing data types, and can combine different dimensions cells, vectors, and higher-order arrays Each element needs a name MyList&lt;-list(name=&quot;SWC&quot;,potpourri=Xvec,numbers=1:10) MyList ## $name ## [1] &quot;SWC&quot; ## ## $potpourri ## [1] &quot;1.1829378&quot; &quot;string&quot; &quot;1&quot; ## [4] &quot;2&quot; &quot;3&quot; &quot;4&quot; ## [7] &quot;5&quot; &quot;6&quot; &quot;7&quot; ## [10] &quot;8&quot; &quot;9&quot; &quot;10&quot; ## [13] &quot;E&quot; &quot;Computational Biology&quot; &quot;100&quot; ## [16] &quot;99&quot; &quot;98&quot; &quot;97&quot; ## [19] &quot;96&quot; &quot;95&quot; &quot;94&quot; ## [22] &quot;93&quot; &quot;92&quot; &quot;91&quot; ## [25] &quot;90&quot; ## ## $numbers ## [1] 1 2 3 4 5 6 7 8 9 10 2.6.1 Subset There are a few different ways to subset a list object MyList$numbers # Use $ to subset by name ## [1] 1 2 3 4 5 6 7 8 9 10 MyList[3] # A &#39;slice&#39; of MyList ## $numbers ## [1] 1 2 3 4 5 6 7 8 9 10 MyList[[3]] # An &#39;extract&#39; of MyList ## [1] 1 2 3 4 5 6 7 8 9 10 Whats the difference between [] and [[]]? Look carefully at the output above; notice how the [] includes $numbers but the [[]] includes only the values? This is important if you want to use the slice: 2*MyList[[3]] ## [1] 2 4 6 8 10 12 14 16 18 20 2*MyList[3] ## Error in 2 * MyList[3]: non-numeric argument to binary operator 2.6.2 Output Protip: Many analysis functions in R output as lists (e.g. statistical packages) For example, the output of prcomp: prcomp(Z) ## Standard deviations (1, .., p=3): ## [1] 2.415229 0.000000 0.000000 ## ## Rotation (n x k) = (3 x 3): ## PC1 PC2 PC3 ## [1,] 0.2672612 0.0000000 0.9636241 ## [2,] 0.5345225 -0.8320503 -0.1482499 ## [3,] 0.8017837 0.5547002 -0.2223748 names(prcomp(Z)) ## [1] &quot;sdev&quot; &quot;rotation&quot; &quot;center&quot; &quot;scale&quot; &quot;x&quot; prcomp(Z)$center ## [1] 1.25 2.50 3.75 prcomp(Z)$scale ## [1] FALSE 2.7 print() and paste() The print function is the go-to function for printing output to the user. The paste function is for combining things together. Paste is a versatile function for manipulating output: paste(&quot;Hello World!&quot;) # Basic string ## [1] &quot;Hello World!&quot; paste(&quot;Hello&quot;,&quot;World!&quot;) # Concatenate two strings ## [1] &quot;Hello World!&quot; paste(1:10) # Paste numbers as strings ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; &quot;6&quot; &quot;7&quot; &quot;8&quot; &quot;9&quot; &quot;10&quot; paste(1:10)[4] # Note that each number is a separate cell in a vector of strings ## [1] &quot;4&quot; as.numeric(paste(1:10)) # Convert back to numbers ## [1] 1 2 3 4 5 6 7 8 9 10 paste(1:10,collapse=&quot;.&quot;) # Collapse separate cells to produce a single string ## [1] &quot;1.2.3.4.5.6.7.8.9.10&quot; Note what happens if we combine objects of different length: paste(&quot;Hello&quot;,1:10,sep=&quot;-&quot;) # Note ## [1] &quot;Hello-1&quot; &quot;Hello-2&quot; &quot;Hello-3&quot; &quot;Hello-4&quot; &quot;Hello-5&quot; &quot;Hello-6&quot; ## [7] &quot;Hello-7&quot; &quot;Hello-8&quot; &quot;Hello-9&quot; &quot;Hello-10&quot; It is not uncommon to nest a paste function within a print: print(paste(&quot;Hello&quot;,1:10,sep=&quot;-&quot;)) ## [1] &quot;Hello-1&quot; &quot;Hello-2&quot; &quot;Hello-3&quot; &quot;Hello-4&quot; &quot;Hello-5&quot; &quot;Hello-6&quot; ## [7] &quot;Hello-7&quot; &quot;Hello-8&quot; &quot;Hello-9&quot; &quot;Hello-10&quot; This would be useful inside of a for loop (see below) where the output of paste is not shown on the screen if used inside of a loop, whereas the output of print is. 2.7.1 ? for HELP Whenever you are learning a new function, you should use ? and carefully read about all the parameters and outputs. The explanations can be a bit technical, which is intimidating at first. But after enough practice you will start to understand more and more of the descriptions. ?paste 2.8 Data So far weve done everything within the R environment. If we quit R then everything we have made will be removed from memory and well have to start all over. Therefore, it can be useful to save and load data from external files. 2.8.1 Working Directory The working directory is the place where R looks to load or save your files. You can figure out what your current working directory is with the getwd() function getwd() Or you can set a specific working directory. Heres one example: setwd(&quot;C:/Users/ColauttiLab/Documents&quot;) Did you type out the above line? You should! Remember, going through and typing everything out is one of the most effective ways to learn to code. So do it now Okay, so you probably have an error unless you are working in Windows and for some reason have a ColauttiLab username on your computer. Now try changing to a different directory on your computer. If you are a mac user, you can just ignore the C: part: setwd(&quot;/Users/ColauttiLab/Documents&quot;) 2.8.1.1 Relative Path The above examples of setwd() us an absolute path. You can also use a relative path. For example, if we have a folder called Data inside our Documents folder, and our current working directory is one of the two examples above, we can use a relative path name to set the Data folder as the working directory. Before you type this out, you should make a folder called Data inside of your current working directory: setwd(&quot;./Data&quot;) The . means Inside of my current directory and the /Data means find the Data folder now try this: getwd() setwd(&quot;..&quot;) getwd() Compare the working directories. The .. means Go to the parent directory The neat thing about relative directories is that it makes it easy to share code between Windows, MacOS and Linux/Unix. In fact, these commands come from Linux. You can check out the Linux Crash Course for more detail. 2.8.2 Import Download This Data File and save in a folder called Data inside of your current working directory. We can use the read.csv to read a comma-delimited file and import it into an object called MyData MyData&lt;-read.csv(&quot;Data/FallopiaData.csv&quot;,header=T) # Header=T tells read.csv to interpret first row as column labels A .csv file is just a text file with special formatting that can be read into a program like Microsoft Excel or R to translate the text file into a data matrix. Important: In R, objects created by read.csv and other read.? functions are special objects called data.frame objects. 2.8.3 data.frame A data.frame is a special type of 2D matrix with additional indexing information for rows/columns of data This format is partly why R is so useful for data analysis There are a number of useful functions for inspecting a data.frame object names(MyData) # See column names ## [1] &quot;PotNum&quot; &quot;Scenario&quot; &quot;Nutrients&quot; &quot;Taxon&quot; &quot;Symphytum&quot; ## [6] &quot;Silene&quot; &quot;Urtica&quot; &quot;Geranium&quot; &quot;Geum&quot; &quot;All_Natives&quot; ## [11] &quot;Fallopia&quot; &quot;Total&quot; &quot;Pct_Fallopia&quot; head(MyData) # Show first six rows of data ## PotNum Scenario Nutrients Taxon Symphytum Silene Urtica Geranium Geum ## 1 1 low low japon 9.81 36.36 16.08 4.68 0.12 ## 2 2 low low japon 8.64 29.65 5.59 5.75 0.55 ## 3 3 low low japon 2.65 36.03 17.09 5.13 0.09 ## 4 5 low low japon 1.44 21.43 12.39 5.37 0.31 ## 5 6 low low japon 9.15 23.90 5.19 0.00 0.17 ## 6 7 low low japon 6.31 24.40 7.00 9.05 0.97 ## All_Natives Fallopia Total Pct_Fallopia ## 1 67.05 0.01 67.06 0.01 ## 2 50.18 0.04 50.22 0.08 ## 3 60.99 0.09 61.08 0.15 ## 4 40.94 0.77 41.71 1.85 ## 5 38.41 3.40 41.81 8.13 ## 6 47.73 0.54 48.27 1.12 tail(MyData) # Show last six rows of data ## PotNum Scenario Nutrients Taxon Symphytum Silene Urtica Geranium Geum ## 118 143 fluctuations high bohem 5.06 12.81 23.82 3.64 0.16 ## 119 144 fluctuations high bohem 19.93 21.07 6.08 2.80 0.43 ## 120 145 fluctuations high bohem 4.89 32.93 6.30 9.64 0.00 ## 121 147 fluctuations high bohem 7.84 31.16 13.61 6.58 0.03 ## 122 148 fluctuations high bohem 4.15 38.70 23.59 5.11 1.36 ## 123 149 fluctuations high bohem 1.72 10.41 23.48 8.51 0.43 ## All_Natives Fallopia Total Pct_Fallopia ## 118 45.49 21.31 66.80 31.90 ## 119 50.31 0.00 50.31 0.00 ## 120 53.76 2.36 56.12 4.21 ## 121 59.22 3.74 62.96 5.94 ## 122 72.91 5.89 78.80 7.47 ## 123 44.55 19.70 64.25 30.66 dim(MyData) # Number of rows x columns (or &#39;dimension&#39;) of the data object ## [1] 123 13 nrow(MyData) # Number of rows only ## [1] 123 ncol(MyData) # Number of columns only ## [1] 13 str(MyData) # Data &#39;structure&#39; - types of variables ## &#39;data.frame&#39;: 123 obs. of 13 variables: ## $ PotNum : int 1 2 3 5 6 7 8 9 10 11 ... ## $ Scenario : chr &quot;low&quot; &quot;low&quot; &quot;low&quot; &quot;low&quot; ... ## $ Nutrients : chr &quot;low&quot; &quot;low&quot; &quot;low&quot; &quot;low&quot; ... ## $ Taxon : chr &quot;japon&quot; &quot;japon&quot; &quot;japon&quot; &quot;japon&quot; ... ## $ Symphytum : num 9.81 8.64 2.65 1.44 9.15 ... ## $ Silene : num 36.4 29.6 36 21.4 23.9 ... ## $ Urtica : num 16.08 5.59 17.09 12.39 5.19 ... ## $ Geranium : num 4.68 5.75 5.13 5.37 0 9.05 3.51 9.64 7.3 6.36 ... ## $ Geum : num 0.12 0.55 0.09 0.31 0.17 0.97 0.4 0.01 0.47 0.33 ... ## $ All_Natives : num 67 50.2 61 40.9 38.4 ... ## $ Fallopia : num 0.01 0.04 0.09 0.77 3.4 0.54 2.05 0.26 0 0 ... ## $ Total : num 67.1 50.2 61.1 41.7 41.8 ... ## $ Pct_Fallopia: num 0.01 0.08 0.15 1.85 8.13 1.12 3.7 0.61 0 0 ... Protip: str() is very important for functions that use data.frames including statistical analysis and plotting Pay careful attention to int vs num vs factor. These are the data types, as noted above. Heres an example of data types gone rogue: In an analysis of variance (ANOVA), you want a factor as a predictor. But in linear regression you want int or num as a predictor. If you code your factor (e.g. treatment) as a number (e.g. 1-4) then your data.frame will treat it as an integer. When you run a linear model, you will be running a regression rather than ANOVA. 2.8.4 Subset The data.frame object can be subset, just like a matrix MyData[1,] # Returns first row of data.frame ## PotNum Scenario Nutrients Taxon Symphytum Silene Urtica Geranium Geum ## 1 1 low low japon 9.81 36.36 16.08 4.68 0.12 ## All_Natives Fallopia Total Pct_Fallopia ## 1 67.05 0.01 67.06 0.01 MyData[1,1] # Returns first value of data.frame ## [1] 1 In addition, you can define the column names MyData[,&quot;PotNum&quot;] # Returns values in &quot;PotNum&quot; column ## [1] 1 2 3 5 6 7 8 9 10 11 12 14 16 17 18 19 20 22 ## [19] 23 24 25 26 28 29 30 31 33 34 35 36 38 39 40 41 42 44 ## [37] 45 47 48 49 50 52 53 54 55 57 58 60 61 62 63 65 66 67 ## [55] 68 69 70 72 73 74 76 77 78 79 80 81 83 84 85 86 87 88 ## [73] 90 91 92 93 94 95 96 97 98 100 101 102 103 104 105 107 108 110 ## [91] 111 112 113 114 116 117 118 119 120 121 122 124 125 126 127 128 129 131 ## [109] 132 133 134 135 136 138 139 140 142 143 144 145 147 148 149 MyData$PotNum # Another way to get the same output ## [1] 1 2 3 5 6 7 8 9 10 11 12 14 16 17 18 19 20 22 ## [19] 23 24 25 26 28 29 30 31 33 34 35 36 38 39 40 41 42 44 ## [37] 45 47 48 49 50 52 53 54 55 57 58 60 61 62 63 65 66 67 ## [55] 68 69 70 72 73 74 76 77 78 79 80 81 83 84 85 86 87 88 ## [73] 90 91 92 93 94 95 96 97 98 100 101 102 103 104 105 107 108 110 ## [91] 111 112 113 114 116 117 118 119 120 121 122 124 125 126 127 128 129 131 ## [109] 132 133 134 135 136 138 139 140 142 143 144 145 147 148 149 subset(MyData,Scenario==&quot;extreme&quot;) # Subset data where the Scenario column == &#39;extreme&#39; ## PotNum Scenario Nutrients Taxon Symphytum Silene Urtica Geranium Geum ## 74 91 extreme high japon 6.77 29.29 17.58 1.20 0.98 ## 75 92 extreme high japon 9.19 16.76 7.32 4.84 0.21 ## 76 93 extreme high japon 6.55 48.19 0.00 9.21 0.05 ## 77 94 extreme high japon 5.22 18.21 21.51 6.53 0.58 ## 78 95 extreme high japon 4.92 25.93 40.33 4.92 0.07 ## 79 96 extreme high japon 9.51 3.15 36.16 10.16 0.62 ## 80 97 extreme high japon 14.98 33.34 2.56 7.38 0.16 ## 81 98 extreme high japon 17.37 4.38 2.73 16.41 0.00 ## 82 100 extreme high japon 7.36 24.90 3.21 7.30 0.46 ## 83 101 extreme high japon 10.54 31.97 7.37 4.62 0.54 ## 84 102 extreme high japon 9.51 0.00 17.56 6.97 0.00 ## 85 103 extreme high japon 6.92 49.38 0.00 10.33 0.42 ## 86 104 extreme high japon 12.42 18.36 4.44 6.42 0.42 ## 87 105 extreme high japon 5.89 37.92 4.71 5.18 0.09 ## 88 107 extreme high bohem 0.00 43.85 8.10 8.18 0.36 ## 89 108 extreme high bohem 10.29 27.47 5.47 0.00 0.40 ## 90 110 extreme high bohem 17.39 24.42 10.71 8.34 0.00 ## 91 111 extreme high bohem 12.59 0.00 41.08 4.81 1.38 ## 92 112 extreme high bohem 15.27 1.66 25.77 8.79 0.50 ## 93 113 extreme high bohem 12.52 21.52 0.00 5.71 1.11 ## 94 114 extreme high bohem 11.33 31.61 6.95 10.14 0.86 ## 95 116 extreme high bohem 14.89 0.00 10.16 10.28 0.18 ## 96 117 extreme high bohem 14.12 24.57 12.59 8.46 0.63 ## 97 118 extreme high bohem 14.21 25.15 12.69 8.06 0.29 ## 98 119 extreme high bohem 0.00 36.79 8.69 3.38 1.20 ## 99 120 extreme high bohem 9.85 15.71 15.56 3.89 1.46 ## All_Natives Fallopia Total Pct_Fallopia ## 74 55.82 1.98 57.80 3.43 ## 75 38.32 3.40 41.72 8.15 ## 76 64.00 3.44 67.44 5.10 ## 77 52.05 6.73 58.78 11.45 ## 78 76.17 1.57 77.74 2.02 ## 79 59.60 6.08 65.68 9.26 ## 80 58.42 0.00 58.42 0.00 ## 81 40.89 14.46 55.35 26.12 ## 82 43.23 7.05 50.28 14.02 ## 83 55.04 0.00 55.04 0.00 ## 84 34.04 5.52 39.56 13.95 ## 85 67.05 4.02 71.07 5.66 ## 86 42.06 3.17 45.23 7.01 ## 87 53.79 3.41 57.20 5.96 ## 88 60.49 7.21 67.70 10.65 ## 89 43.63 8.83 52.46 16.83 ## 90 60.86 0.00 60.86 0.00 ## 91 59.86 2.33 62.19 3.75 ## 92 51.99 13.54 65.53 20.66 ## 93 40.86 7.33 48.19 15.21 ## 94 60.89 0.00 60.89 0.00 ## 95 35.51 12.62 48.13 26.22 ## 96 60.37 0.00 60.37 0.00 ## 97 60.40 7.46 67.86 10.99 ## 98 50.06 6.34 56.40 11.24 ## 99 46.47 2.66 49.13 5.41 levels(MyData$Scenario) ## NULL 2.8.5 New Columns Its easy to add new columns to a data frame. For example, to add a new column that is the sum of two others MyData$Total&lt;-MyData$Symphytum + MyData$Silene + MyData$Urtica names(MyData) ## [1] &quot;PotNum&quot; &quot;Scenario&quot; &quot;Nutrients&quot; &quot;Taxon&quot; &quot;Symphytum&quot; ## [6] &quot;Silene&quot; &quot;Urtica&quot; &quot;Geranium&quot; &quot;Geum&quot; &quot;All_Natives&quot; ## [11] &quot;Fallopia&quot; &quot;Total&quot; &quot;Pct_Fallopia&quot; print(MyData$Total) ## [1] 62.25 43.88 55.77 35.26 38.24 37.71 49.46 32.77 45.76 39.20 49.84 36.28 ## [13] 40.52 35.78 39.26 45.33 38.54 33.27 50.09 48.55 49.25 31.36 36.56 37.21 ## [25] 57.06 48.48 39.32 28.03 47.19 57.63 53.27 37.79 43.56 45.47 56.68 43.88 ## [37] 47.03 47.41 50.64 34.74 54.40 48.46 64.48 49.31 48.97 54.00 55.71 64.35 ## [49] 38.73 41.31 52.31 56.77 50.10 47.22 38.61 59.73 75.59 36.33 53.57 54.94 ## [61] 39.21 45.22 25.39 57.10 38.00 37.51 56.86 43.48 51.86 67.97 16.43 58.13 ## [73] 52.64 53.64 33.27 54.74 44.94 71.18 48.82 50.88 24.48 35.47 49.88 27.07 ## [85] 56.30 35.22 48.52 51.95 43.23 52.52 53.67 42.70 34.04 49.89 25.05 51.28 ## [97] 52.05 45.48 41.12 45.67 38.18 53.30 40.52 36.70 58.78 37.31 14.48 43.19 ## [109] 65.25 30.79 54.97 62.96 38.64 37.08 41.39 38.85 39.34 41.69 47.08 44.12 ## [121] 52.61 66.44 35.61 2.9 Other Functions There are a few more useful functions for inspecting your data. 2.9.1 unique Find all the unique values within a vector using unique unique(MyData$Nutrients) ## [1] &quot;low&quot; &quot;high&quot; 2.9.2 duplicated Look at each value in a vector and return a TRUE if it is duplicated and FALSE if it is unique duplicated(MyData$Nutrients) ## [1] FALSE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE ## [13] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE ## [25] TRUE FALSE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE ## [37] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE ## [49] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE ## [61] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE ## [73] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE ## [85] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE ## [97] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE ## [109] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE ## [121] TRUE TRUE TRUE This is a good example of a Boolean vector, which can be used to subset your data. MyData$Nutrients[duplicated(MyData$Nutrients)] ## [1] &quot;low&quot; &quot;low&quot; &quot;low&quot; &quot;low&quot; &quot;low&quot; &quot;low&quot; &quot;low&quot; &quot;low&quot; &quot;low&quot; &quot;low&quot; ## [11] &quot;low&quot; &quot;low&quot; &quot;low&quot; &quot;low&quot; &quot;low&quot; &quot;low&quot; &quot;low&quot; &quot;low&quot; &quot;low&quot; &quot;low&quot; ## [21] &quot;low&quot; &quot;low&quot; &quot;low&quot; &quot;low&quot; &quot;high&quot; &quot;high&quot; &quot;high&quot; &quot;high&quot; &quot;high&quot; &quot;high&quot; ## [31] &quot;high&quot; &quot;high&quot; &quot;high&quot; &quot;high&quot; &quot;high&quot; &quot;high&quot; &quot;high&quot; &quot;high&quot; &quot;high&quot; &quot;high&quot; ## [41] &quot;high&quot; &quot;high&quot; &quot;high&quot; &quot;high&quot; &quot;high&quot; &quot;high&quot; &quot;high&quot; &quot;high&quot; &quot;high&quot; &quot;high&quot; ## [51] &quot;high&quot; &quot;high&quot; &quot;high&quot; &quot;high&quot; &quot;high&quot; &quot;high&quot; &quot;high&quot; &quot;high&quot; &quot;high&quot; &quot;high&quot; ## [61] &quot;high&quot; &quot;high&quot; &quot;high&quot; &quot;high&quot; &quot;high&quot; &quot;high&quot; &quot;high&quot; &quot;high&quot; &quot;high&quot; &quot;high&quot; ## [71] &quot;high&quot; &quot;high&quot; &quot;high&quot; &quot;high&quot; &quot;high&quot; &quot;high&quot; &quot;high&quot; &quot;high&quot; &quot;high&quot; &quot;high&quot; ## [81] &quot;high&quot; &quot;high&quot; &quot;high&quot; &quot;high&quot; &quot;high&quot; &quot;high&quot; &quot;high&quot; &quot;high&quot; &quot;high&quot; &quot;high&quot; ## [91] &quot;high&quot; &quot;high&quot; &quot;high&quot; &quot;high&quot; &quot;high&quot; &quot;high&quot; &quot;high&quot; &quot;high&quot; &quot;high&quot; &quot;high&quot; ## [101] &quot;high&quot; &quot;high&quot; &quot;high&quot; &quot;high&quot; &quot;high&quot; &quot;high&quot; &quot;high&quot; &quot;high&quot; &quot;high&quot; &quot;high&quot; ## [111] &quot;high&quot; &quot;high&quot; &quot;high&quot; &quot;high&quot; &quot;high&quot; &quot;high&quot; &quot;high&quot; &quot;high&quot; &quot;high&quot; &quot;high&quot; ## [121] &quot;high&quot; Note that only the TRUE values are returned (duplicated) 2.9.3 aggregate Quickly calculate means of one vector (Total) for each value of a grouping variable (Nutrients) aggregate(MyData$Total,list(MyData$Nutrients), mean) ## Group.1 x ## 1 high 46.51173 ## 2 low 42.76800 The ~ provides an alternative way to write this function. In R the ~ usually means by and is often used in statistical models. Here we can say aggregate Total by Nutrients grouping aggregate(Total ~ Nutrients, data=MyData, mean) ## Nutrients Total ## 1 high 46.51173 ## 2 low 42.76800 The nice thing about doing it this way is that we preserve the column name (Total instead of x). You can also use this to calculate means across different grouping variables aggregate(Total ~ Nutrients*Taxon*Scenario, data=MyData, mean) ## Nutrients Taxon Scenario Total ## 1 high bohem extreme 45.24833 ## 2 high japon extreme 45.31500 ## 3 high bohem fluctuations 43.89545 ## 4 high japon fluctuations 44.77692 ## 5 high bohem gradual 45.36923 ## 6 high japon gradual 50.43417 ## 7 high bohem high 52.04273 ## 8 high japon high 45.69417 ## 9 low bohem low 41.75231 ## 10 low japon low 43.86833 Note that mean is just the mean() function in R. We can use other functions, like the standard deviation sd: aggregate(Total ~ Nutrients, data=MyData, sd) ## Nutrients Total ## 1 high 11.175885 ## 2 low 8.227402 2.9.4 tapply The tapply function is a more general way to replicate functions. tapply(MyData$Total, list(MyData$Nutrients), mean) # calculate means ## high low ## 46.51173 42.76800 Compare the two outputs with aggregate above 2.9.5 Save Just as we can load FROM external files, we can save TO external files ## Calulate means NutrientMeans&lt;-tapply(MyData$Total,list(MyData$Nutrients),mean) ## Save means as .csv file write.csv(NutrientMeans,&quot;MyData_Nutrient_Means.csv&quot;) You should see this file in your working directory. 2.10 Flow control Think of your data analysis as a stream flowing from the raw data at the headwaters and flowing down to the end, exiting as a full analysis with graphics, stats, and interpretation. There are different ways we can control the flow of the water. The simplest is just to write a sequence of lines of code, with the output of one line of code forming the input of the next. There are several examples of this above: A&lt;-functionA() B&lt;-functionB(A) C&lt;-functionC(B) But sometimes we may want to do the same function or analysis only if the input meets certain criteria. Or we may want to reiterate the same analysis multiple times on different inputs. This is where more advanced flow control comes in handy. To start, lets make up a couple of objects to play with: X&lt;-21 Xvec&lt;-c(1:10,&quot;string&quot;) 2.10.1 if The if statement uses an operator (see above) to asses whether the value is TRUE or FALSE: if(X &gt; 100){ # Greater-than operator assessing whether X is greater than 100 print(&quot;X &gt; 100&quot;) # What to do if TRUE (X greater than 100) } else { print(&quot;X &lt;= 100&quot;) # What do do if FALSE (X less than 100) } ## [1] &quot;X &lt;= 100&quot; NOTE: A common rookie mistake is to leave out a bracket or use the wrong type. Use regular brackets for the if function if() followed by two sets of curly brackets {}else{}. Break up across multiple lines to improve readability. Note that you dont need an else{} part if you just want to do nothing when FALSE. if(1 &gt; 0){print (&quot;yup&quot;)} ## [1] &quot;yup&quot; 2.10.2 ifelse The ifelse is a more compact version for simple comparisons. The following code does the same as above ifelse(X &gt; 100, print(&quot;X &gt; 100&quot;), print(&quot;X &lt;= 100&quot;)) ## [1] &quot;X &lt;= 100&quot; ## [1] &quot;X &lt;= 100&quot; 2.10.3 for loop A loop does the same thing over and over again until some condition is met. In the case of a for loop, we set a counter variable and loop through each value of the counter variable. Here are a few examples: # Loop through numbers from 1 to X for (i in 1:X){ print(paste(X,i,sep=&quot;:&quot;)) } ## [1] &quot;21:1&quot; ## [1] &quot;21:2&quot; ## [1] &quot;21:3&quot; ## [1] &quot;21:4&quot; ## [1] &quot;21:5&quot; ## [1] &quot;21:6&quot; ## [1] &quot;21:7&quot; ## [1] &quot;21:8&quot; ## [1] &quot;21:9&quot; ## [1] &quot;21:10&quot; ## [1] &quot;21:11&quot; ## [1] &quot;21:12&quot; ## [1] &quot;21:13&quot; ## [1] &quot;21:14&quot; ## [1] &quot;21:15&quot; ## [1] &quot;21:16&quot; ## [1] &quot;21:17&quot; ## [1] &quot;21:18&quot; ## [1] &quot;21:19&quot; ## [1] &quot;21:20&quot; ## [1] &quot;21:21&quot; # Loop through elements of a vector directly for (i in Xvec){ print(i) } ## [1] &quot;1&quot; ## [1] &quot;2&quot; ## [1] &quot;3&quot; ## [1] &quot;4&quot; ## [1] &quot;5&quot; ## [1] &quot;6&quot; ## [1] &quot;7&quot; ## [1] &quot;8&quot; ## [1] &quot;9&quot; ## [1] &quot;10&quot; ## [1] &quot;string&quot; # Use an index to loop through the elements for (i in 1:length(Xvec)){ print(Xvec[i]) } ## [1] &quot;1&quot; ## [1] &quot;2&quot; ## [1] &quot;3&quot; ## [1] &quot;4&quot; ## [1] &quot;5&quot; ## [1] &quot;6&quot; ## [1] &quot;7&quot; ## [1] &quot;8&quot; ## [1] &quot;9&quot; ## [1] &quot;10&quot; ## [1] &quot;string&quot; Note that in each case there is a vector and we loop through each cell in the vector. The i keeps track of the cell value in each iteration of the loop. Loops can be tricky, and the only way to really learn them is to try to write a bunch. Whenever you find yourself writing similar code more than 2 or 3 times, challenge yourself to try to do it as a loop. In addition to looping through a vector, it can often be useful to include a counter variable. One thing to watch out for is what part of the loop you want to update the counter variable. USUALLY it will be at the beginning count1&lt;-1 count10&lt;-1 for(i in 1:10){ print(paste(&quot;count1 =&quot;,count1)) print(paste(&quot;count10 =&quot;,count10)) count1&lt;-count1+1 count10&lt;-count10*10 } ## [1] &quot;count1 = 1&quot; ## [1] &quot;count10 = 1&quot; ## [1] &quot;count1 = 2&quot; ## [1] &quot;count10 = 10&quot; ## [1] &quot;count1 = 3&quot; ## [1] &quot;count10 = 100&quot; ## [1] &quot;count1 = 4&quot; ## [1] &quot;count10 = 1000&quot; ## [1] &quot;count1 = 5&quot; ## [1] &quot;count10 = 10000&quot; ## [1] &quot;count1 = 6&quot; ## [1] &quot;count10 = 1e+05&quot; ## [1] &quot;count1 = 7&quot; ## [1] &quot;count10 = 1e+06&quot; ## [1] &quot;count1 = 8&quot; ## [1] &quot;count10 = 1e+07&quot; ## [1] &quot;count1 = 9&quot; ## [1] &quot;count10 = 1e+08&quot; ## [1] &quot;count1 = 10&quot; ## [1] &quot;count10 = 1e+09&quot; or at the end. countbefore&lt;-0 countafter&lt;-0 for(i in 1:10){ countbefore&lt;-countbefore+1 print(paste(&quot;before =&quot;,countbefore)) print(paste(&quot;after =&quot;,countafter)) countafter&lt;-countafter+1 } ## [1] &quot;before = 1&quot; ## [1] &quot;after = 0&quot; ## [1] &quot;before = 2&quot; ## [1] &quot;after = 1&quot; ## [1] &quot;before = 3&quot; ## [1] &quot;after = 2&quot; ## [1] &quot;before = 4&quot; ## [1] &quot;after = 3&quot; ## [1] &quot;before = 5&quot; ## [1] &quot;after = 4&quot; ## [1] &quot;before = 6&quot; ## [1] &quot;after = 5&quot; ## [1] &quot;before = 7&quot; ## [1] &quot;after = 6&quot; ## [1] &quot;before = 8&quot; ## [1] &quot;after = 7&quot; ## [1] &quot;before = 9&quot; ## [1] &quot;after = 8&quot; ## [1] &quot;before = 10&quot; ## [1] &quot;after = 9&quot; Read through the outputs above carefully to make sure you understand how the loops work. When you are confident you understand, then write a new for loop and write down the predicted output. Run the loop to check if you were right. 2.10.4 Nested Loops Counters are particularly valuable when you have a nested loop, which is just one loop inside of another. In the example below, we are first looping through a vector of length 3, tracked with i. Then for each i we do a second loop, tracked by j. This time, try to predict the output BEFORE you run the loop. Write it down, then run the loop to check your answer. LoopCount&lt;-0 for(i in 1:3){ for(j in 1:4){ LoopCount&lt;-LoopCount+1 print(paste(&quot;i = &quot;,i)) print(paste(&quot;j = &quot;,j)) print(paste(&quot;Loop =&quot;,LoopCount)) } } ## [1] &quot;i = 1&quot; ## [1] &quot;j = 1&quot; ## [1] &quot;Loop = 1&quot; ## [1] &quot;i = 1&quot; ## [1] &quot;j = 2&quot; ## [1] &quot;Loop = 2&quot; ## [1] &quot;i = 1&quot; ## [1] &quot;j = 3&quot; ## [1] &quot;Loop = 3&quot; ## [1] &quot;i = 1&quot; ## [1] &quot;j = 4&quot; ## [1] &quot;Loop = 4&quot; ## [1] &quot;i = 2&quot; ## [1] &quot;j = 1&quot; ## [1] &quot;Loop = 5&quot; ## [1] &quot;i = 2&quot; ## [1] &quot;j = 2&quot; ## [1] &quot;Loop = 6&quot; ## [1] &quot;i = 2&quot; ## [1] &quot;j = 3&quot; ## [1] &quot;Loop = 7&quot; ## [1] &quot;i = 2&quot; ## [1] &quot;j = 4&quot; ## [1] &quot;Loop = 8&quot; ## [1] &quot;i = 3&quot; ## [1] &quot;j = 1&quot; ## [1] &quot;Loop = 9&quot; ## [1] &quot;i = 3&quot; ## [1] &quot;j = 2&quot; ## [1] &quot;Loop = 10&quot; ## [1] &quot;i = 3&quot; ## [1] &quot;j = 3&quot; ## [1] &quot;Loop = 11&quot; ## [1] &quot;i = 3&quot; ## [1] &quot;j = 4&quot; ## [1] &quot;Loop = 12&quot; 2.10.5 while loop The while is another kind of loop, but instead of looping through a predefined set of variables, we iterate until some condition is met inside of the loop. This is called the exit condition. Often, the while loop is used in optimization algorithms, where many calculations are run until some optimum or threshold value is reached. One common coding error associated with while loops is that the exit condition is never reached, causing your computer to run an infinite loop. Heres a simple while loop, which will continue until count is greater than or equal to X. count&lt;-0 while (count &lt; X){ print(count) count&lt;-count+1 } ## [1] 0 ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 4 ## [1] 5 ## [1] 6 ## [1] 7 ## [1] 8 ## [1] 9 ## [1] 10 ## [1] 11 ## [1] 12 ## [1] 13 ## [1] 14 ## [1] 15 ## [1] 16 ## [1] 17 ## [1] 18 ## [1] 19 ## [1] 20 2.11 Packages As noted above, functions in R use brackets () and generally have input and output objects as well as parameters that affect their behaviour. All of the functions in this tutorial are automatically loaded when you start R. There are many more functions available from developers. For example, our lab developed the baRcodeR package for creating unique identifier codes with printable barcodes and data sheets to help with sample management and data collection. A package in R is a set of functions grouped together. For example, the stats package is automatically loaded when you run R and contains many useful functions. You can see what package a function belongs to at the beginning of the help file: ?cor 2.11.1 Installing Before you can use a new function from a package that isnt installed with R, you first have to install the package on your computer. You only have to do this once per computer. However, it is a good idea to update the package frequently, especially when you update your version of R. This ensures that you are using the most recent version of the package. Note that installing a package just downloads it from an online repository and saves to your computer. Packages are installed with install.packages(), with the package indicated with single or double quotation marks. You may be asked for a repository, in which case choose one that is geographically close to you. install.packages(&#39;baRcoeR&#39;) 2.11.2 Loading Once you have installed a package, you can access it two ways. 2.11.2.1 1. Library You can load the package using the library() function, giving you access to functions contained within it: library(baRcodeR) make_labels() 2.11.2.2 2. Function You can run a function without loading the whole package: baRcodeR::make_labels() This translates to \"Run the make_labels function from the baRcodeR library. The first method is more common, especially for the commonly used functions covered in these self-tutorials. However, the second method is convenient if you just want to use one function from a large library that take up a lot of space. More importantly, some packages have functions with the same names. Lets say you load two packages pkgA and pkgB that have different functions but both are called cor. When you run the cor function, R will assume you want the one from the package that was most recently loaded using the library() function. However, you can over-ride this with the second method: pkgA::cor() pkgB::cor() 2.11.2.3 Library vs Package The terms library and package are often used interchangeably. Technically, the package is the collection of functions whereas the library is the specific folder where the R packages are stored. A library may contain more than one package. For the most part, you just need to know that a package and a library are a collection of functions. 2.12 Readable code Its important to make your code readable and interpretable by collaborators, peer reviewers, and yourself 6 months from now. There are lots of opinions on this but here are a few basic suggestions: Add documentation to explain what you are doing Add spacing between parameters to improve readability Add spacing on either side of &lt;- when making objects Break long functions into multiple lines; add the line break after a , or + Follow these suggestions for object/column/file names a. Try to keep your names short and concise but meaningful b. Use underscore _ to improve readability and avoid . c. Always start with a letter d. Avoid symbols Bad Good sum(X,na.rm=T) sum(X, na.rm=T) data.frame(X, Y, ..., data=...) data.frame(X, Y, ..., data=...) X Mass Days.To.First.Flower Flwr_Days or FDays 10d.Height Ht10d Length*Width LxW To take your code to the next level, look into the Tidyverse Style Guide 2.13 TEST yourself: Are you ready to test your knowledge? If so, click HERE "],["quick-visualizations.html", "Chapter 3 Quick Visualizations 3.1 Overview 3.2 Getting Started 3.3 Basic Graphs 3.4 Basic customization 3.5 Themes and Geoms 3.6 Multiple graphs 3.7 Save output 3.8 Practice", " Chapter 3 Quick Visualizations 3.1 Overview Visualizing data is a key step in any analysis. Whether you are just starting to understand the structure of your data or polishing off the perfect figure for publication in tabloid journal like Science or Nature, R provides powerful and flexible graphing tools. In this tutorial, you will learn how to make quick graphs with the qplot function, with the option of some basic formatting customization. In the ggplot Tutorial you will learn some additional tricks and resources for developing your graphing skills even further By the time you are finished these two self-tutorials, you will have all the resources you need to make publication-ready graphics! All you will really need to do is practice and apply what you have learned. Both qplot and ggplot come from the ggplot2 package. Dont ask me what happened to ggplot1 Developed by Hadley Wickham and the same team as R Studio, ggplot2 is part of the Tidyverse group of helpful R packages. Once you have mastered these tutorials, you might want to continue to expand your ggplot repertoire by reading through additional examples in the ggplot2 documentation http://docs.ggplot2.org/current/ WARNING: There is a learning curve! Learning visualizations in R can feel like a struggle at first, and you may ask yourself: Is it worth my time? If you already have experience making figures with graphics programs, you may ask youself: Why deal with all these coding errors when I can just generate a quick figure in a different program? There are a few good reasons to invest the time to get over the learning curve and use R for all your graphing needs. You will get much faster with practice You have much more control over every aspect of your figure Your visualization will be reproducible, meaning anyone with the data and the code can reproduce every aspect of your figure, from each individual data point down to the specific axis labels. The third point is worth some extra thought. Everybody makes mistakes, whether you are graphing with R or a point-and-click graphics program. If you make an error in R you will either get an error message telling you, or you will have reproducible code that you can have somebody check. If you make a mistake in a point-and-click program, you may produce a graph that is incorrect and no way to check! Now consider what happens if you add new data or find a mistake in your original data that needs to be corrected. With a point-and-click program you have to make the graph all over again. With R, you just rerun the code with new input and get the updated figure right away! 3.1.1 Graphical Concepts There are a few universal graphing concepts that are important to understand in order to create publication-ready graphics in R. 3.1.2 Vector vs. Raster The first concept is to understand that there are two main file types that you can use to save your graphs. Once saved, you can send these to graphics programs, printers, or journal websites. Raster files save graphs in a 2-dimensional grid of data corresponding to pixels. You are probably quite familiar with this format if youve ever worked with a digital photo or an 8-bit video game. Some popular Raster file types include JPEG/JPG, PNG, TIFF, and BMP. Vector files save information about points, lines and curves. If youve ever drawn a shape in a program like Microsoft Powerpoint or Adobe Illustrator, you might have some sense of how this works. Some popular vector formats include SVG, PDF, EPS, AI, PS. Why does this matter? In most cases, you should save your visualizations as vector files. SVG is a good choice, because it can be interpreted by web browsers and it is not proprietary. PDF and EPS are commonly used by publishers. The reason for this is that raster files introduce artifacs when they are scaled. You may have seen some images that look pixelated  this happens when you try to expand the size of a lower-resolution figure. In contrast, you can expand vector images to any size and the lines will always be clean and clear. This is why they are generally preferred for publication. There are a few important exceptions, however. Photographs  Photographs captured by a camera are saved in the Raster format and cannot be converted to vector without significant loss of information Grid Data  Raster data are convenient for plotting data that occurs in a grid. This may include spatial data that is broken up into a geographic grid. However, even in these cases, you may often want to use the vector format so that the overlapping geographical features (e.g. borders, lakes, rivers) are not pixellated. Large Data  With some large data applications a graph may have many millions or billions of data points or lines. In these cases, the vector file would be too big to use in publication (e.g. several gigabytes). In this case you might opt for a high-resolution Raster file. On the other hand, you could graph your data using a density grid with colours corresponding to the density of points. In this case, you could use the vector format to maintain clean lines for the graph axes and labels. The bottom line: you generally want to save your graphics as SVG or PDF files if you plan to publish them. 3.1.3 Resolution vs Dimension In cases where you do need to use raster images in a publication, pay careful attention to the images Pixel Dimension. We are used to thinking about resolution  for example a 2 megapixel camera is better than a 1 megapixel camera. Or 200 dpi (dots per inch) is better than 100 dpi. But its not just the resolution that matters, the image size also determines the quality of the final image. The size and resolution of an image jointly determine its Pixel Dimension. For example, an image with 200 dpi that is 1 x 3 inches will have the same pixel dimension of an image with 100 dpi that is 2 x 6 inches. These images will look exactly the same if they are printed at the same size. Thats because the pixel dimension determines how an image looks on a page, and both of these have the same pixel dimension: 200 x 600 pixels. 3.1.4 Screen vs Print Another important consideration is whether your figures are intended for a computer screen or printed page (or both). Each pixel of your screen has tiny lights that determine the specific colour that is reproduced. The emission of different wavelengths from your screen produces the different colours. In contrast, printed images get their colour from combinatios of ink, which absorb different wavelengths of colour. As a result, some colours that look fine on your screen do not reproduce well in print. In print, the intensity of colours are limited by the intensity of the Cyan, Magenta and Yellow inks that are used to reproduce the images. This is called CMYK printing. Some programs like Adobe Illustrator have options to limit the colours on your screen to only display colours that can be reproduced with CMYK printing. 3.1.5 Accessibility There are two other important considerations for colouring your figures. First, remember that a significant portion of the population is unable to see certain colours. In addition, many scientists and students may print out your paper in black-and-white. You should try to choose colours that can be discerned in these situations. The viridis package is a good tool for this. See: https://cran.r-project.org/web/packages/viridis/vignettes/intro-to-viridis.html 3.1.6 Slides Some of the above information is covered and expanded in the Introductory Slides for examples of graphical output from R, using ggplot2 and other graphing functions. These slides cover: Graphing examples Graphical concepts ggplot grammar anatomy of a qplot/ggplot graph 3.2 Getting Started Install the ggplot2 package using install.packages(\"ggplot2\"). Load it with the library function whenever you want to include a function from the ggplot2 library in your code.. library(ggplot2) The ggplot2 package includes two main functions, quickplot qplot() for fast graphs and the ggplot() function for more detailed, customizable graphs. 3.2.1 Data setup We will again be working with the FallopiaData.csv dataset, which can be downloaded here: https://colauttilab.github.io/RCrashCourse/FallopiaData.csv, and saved to your project folder, which you can identify with the getwd() function. You may want to save this to a folder called Data, and then open the file in R: MyData&lt;-read.csv(&quot;./Data/FallopiaData.csv&quot;, header=T) alternatively, you can load the file right from the internet: MyData&lt;-read.csv(&quot;https://colauttilab.github.io/RCrashCourse/FallopiaData.csv&quot;, header=T) This dataset comes from the research group of Dr. Oliver Bossdorf at the University of Tuebingen in Tuebingen, Germany  a wonderful little town on the Neckar River. The data come from a plant competition experiment involving two invasive species from the genus Fallopia. str(MyData) ## &#39;data.frame&#39;: 123 obs. of 13 variables: ## $ PotNum : int 1 2 3 5 6 7 8 9 10 11 ... ## $ Scenario : chr &quot;low&quot; &quot;low&quot; &quot;low&quot; &quot;low&quot; ... ## $ Nutrients : chr &quot;low&quot; &quot;low&quot; &quot;low&quot; &quot;low&quot; ... ## $ Taxon : chr &quot;japon&quot; &quot;japon&quot; &quot;japon&quot; &quot;japon&quot; ... ## $ Symphytum : num 9.81 8.64 2.65 1.44 9.15 ... ## $ Silene : num 36.4 29.6 36 21.4 23.9 ... ## $ Urtica : num 16.08 5.59 17.09 12.39 5.19 ... ## $ Geranium : num 4.68 5.75 5.13 5.37 0 9.05 3.51 9.64 7.3 6.36 ... ## $ Geum : num 0.12 0.55 0.09 0.31 0.17 0.97 0.4 0.01 0.47 0.33 ... ## $ All_Natives : num 67 50.2 61 40.9 38.4 ... ## $ Fallopia : num 0.01 0.04 0.09 0.77 3.4 0.54 2.05 0.26 0 0 ... ## $ Total : num 67.1 50.2 61.1 41.7 41.8 ... ## $ Pct_Fallopia: num 0.01 0.08 0.15 1.85 8.13 1.12 3.7 0.61 0 0 ... The first 4 columns give information about the pot and treatments. The rest give biomass measurements. 3.3 Basic Graphs Think back to the R Fundamentals Tutorial, and you will hopefully recall the different data types. For graphing purposes, there are two main types of data: categorical and continuous putting these together in different combinations with plot gives us different graphs. One nice thing is that we dont have to specify which graphs to make; qplot will decide which type of graph based on the type of data. Of course, we can also specify a plot type if we want something different. 3.3.1 One continuous If we input one continous variable, qplot will produce a frequency histogram by default. 3.3.1.0.1 Histogram qplot(x=Total, data=MyData) ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. 3.3.2 One categorical If we input one categorical variable, qplot will produce a bar graph showing counts for each category. 3.3.2.0.1 Bar Graph qplot(x=Scenario, data=MyData) 3.3.3 Two continuous If we input two continuous variables, we get the classic bivariate plot a.k.a. scatterplot. 3.3.3.0.1 Bivariate plot qplot(x=Silene, y=Total, data=MyData) 3.3.4 Two categorical Plotting two categorical variables just plots overlapping dots, and its not so useful except if you want to check for representation of particular variables. qplot(x=Nutrients, y=Scenario, data=MyData) In this case we can see that there is only one type of Low Nutrient treatment, but 4 types of High treatments. In other words, all of the rows with Low nutrient treatment also have the Low scenario, and NONE of the rows with Low in the scenario column have Low in the Nutrients column. 3.3.5 Categorical by continuous If we input a combination of categorical and continuous variables, we see get a categorical scatterplot showing the spread of points along the Y or X axis. 3.3.5.0.1 Categorical scatter plots qplot(x=Nutrients, y=Total, data=MyData) Thats it! Thats all you need to start exploring your data! Load your data frame, and plot different combinations of variables to look at the distribution of values or the relationship between your variables. Of course, you might also want to make a few quick tweaks to the look of the graph. 3.4 Basic customization There are a number of parameters available with qplot() to quickly customize a few of the basic features of your graphs. Most of these will work with ggplot() as well, though the syntax or context is a bit different in some cases. Refer back to these when you work through the ggplot Tutorial. 3.4.1 binwidth Use this with the histogram graph to alter the size of the bins along the x-axis. qplot(x=Total, data=MyData, binwidth=9) qplot(x=Total, data=MyData, binwidth=0.5) 3.4.2 size This controls the size of points (usually) or sometimes lines, depending on the context. qplot(x=Silene, y=Fallopia, data=MyData, size=Total) # Scale by a variable qplot(x=Silene, y=Total, data=MyData, size=I(5)) # Scale by a constant NOTE the use of the identity function: I() for constant. What happens if you just put a 5 in there without the identity function? Do it and see if you can figure out the problem. Try using different numbers for comparison (e.g., 2, 5 and 10). How does the size change when you include the I() function vs when you just put the number in? The explanation is a bit tricky, but imagine if you added a column to your data frame and put in a number. Then for size you put the column name. R would treat this as a variable and scale the size of the symbol to the value in this column. However, since all the rows have the same value, then they all have the same scaled size. Now try using a different column for scaling: qplot(x=Silene, y=Total, data=MyData, size=Total) # Scale by column &#39;Total&#39; You can see in the legend how the point size scales with the column called Total On the other hand, the identify function I() tells R: I want to use this exact point size. 3.4.3 colour or color Another nice feature of qplot and ggplot is that you can use different spelling. You can use colour or color to colour add colour to your graphs. For example, you can colours points based on a factor qplot(x=Silene, y=Fallopia, data=MyData, colour=Nutrients) # Categorical colour qplot(x=Silene, y=Fallopia, data=MyData, colour=Total) # Continuous colour Or use the identity function I() again to set a specific colour qplot(x=Silene, y=Total, data=MyData, colour=I(&quot;purple&quot;)) # basic colour qplot(x=Silene, y=Total, data=MyData, colour=I(rgb(1,0,0))) # rgb = red/green/blue 3.4.3.1 Histogram Note what happens when we use the colour parameter for a histrogram qplot(x=Total, data=MyData, group=Nutrients, colour=Nutrients) ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. The coloured outlines might be useful but we usually will want the inside coloured. 3.4.4 fill This parameter is used for boxes and other shapes that have a separate outline (colour=) and interior (fill=). qplot(x=Total, data=MyData, group=Nutrients, fill=Nutrients) ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. 3.4.5 posit Use this to adjust the position, usually for histograms or bar graphs. For example, if we want to compare histograms on the same graph: qplot(x=Total, data=MyData, group=Nutrients, fill=Nutrients) ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. Its hard to interpret that graph, so we can shift the position using \"dodge\". qplot(x=Total, data=MyData, group=Nutrients, fill=Nutrients, posit=&quot;dodge&quot;) ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. 3.4.6 alpha Think of alpha as a measure of opacity, ranging from 0 to 1 with 1 being the default, solid point or line and 0 being invisible. This is particularly useful for visualizing overlapping points. qplot(x=Silene,y=Total,data=MyData,size=I(5),alpha=I(0.3)) 3.4.7 shape You can also change the shape of your points, again using a column of data or the identity I() function. qplot(x=Silene,y=Total,data=MyData,size=I(5),shape=Nutrients) qplot(x=Silene,y=Total,data=MyData,size=I(5),shape=I(17)) There are a number of different shapes available, by specifying a number from 0 through 25. Note that the shapes with grey in the above figure can be coloured with fill= paremeter, while all of the black parts (lines and fill) can be coloured with the colour= parameter. You can use fill and colour to customize these separately. qplot(x=Silene,y=Total,data=MyData,size=I(5),shape=I(21),fill=I(&quot;yellow&quot;),colour=I(&quot;red&quot;)) 3.4.8 lab, xlab, and ylab Use these to customize your axis labels. qplot(x=Silene, y=Total, data=MyData, xlab=&quot;Silene Biomass&quot;,ylab=&quot;Total Biomass&quot;) 3.4.9 main This will add a title to your plot. Usually you wouldnt use this for a figure intended for publication, but this can be useful for reports, websites, presentations, supplementary material, appendices, etc. qplot(x=Silene,y=Total,data=MyData,main=&quot;Biomass&quot;) 3.5 Themes and Geoms Themes determine the look and feel of your graphs, while Geoms determine the geometry  how your data are physically mapped to the graphing space. In both qplot and ggplot, themes are added with a separate function linked to the graph by using the plus sign +. Geoms are defined by the geom= paremeter inside the qplot() function or with a specific geom_FUNCTION() linked to the main ggplot() function by using the plus sign. These are easy to understand with a few examples. 3.5.1 + theme_NAME() There are a number of available themes, defined by changing the NAME part. qplot(x=Silene,data=MyData) + theme_grey() # default ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. qplot(x=Silene,data=MyData) + theme_bw() # cleaner, better contrast ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. qplot(x=Silene,data=MyData) + theme_linedraw() # thicker grid lines ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. qplot(x=Silene,data=MyData) + theme_light() # fainter border and axis values ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. qplot(x=Silene,data=MyData) + theme_minimal() # no borders ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. qplot(x=Silene,data=MyData) + theme_classic() # x and y lines only, no tick marks ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. These can be further customized. Or you can create a completely new theme. For example, here is a simplified and cleaner version of theme_classic but with bigger axis labels taht are more suitable for figures in presentation or publication: # Clean theme for presentations &amp; publications used in the Colautti Lab theme_pub &lt;- function (base_size = 12, base_family = &quot;&quot;) { theme_classic(base_size = base_size, base_family = base_family) %+replace% theme( axis.text = element_text(colour = &quot;black&quot;), axis.title.x = element_text(size=18), axis.text.x = element_text(size=12), axis.title.y = element_text(size=18,angle=90), axis.text.y = element_text(size=12), axis.ticks = element_blank(), panel.background = element_rect(fill=&quot;white&quot;), panel.border = element_blank(), plot.title=element_text(face=&quot;bold&quot;, size=24), legend.position=&quot;none&quot; ) } To use this theme, you could just copy-and-paste the above function into your R code. Alternatively, you could save it as a separate .R file and thean load it with the source() function. A third, even easier option, is to load the version of this code that is available online: source(&quot;http://bit.ly/theme_pub&quot;) The theme is called theme_pub (pub = publication): qplot(x=Silene,data=MyData) + theme_pub() # A clean format with bigger axis labels for publication ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. qplot(x=Pct_Fallopia,y=Silene,data=MyData) + theme_pub() # Bivariate plot 3.5.2 theme_set If you want to use the same theme throughout your code, you can use this funciton. theme_set(theme_pub()) qplot(x=Silene,data=MyData) ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. 3.5.3 geom In addition to the default genomes that qplot uses for different data types, there are some other options available. For example, the scatterplot doesnt give a good sense of the spread of the data. qplot(x=Nutrients,y=Total,data=MyData) # Basic But the boxplot geom shows the median (line), 1st and 3rd quartiles (boxes), range of most observations (whiskers), and potential outliers (dots) qplot(x=Nutrients,y=Total,data=MyData,geom=&quot;boxplot&quot;) # Geom Another useful example is for histograms with many bins which can be smoothed into a density curve rather than plotting bar graphs. For example, the bar graph from above qplot(Total,data=MyData) # Basic ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. reformatted as a density geom. qplot(Total,data=MyData,geom=&quot;density&quot;) # Geom See the ggplot2 website for a complete list of geoms with examples: https://ggplot2.tidyverse.org/reference/ 3.6 Multiple graphs It is often handy to plot separate graphs for different categories of a grouping variable. This can be done with facets in qplot. 3.6.1 facets Facets have the general form VERTICAL ~ HORIZONTAL. Use the period . to indicate all data r do not separate my data. qplot(x=Silene,data=MyData,facets=Nutrients~.) # Vertical stacking ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. qplot(x=Silene,data=MyData,facets=.~Nutrients) # Horizontal stacking ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. qplot(x=Silene,data=MyData,facets=Taxon~Nutrients) # Both (2 column stacking) ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. 3.7 Save output Saving your graphs to an external file requires three important steps: Open a file using a function like pdf or svg for the vector format, or png for the raster format. Run the code to produce the graph, just like above. However, instead of seeing a graph in your R interface, you will not see anything because the graph is being sent to the file. Close the file! Do this with the dev.off() function. Important: If you dont close the file, it is unusable. Failing to close the file is a common source of error when generating graphs. If you are having problems with graphing outputs, try running the dev.off() function a few times to make sure you close any files that are hanging open. Heres an example code for making a pdf output of a grpah. pdf(&quot;SileneHist.pdf&quot;) # 1. Create and open a file qplot(x=Silene,data=MyData,facets=Taxon~Nutrients) # 2. Write the graph info dev.off() # 3. Close the file Note how the qplot command does not open in the plots window when you run this. This is because the info is sent to SileneHist.pdf file instead of the graphing area in your R console (e.g. plots tab in R Studio) 3.8 Practice Graphing may seem slow and tedious at first, but the more you practice, the faster you will be able to produce meaningful visualizations. Dont be afraid to try new things. Try mixing up components and see what happens. At worst you will just get an error message. Once you have a good understanding of these basics, you can see how to build more advanced plots with ggplot(). "],["advanced-visualizations.html", "Chapter 4 Advanced Visualizations 4.1 Overview 4.2 Getting Started 4.3 Rules of thumb 4.4 Example 4.5 Measuring Selection 4.6 ggplot vs qplot 4.7 Full ggplot 4.8 Multi-graph 4.9 Further Reading", " Chapter 4 Advanced Visualizations 4.1 Overview Before following this tutorial, you should be familiar with the qplot() tutorial, and you should have lots of practice making graphs with different formatting options using qplot. In this self-tutorial, we look at some more advanced options for visualizations by using the ggplot function. The 1ggplot function adds even more flexibiliity and possibilities to our visualizations. The ggplot cheat sheet is a downloadable pdf that provides a good summary and quick-reference guide for advanced graphics. 4.2 Getting Started Well load the ggplot2 library and set a custom theme as described in the qplot Tutorial library(ggplot2) source(&quot;http://bit.ly/theme_pub&quot;) theme_set(theme_pub()) The source function loads an external file, in this case from the internet. The file is just a .R file with a custom function defining different aspects of the graph (e.g. text size, line width, etc.) You can open the link in a web browser or download and open in a text editor to see the file. The theme_set() command sets our custom theme (theme_pub) as the default plotting theme. Since the theme is a function in R, we need the extra brackets: theme_pub() 4.3 Rules of thumb Standards of practice for published graphs in professional journals can vary depending on format and discipline, but there are a number of useful rules of thumb to keep in mind. These are not hard and fast rules but helpful for new researchers who arent sure how or where to start. 4.3.1 1. Minimize ink In the old days, when most papers were actually printed and mailed to journal subscribers, black ink was expensive and printing in colour was very expensive. Printing is still expensive but of course most research articles are available online where there is no additional cost to colour or extra ink. However, the concept of minimizing ink (or pixels) can go a long way toward keeping a graph free from clutter and unnecessary distraction. 4.3.2 2. Use space wisely Empty space is not necessarily bad, but ask yourself if it is necessary and what you want the reader to take away. Consider the next two graphs: Above: Y-axis scaled to the data Above: Y-axis scaled between 0 and 100 What are the benefits/drawbacks of scaling the axes? When might you choose to use one over ther other? 4.3.3 3. Choose a colour palette Colour has three basic components Hue  the amount of red vs green vs blue light Saturation  how vivid the colour is Brightness  the amount of white (vs black) in the colour In R these can be easily defined with the rgb() function. For example: rgb(1,0,0)  a saturated red rgb(0.1,0,0)  a dark red (low brightness, low saturation) rgb(1,0.9,0.9)  a light red (high brightness, low saturation) Dont underestimate the impact of choosing a good colour palette, especially for presentations. Colour theory can get a bit overwhelming but here are a few good websites to help: Quickly generate your own palette using coolors Use a colour wheel to find complementary colours using Adobe Browse some pre-made palettes or create one from a picture colorfavs 4.3.4 4. Colours have meaning Whats wrong with this graph? Humans naturally associate colours with particular feelings. Be mindful of these associations when choosing a colour palette Another important consideration is that not everyone sees colour the same way. About 5% to 10% of the population has colour blindness. In order to make colour graphs readable to everyone, you can use different 4.3.5 5. Maximize contrast Colours that are too similar will be hard to distinguish 4.3.6 6. Keep relevant information Make sure to include proper axis labels (i.e. names) and tick marks (i.e. numbers or categories showing the different values). These labels, along with the figure caption, should act as a stand-alone unit. The reader should be able to understand the figure without having to read through the rest of the paper. 4.3.7 7. Choose the right graph Often the same data can be presented in different ways but some are easier to interpret than others. Think carefully about the story you want to present and the main ideas you want your reader to get from your figures. Look at these two graphs that show the same data and see which one is more intuitive X&lt;-rnorm(100) Y&lt;-X+rnorm(100) qplot(c(X,Y),fill=c(rep(&quot;X&quot;,100),rep(&quot;Y&quot;,100)),posit=&quot;dodge&quot;) ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. qplot(X,Y) 4.4 Example To get to know ggplot better, lets do a step-by-step example of a figure published in a paper by Colautti &amp; Lau in the journal Molecular Ecology (2015) 4.4.1 Setup 4.4.1.1 Import data Download selection dataset from Colautti &amp; Lau (2015), published in the journal Molecular Ecology: https://doi.org/10.1111/mec.13162 The paper is a meta-analysis and review of evolution occurring during biological invasions. in this tutorial, well recreate Figure 2, which shows the result of a meta-analysis of selection gradients (\\(\\beta\\)) and selection differentials (\\(\\s\\)). First, well just recreate the top panel, and then well look at ways to make more advanced multi-panel graphs like this one. The data from the paper are archived on Dryad: https://datadryad.org/stash/dataset/doi:10.5061/dryad.gt678 You could downoad the zip file and look for the file called Selection_Data.csv and save it to your working directory. Or you can just download directly from this website: SelData&lt;-read.csv(&quot;https://colauttilab.github.io/RCrashCourse/Selection_Data.csv&quot;, header=T) We are also going to change the names from the file to make them a bit more intuitive and easier to work with in R. names(SelData)&lt;-c(&quot;Collector&quot;, &quot;Author&quot;, &quot;Year&quot;, &quot;Journal&quot;, &quot;Vol&quot;, &quot;Species&quot;, &quot;Native&quot;, &quot;N&quot;, &quot;Fitness.measure&quot;, &quot;Trait&quot;, &quot;s&quot;, &quot;s.SE&quot;, &quot;s.P&quot;, &quot;B&quot;, &quot;B.SE&quot;, &quot;B.P&quot;) 4.4.2 Inspect Lets take a quick look at the data head(SelData) ## Collector Author Year Journal ## 1 KingsolverDiamond Alatalo and Lundberg 1986 Evolution ## 2 KingsolverDiamond Alatalo and Lundberg 1986 Evolution ## 3 KingsolverDiamond Alatalo and Lundberg 1986 Evolution ## 4 KingsolverDiamond Alatalo et al. 1990 American Naturalist ## 5 KingsolverDiamond Alatalo et al. 1990 American Naturalist ## 6 KingsolverDiamond Alatalo et al. 1990 American Naturalist ## Vol Species Native N Fitness.measure ## 1 40:574-583 Ficedula hypoleuca yes 641 male mating success ## 2 40:574-583 Ficedula hypoleuca yes 713 female mating success ## 3 40:574-583 Ficedula hypoleuca yes 1705 survival ## 4 135(3):464-471 Ficedula albicollis yes &lt;NA&gt; survival ## 5 135(3):464-471 Ficedula albicollis yes &lt;NA&gt; survival ## 6 135(3):464-471 Ficedula albicollis yes &lt;NA&gt; survival ## Trait s s.SE s.P B B.SE B.P ## 1 tarsus length -0.01 ns NA ## 2 tarsus length 0.01 sig NA ## 3 tarsus length 0.04 ns NA ## 4 tarus length 0.02 ns -0.06 ## 5 tarus length 0.08 ns -0.01 ## 6 tarus length 0.19 sig 0.01 Its worth taking some time to look at this to understand how a meta-analysis works. The collector column indicates the paper that the data came from. The Author indicates the author(s) of the original paper that reported the data. The Year, Journal, and Vol give information about the publication that the data came from originally. We can see above the collector KingsolverDiamond, which represents a paper from Kingsolver and Diamond that was itself a meta-analysis of natural selection. Most of the studies came from this meta-analysis, but a few of the more recent papers were added by grad students, denoted by initials: unique(SelData$Collector) ## [1] &quot;KingsolverDiamond&quot; &quot;JAL&quot; &quot;DJW&quot; ## [4] &quot;CPT&quot; Species is the study species, and Native is its stauts as a binary yes/no variable. N is the sample size and Fitness.measure is the specific trait that defines fitness. Trait is the trait on which selection was measured. Finally, \\(s\\) is the selection differential and \\(\\beta\\) is the selection gradient. Note that these are slopes in units of relative fitness per trait standard deviation. This is explained in more detail below. 4.4.3 Absolute Value In this analysis, we are interested in the magnitude but not the direction of natural selection. In other words we would want to treat a slope of -4 the same as a slope of +4 because they have the same magnitude. Therefore, we can replace the \\(s\\) column with \\(|s|\\) SelData$s&lt;-abs(SelData$s) Well also add a couple of columns with random variables that we can use later to explore additional plotting options. First, a column of values sampled from a z-distribution (Gaussian distribution with mean = 0 and sd = 1) SelData$Rpoint&lt;-rnorm(nrow(SelData)) # Random, normally distributed Second, a columnn of 1 and 0 sampled randomly with equal frequency (p = 0.5) SelData$Rgroup&lt;-sample(c(0,1),nrow(SelData),replace=T) # Random binary value 4.4.4 Missing values Note the missing data (denoted NA) print(SelData$s) We can subset to remove mising data SelData&lt;-SelData[!is.na(SelData$s),] Recall from the R Fundamentals Tutorial that ! means not or invert Alternatively, we could use filter from dplyr library(dplyr) SelData&lt;-SelData %&gt;% filter(!is.na(s)) There is also has a convenient drop_na function in the tidyr package library(tidyr) SelData&lt;-SelData %&gt;% drop_na(s) 4.5 Measuring Selection A simple analysis of phenotypic selection as proposed by Lande &amp; Arnold (1983) is just a linear model with relative fitness on the y-axis and the standardized trait value on the x-axis. 4.5.1 Relative Fitness Fitness can be measured in many ways, such as survival or lifetime seed or egg production. Use unique(SelData$Fitness.measure) to see the list of specific fitness measures used in these studies. relative fitness is just the observed or absolute fitness divided by the mean. Absolute fitness is usually denoted by the capital letter \\(W\\) and relative fitness is usually represented by a lower-case \\(w\\) or omega \\(\\omega\\). Expressing this in mathematical terms: \\[ \\omega = W_i/\\bar W \\] 4.5.2 Trait Value A Trait Value is literally just the measured trait. Use unique(SelData$Trait) to see the list of specific traits that were measured in these studies. The Standardized Trait Value is the traits z-score. See the Distributions Tutorial for more information about z-scores. Since traits have different metrics, they are hard to compare: e.g. days to flower, egg biomass, foraging intensity, aggression. But standardizing traits to z-scores puts them all on the same scale for comparison. Specifically, the scale is in standard deviations from the mean. 4.5.3 \\(s\\) vs \\(\\beta\\) Selection differentials (\\(s\\)) and selection gradients (\\(\\beta\\)) measure selection using linear models but represent slightly different measurements. Linear models are covered in the Linear Models Tutorial. Both models use relative fitness (\\(\\omega\\)) as the response variable (Y). Selection differentials (\\(s\\)) measure selection on only a single trait, ignoring all other traits. In theory, the response to selection is a simple function of the genetic correlation between a trait and fitness. Some of this theory, with examples in R, is covered in the Population Genetics Tutorials. Fitness differences among individuals can depend on a lot of things  genetic variation for the trait itself, but also environmental effects on the trait as well as effects on other traits that are under selection and correlated with the trait of interest. Selection gradients (\\(\\beta\\)) measure selection on a trait of interest while also accounting for selection on other correlated traits. This is done via a multiple regression  a linear model with multiple predictors. 4.6 ggplot vs qplot We can create the same graph using qplot and ggplot, just the syntax changes. 4.6.1 Histogram Compare this qplot BarPlot&lt;-qplot(s, data=SelData, fill=Native, geom=&quot;bar&quot;) print(BarPlot) with this ggplot BarPlot &lt;-ggplot(aes(s, fill=Native), data=SelData) 4.6.2 aes Note the use of the aesthetic funciton aes(). This defines the data that we want to use for our ggplot graph. We will see how we do this by adding layers to our plot, similar to the way old-timey cartoons were made by layering multiple clear pages of cellphane with painting on them. The aes function inside of the ggplot function defines that data that will be shared among all of the layers. In addition, we can have separate aes functions inside different geom_ layers that define and restrict the plotting data to that specific layer. Lets look at the ggplot object so far: print(BarPlot) No data! This is one key difference between qplot and ggplot. The former has default geoms that it applies depending on the type of input data. We can modify geoms with the geom='NAME' parameter in qplot, where NAME is the specific name of the geom we want to use. In ggplot we have to explictly define the geoms using geom_NAME where name is the specific name of the geom  the same text that would go in quotation marks for the geom in qplot. The advantage of using ggplot is that its easier to creat multiple, overlapping layers with different geoms from types data sources. 4.6.3 Layers So far, we have only loaded in the data info for plotting. We have to specify which geom(s) we want BarPlot&lt;- BarPlot + geom_bar() # info from ggplot() passed to geom_bar() BarPlot Explore the components of our BarPlot object: summary(BarPlot) ## data: Collector, Author, Year, Journal, Vol, Species, Native, N, ## Fitness.measure, Trait, s, s.SE, s.P, B, B.SE, B.P, Rpoint, Rgroup ## [2766x18] ## mapping: x = ~s, fill = ~Native ## faceting: &lt;ggproto object: Class FacetNull, Facet, gg&gt; ## compute_layout: function ## draw_back: function ## draw_front: function ## draw_labels: function ## draw_panels: function ## finish_data: function ## init_scales: function ## map_data: function ## params: list ## setup_data: function ## setup_params: function ## shrink: TRUE ## train_scales: function ## vars: function ## super: &lt;ggproto object: Class FacetNull, Facet, gg&gt; ## ----------------------------------- ## geom_bar: width = NULL, na.rm = FALSE, orientation = NA ## stat_count: width = NULL, na.rm = FALSE, orientation = NA ## position_stack This shows us the columns of data available, the mapping for our x and y axes, and our fill colours. It also shows some of the functions and parameters used to generate the graph. At the bottom we see parameters for geom_bar and stat_count. Note that there are more parameters than the ones we defined. These are the default parameters. 4.6.4 stat_NAME If geoms are the geometry of the shapes in the plt, stats are the statistics or mathematical functions that create the geoms. In the above case, the bars in geom_bar are created by counting the number of observations in each bin. The stat_count function is responsible for this calculation, and it is called by default when we use the geom_bar function. Just as we can change the geometry of the plotted shapes with geom_NAME, we can define different functions for generating shapes with stat_NAME. Luckily, there is a default stat for each geom, so we dont have to choose it unless we want something other than the default. For more information on the parameters and stast of geom_bar() ?geom_bar 4.6.5 Bivariate geom Lets explroe a few more plotting options. Here well use the random normal values we generated above so that we can make a bivariate plot: BivPlot&lt;-ggplot(data=SelData, aes(x=s, y=Rpoint)) + geom_point() print(BivPlot) Notice how the points are all clustered to the left. This looks like a classic log-normal variable, so lets log-transform \\(s\\) (x-axis) BivPlot&lt;-ggplot(data=SelData, aes(x=log(s+1), y=Rpoint)) + geom_point() print(BivPlot) 4.6.6 geom_smooth A really handy feature of ggplot is the geom_smooth function with several options for calculating and plotting a statistical model to the observations. Heres a simple linear regression slope: BivPlot + geom_smooth(method=&quot;lm&quot;,colour=&quot;steelblue&quot;,size=2) ## `geom_smooth()` using formula &#39;y ~ x&#39; We can use a grouping variable to add separate regression lines for each group BivPlot + geom_smooth(method=&quot;lm&quot;,size=2,aes(group=Native,colour=Native)) ## `geom_smooth()` using formula &#39;y ~ x&#39; 4.7 Full ggplot Now that weve done a bit of exploration, lets try to recreate the selection histograms from Colautti &amp; Lau: Create separate data for native vs. introduced species Use a bootstrap to estimate non-parametric mean and 95% confidence intervals Plot all of the components on a single graph 4.7.1 Separate data NatSVals&lt;-SelData$s[SelData$Native==&quot;yes&quot;] # s values for Native species IntSVals&lt;-SelData$s[SelData$Native==&quot;no&quot;] # s values for Introduced species 4.7.2 Bootstrap The graph includes a bootstrap model to estimate the mean and variance for each group (native=yes vs no). Bootstrapping is covered in the Bootstrapping and Randomization Tutorial. The example below is not the most efficient approach but it applies the flow control concepts covered in the R Fundamentals Tutorial 4.7.2.1 Data Setup First we define the number of iterations and set up two objects to hold the data from our bootstrap loops. IterN&lt;-100 # Number of iterations NatSims&lt;-{} # Dummy objects to hold output IntSims&lt;-{} 4.7.2.2 for loop Here we apply our for loop. in each round, we: Sample, with replacement and calculate average Store average in NatSims (native species) or IntSims (non-native species) for (i in 1:IterN){ NatSims[i]&lt;-mean(sample(NatSVals,length(NatSVals),replace=T)) IntSims[i]&lt;-mean(sample(IntSVals,length(IntSVals),replace=T)) } 4.7.2.3 95% CI Confidence Intervals (CI) are calculated from the bootstrap output. First, sort the datea from low to high NatSims&lt;-sort(NatSims) IntSims&lt;-sort(IntSims) Each of the objects contains a number of values equal to our Iter variable defined above. Now we identify the lower 2.5% and upper 97.5% values in each vector. For example, with 1000 iterations our 2.5% would be the 25th value in the sorted vector and the upper 97.5% would be the 975th value in the sorted vector. We use this number to index the vector with square brackets. We make sure to round to a whole number since we cant have a fractional cell position. CIs&lt;-c(sort(NatSims)[round(IterN*0.025,0)], # Native, lower 2.5% sort(NatSims)[round(IterN*0.975,0)], # Native, upper 97.5% sort(IntSims)[round(IterN*0.025,0)], # Intro, lower 2.5% sort(IntSims)[round(IterN*0.975,0)]) # Intro, upper 97.5% 4.7.3 Plot data Well combine the separate bootstrap vectors into a single data.frame object to make it easier to incorporate into our ggplot functions. HistData&lt;-data.frame(s=SelData$s,Native=SelData$Native) Now we can add layers to the plot. Well print out each layer as we go, so that we can see what each layer does. The coding is a bit complex here, so dont worry if its hard to follow everything. The key thing to understand here is how the different geoms contribute to the final plot as individual layers. p &lt;- ggplot() + theme_classic() p &lt;- p + geom_freqpoly(data=HistData[HistData$Native==&quot;yes&quot;,], aes(s,y=(..count..)/sum(..count..)),alpha = 0.6,colour=&quot;#1fcebd&quot;,size=2) print(p) # native species histogram ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. p &lt;- p + geom_freqpoly(data=HistData[HistData$Native==&quot;no&quot;,], aes(s,y=(..count..)/sum(..count..)),alpha = 0.5,colour=&quot;#f53751&quot;,size=2) print(p) # introduced species histogram ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. p &lt;- p + geom_rect(aes(xmin=CIs[1],xmax=CIs[2],ymin=0,ymax=0.01),colour=&quot;white&quot;,fill=&quot;#1fcebd88&quot;) print(p) # native species 95% CI bar ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. p &lt;- p + geom_line(aes(x=mean(NatSims),y=c(0,0.01)),colour=&quot;#1d76bf&quot;,size=1) print(p) # native species bootstrap mean ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. p &lt;- p + geom_rect(aes(xmin=CIs[3],xmax=CIs[4],ymin=0,ymax=0.01),colour=&quot;white&quot;,fill=&quot;#f5375188&quot;) print(p) # introduced species 95% CI bar ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. p &lt;- p + geom_line(aes(x=mean(IntSims),y=c(0,0.01)),colour=&quot;#f53751&quot;,size=1) print(p) # introduced species bootstrap mean ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. p &lt;- p + ylab(&quot;Frequency&quot;) + scale_x_continuous(limits = c(0, 1.5)) print(p) # labels added, truncated x-axis ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. ## Warning: Removed 12 rows containing non-finite values (stat_bin). ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. ## Warning: Removed 1 rows containing non-finite values (stat_bin). ## Warning: Removed 2 row(s) containing missing values (geom_path). ## Warning: Removed 2 row(s) containing missing values (geom_path). Another important point to note is that case we leave the ggplot() function empty because each geom uses different data. The data for each geom is defined by separate aes functions inside of each geom. 4.8 Multi-graph In the qplot Tutorial we saw a quick and easy way to make multiple graphs for different groups using the facets parameter. 4.8.1 facets We can also use facets with gpplot, just using a slightly different syntax giving a couple of options: facet_grid lets us define a grid and set the vertical and horizontal variables facet_wrap is a convenient option if only have one categorical variable but many categories NOTE: one little tricky part of facets with ggplot is that it uses vars instead of the aes function to indicate which categorical variables from the original dataset should be used to subset the graphs. Returning to the BivPlot example above: BivPlot&lt;-ggplot(data=SelData, aes(x=log(s+1), y=Rpoint)) + geom_point() BivPlot + facet_grid(rows=vars(Native), cols=vars(Collector)) BivPlot&lt;-ggplot(data=SelData, aes(x=log(s+1), y=Rpoint)) + geom_point() BivPlot + facet_wrap(vars(Year)) 4.8.2 grid.extra package Facets produce graphs with the same x- and y-axes. We might call these homogenous plots because they use the same axes and they are all the same size. For publications though, we might want to includ heterogeneous plots with different axes and different sizes. The gridExtra package provides options for this. Install gridExtra with install.packages(\"gridExtra\") library(gridExtra) 4.8.2.1 grid.arrange() Use this to combine heterogeous ggplot objects into a single multi-panel plot. Note that this will print ghe graphs graphs down rows, then across columns, from top left to bottom right. You can use nrow and ncol to control the layout in a grid format. HistPlot&lt;-p # Make a more meaningful name grid.arrange(HistPlot,BivPlot,BarPlot,ncol=1) grid.arrange(HistPlot,BivPlot,BarPlot,nrow=2) Note: You might get some warnings based on missing values or wrong binwidth. You will also see some weird things with different text sizes in the graphs. Normally, you would want to fix these for a final published figure but here we are just focused on showing what is possible with the layouts. 4.8.3 grid package What if we want to have graphs of different sizes? Or what if we want one figure to be inside another? We can make some even more advanced graphs using the grid package. library(grid) First, we set up the plotting area with grid.newpage grid.newpage() # Open a new page on grid device To insert a new graph on top (or inside) the current graph, we use pushViewport to set up an imaginary plotting grid. In this case, imagine breaking up the plotting space into 3 rows by two columsn. pushViewport(viewport(layout = grid.layout(3, 2))) # Create 3x2 grid layout Finally, we print each ggplot object, specifying which grid(s) to plot in. print(HistPlot, vp = viewport(layout.pos.row = 3, layout.pos.col = 1:2)) # Add fig in row 3 and across columns 1:2 print(BivPlot, vp = viewport(layout.pos.row = 1:2, layout.pos.col = 1)) # add fig acros rows 1:3 in column 1 print(BarPlot, vp = viewport(layout.pos.row = 1:2, layout.pos.col = 2)) 4.8.3.1 Inset We can also use pushViewport to set up a grid for plotting on top of an existing graph or image. This can be used to generate a figure with an inset. HistPlot pushViewport(viewport(layout = grid.layout(4, 4))) # Create 4x4 grid layout (number of cells, will determine size/location of graph) print(BivPlot, vp = viewport(layout.pos.row = 1:2, layout.pos.col = 3:4)) 4.9 Further Reading The 2009 book ggplog2: Elegant Graphics for Data Analysis by Hadly Wickham is the definitive guide to all things ggplot. A physical copy is published by Springer http://link.springer.com/book/10.1007%2F978-0-387-98141-3 And there is a free ebook version: https://ggplot2-book.org/ "],["regular-expressions.html", "Chapter 5 Regular Expressions 5.1 Overview 5.2 Functions 5.3 Wildcards 5.4 New Lines 5.5 Special characters 5.6 [] 5.7 ^ and $ 5.8 () 5.9 Scraping 5.10 Examples 5.11 Solutions 5.12 More Exercises", " Chapter 5 Regular Expressions 5.1 Overview Regular Expressions, also known as regex and regexp is a syntax that allows for coders to run complex find-and-replace functions. I didnt learn regular expressions until I was a postdoc working at Duke University, but I wish I had learned this a lot earlier! This remains one of the most useful programming tools I have ever used. It is absolutely essential for working with any kind of large text files or large datasets. A lot of programming tools in biology use input text files that require very specific formatting (e.g. .txt, .csv, .fasta, .nex). Sometimes, you might need to reorganize or recode data in a large text file. This can be a big pain that can lead to errors if you try to do everything manually. But regular expressions can automate the process. Heres one example. As a PhD student I co-founded a project called the Global Garlic Mustard Field Survey (GGMFS) with collaborator Dr. Oliver Bossdorf at the University of Tuebingen  yes the same Dr. Bossdorf mentioned in the qplot Tutorial. We were fortunate to have over 100 collaborators across Europe and North America who helped to collect samples for the project. Details of the project were published in the Journal Neobiota: https://neobiota.pensoft.net/article/1270/ but one BIG problem is the way that each of these 100+ collaborators entered their data online. For example, latitudes and longitudes were entered in a variety of different formats. Regular expressions allowed me to write a small program to automatically convert all of these different formats to a common, decimal format that we could use for the analysis. This saved a huge amount of time and prevented errors that could have been introduced if we tried to edit these values by hand. Often when you work with large datasets, you will need to automate some of your error correction, and regular expressions can be a big help here. For example, imagine a simple field where people were simply asked a simple yes or no question. You might find a variety of inputs such as: YES, Y, yes, and Yes. These all mean the same thing but if you try to analyze it, R will treat these as different categories. Here again, regular expressions can be used to quickly change all the different examples to a common Y or even a boolean variable TRUE. One final example, is pattern searching. This is common for the analysis of DNA, proteins or other large strings of data. You may want to find a particular sequence of data, possibly with a few variable sites: e.g. TCTA or TCAA or TCGA. This is another area where regular expressions can help. 5.1.1 Universal Regular expressions are a universal language that extends to many other programming languages, including C/C#/C++, Python, Unix/Linux, and Perl. We focus here on R but most of the syntax is mantained across programming languages. WARNING! There is a very steep learning curve here, and the only way to really learn this is to drown yourself in examples. There are lots of exercises you can do for practice online. You should also try to apply these whenever you can. 5.2 Functions There are four main functions that use regular expressions in R. grep() and grepl() are equivalent to find in your favorite word processor They have the general form: grep(\"find this pattern\", in.this.object) grep() outputs a vector with all the address locations (i.e. numbers) that match. Thus the output length is equal to the number of matches. grepl() outputs a vector of TRUE (match) and FALSE (no match). Thus, the output length is equal to the length of the input object. sub() and gsub() are equivalent to find and replace They have the general form: grep(\"find this pattern\", \"and replace with this\", in.this.object) sub() replaces only the first match, whereas gsub() replaces all of the matches. Some specific examples are provided below to help you understand these similarities and differences. There are two other more advanced functions in R. These arent covered in this tutorial, but may be of use once you are more comortable with the above functions. regexpr() provides more detailed info about the first match gregexpr() provides more detailed results about all matches 5.2.1 Examples Some examples can help to understand the differences among the four main functions. Lets start with a simple data frame of species names. Species&lt;-c(&quot;petiolata&quot;, &quot;verticillatus&quot;, &quot;salicaria&quot;, &quot;minor&quot;) print(Species) ## [1] &quot;petiolata&quot; &quot;verticillatus&quot; &quot;salicaria&quot; &quot;minor&quot; 5.2.2 grep() This returns cell addresses matching query. Note the vector length compared to the input vector. grep(&quot;a&quot;,Species) ## [1] 1 2 3 5.2.3 grepl() This returns a vector of TRUE (match) and FALSE (no match). Comapre this output with grep(). grepl(&quot;a&quot;,Species) ## [1] TRUE TRUE TRUE FALSE 5.2.4 sub() This replaces the first match (in each cell) sub(&quot;l&quot;,&quot;L&quot;,Species) ## [1] &quot;petioLata&quot; &quot;verticiLlatus&quot; &quot;saLicaria&quot; &quot;minor&quot; 5.2.5 gsub() This replaces all matches (in each cell). Compere this output to sub(). gsub(&quot;l&quot;,&quot;L&quot;,Species) ## [1] &quot;petioLata&quot; &quot;verticiLLatus&quot; &quot;saLicaria&quot; &quot;minor&quot; 5.3 Wildcards 5.3.1 \\ escape character The backslash is a special character. Its called the escape character because it is used to escapes the interpretation of the next character that occurs after it. This is easier to understand by example, as shown below. 5.3.2 \\\\ in R In the introduction, we discussed the universality of regular expressions in the sense that a similar syntax is used by many different programming langagues. But now here is one exception. In R, the double-escape is usually needed, whereas other programming languages typically use just one. The reason is a bit meta  its because we are running regular expressions within R object. So the first \\ is used to escape special characters in R, applying it to the second \\, which is itself the special character that needs to be escaped to pass through the function. The second slash is followed by the escaped character. Some examples are provided below. If that isnt clear. Just remember that you need two backslashes instead of one. 5.3.3 \\\\w Instead of finding the letter w, the \\\\w is a wildcard character that represents any letter or digits. gsub(&quot;w&quot;,&quot;X&quot;,&quot;...which 1-100 words get replaced?&quot;) ## [1] &quot;...Xhich 1-100 Xords get replaced?&quot; gsub(&quot;\\\\w&quot;,&quot;X&quot;,&quot;...which 1-100 words get replaced?&quot;) ## [1] &quot;...XXXXX X-XXX XXXXX XXX XXXXXXXX?&quot; 5.3.4 \\\\W This is the inverse of \\\\w find a character that is NOT a letter or number. gsub(&quot;\\\\W&quot;,&quot;X&quot;,&quot;...which 1-100 words get replaced?&quot;) ## [1] &quot;XXXwhichX1X100XXwordsXgetXreplacedX&quot; 5.3.5 \\\\s This represents a space gsub(&quot;\\\\s&quot;,&quot;X&quot;,&quot;...which 1-100 words get replaced?&quot;) ## [1] &quot;...whichX1-100XXwordsXgetXreplaced?&quot; 5.3.6 \\\\t This is a tab character. A lot of data files stored as text are tab-delimited (.tsv) as well as comma-delimited (.csv) gsub(&quot;\\\\t&quot;,&quot;X&quot;,&quot;...which 1-100 words get replaced?&quot;) ## [1] &quot;...which 1-100 words get replaced?&quot; 5.3.7 \\\\d Digit characters gsub(&quot;\\\\d&quot;,&quot;X&quot;,&quot;...which 1-100 words get replaced?&quot;) ## [1] &quot;...which X-XXX words get replaced?&quot; 5.3.8 \\\\D Non-digit characters gsub(&quot;\\\\D&quot;,&quot;X&quot;,&quot;...which 1-100 words get replaced?&quot;) ## [1] &quot;XXXXXXXXX1X100XXXXXXXXXXXXXXXXXXXXX&quot; 5.4 New Lines There are two special characters that indicate new lines in a text file. 5.4.1 \\\\r This is the carriage return special character 5.4.2 \\\\n This is the newline special character 5.4.3 Big Problem One or two of these is/are generated when you press the enter key while writing a text file. These also add a source of headache and confusion when working with text files because: Macs/Unix and PC/Windows use different standards! Unix/Mac files  lines usually end with \\\\n only Windows/DOS files  lines usually end with \\\\r\\\\n This can cause problems when moving text files between Windows/DOS and Mac/Unix machines, particularly with older operating systems or when working on remote computers that use very basic Linux software. 5.5 Special characters In addition to special characters that use the escape \\\\, there are a number of other special characters that dont use the escape, but have a special meaning. Note that if you want to search for the characters below you would have to use the escape character. E.g. \\\\. if you wanted to search for a period .. 5.5.1 | This is sometimes called the pipe character, and it simply means or. For example, we can search for w or e. gsub(&quot;w|e&quot;,&quot;X&quot;,&quot;...which 1-100 words get replaced?&quot;) ## [1] &quot;...Xhich 1-100 Xords gXt rXplacXd?&quot; 5.5.2 . This means any character except new line. This includes all of the \\\\w characters but also other characters like puncutation marks. gsub(&quot;.&quot;,&quot;X&quot;,&quot;...which 1-100 words get replaced?&quot;) ## [1] &quot;XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX&quot; So how to search for a period .? As noted above, we have to use the escape character gsub(&quot;\\\\.&quot;,&quot;X&quot;,&quot;...which 1-100 words get replaced?&quot;) ## [1] &quot;XXXwhich 1-100 words get replaced?&quot; 5.5.3 *, ?, +, {} These special characters refer to details about the kind of search that we are trying to conduct. Look at these examples carefully, and remember that sub replaces the first match while gsub replaces all of the matches. sub(&quot;\\\\w&quot;,&quot;X&quot;,&quot;...which 1-100 words get replaced?&quot;) ## [1] &quot;...Xhich 1-100 words get replaced?&quot; gsub(&quot;\\\\w&quot;,&quot;X&quot;,&quot;...which 1-100 words get replaced?&quot;) ## [1] &quot;...XXXXX X-XXX XXXXX XXX XXXXXXXX?&quot; Now lets apply some of these special characters to see how they work. 5.5.3.1 + Finds 1 or more matches sub(&quot;\\\\w+&quot;,&quot;X&quot;,&quot;...which 1-100 words get replaced?&quot;) ## [1] &quot;...X 1-100 words get replaced?&quot; gsub(&quot;\\\\w+&quot;,&quot;X&quot;,&quot;...which 1-100 words get replaced?&quot;) ## [1] &quot;...X X-X X X X?&quot; Compare this match to the one above. Notice how we have replaced groups of letters instead of single letters. The algorithm works like this: Start at the left and move to the right, one character at a time Check if the character is a letter or number (\\\\w). If NO, move to the next character If YES, check the next character. If it is also a \\\\w then go to the next character. Repeat until the next character is not \\\\w, and replace the entire string of characters. When run in the sub command, it does the above and then stops. When run with the gsub command, it continues to the next character, and then starts over. 5.5.4 * This is a greedy search (match the largest possible) sub(&quot;\\\\w*&quot;,&quot;X&quot;,&quot;...which 1-100 words get replaced?&quot;) ## [1] &quot;X...which 1-100 words get replaced?&quot; gsub(&quot;\\\\w*&quot;,&quot;X&quot;,&quot;...which 1-100 words get replaced?&quot;) ## [1] &quot;X.X.X.X X-X X X X?X&quot; In the sub command, it detects a . as the first character, indicating no match. It replaces the null or 0 match at the beginning, which has the effect of adding a character. In the gsub command it repeats this before each . until it finds the letter w. Then it finds a group of \\\\w matches, replacing with a single star. Then a space, which is skipped, then a -, which is another null match, prompting another insert. 5.5.5 ? This means match zero or one time sub(&quot;\\\\w?&quot;,&quot;X&quot;,&quot;...which 1-100 words get replaced?&quot;) ## [1] &quot;X...which 1-100 words get replaced?&quot; gsub(&quot;\\\\w?&quot;,&quot;X&quot;,&quot;...which 1-100 words get replaced?&quot;) ## [1] &quot;X.X.X.XXXXX X-XXX XXXXX XXX XXXXXXXX?X&quot; Compare this to the * above. It behaves in a similar way, except it is not greedy  in the second example, each letter is replaced instead of entire words. 5.5.6 +? This is the lazy version of +  note in particular the difference in sub which replaces on the the first letter here but the whole word when + is used alone. In the gsub example we end up replacing every letter instead of whole words. Remember, sub runs the algorithm once and then stops, while gsub repeats until it reaches the end of the line. sub(&quot;\\\\w+?&quot;,&quot;X&quot;,&quot;...which 1-100 words get replaced?&quot;) ## [1] &quot;...Xhich 1-100 words get replaced?&quot; gsub(&quot;\\\\w+?&quot;,&quot;X&quot;,&quot;...which 1-100 words get replaced?&quot;) ## [1] &quot;...XXXXX X-XXX XXXXX XXX XXXXXXXX?&quot; 5.5.7 *? Similarly, we can combine these characters for the lazy version of * sub(&quot;\\\\w*?&quot;,&quot;X&quot;,&quot;...which 1-100 words get replaced?&quot;) ## [1] &quot;X...which 1-100 words get replaced?&quot; gsub(&quot;\\\\w*?&quot;,&quot;X&quot;,&quot;...which 1-100 words get replaced?&quot;) ## [1] &quot;X.X.X.XwXhXiXcXhX X1X-X1X0X0X XwXoXrXdXsX XgXeXtX XrXeXpXlXaXcXeXdX?X&quot; Try using +*. Why do you get an error message? 5.5.8 {} Curly brackets are used to specify a number of matches, expanding on the options even futher. 5.5.9 {n,m} Find between \\(n\\) to \\(m\\) matches gsub(&quot;\\\\w{3,4}&quot;,&quot;X&quot;,&quot;...which 1-100 words get replaced?&quot;) ## [1] &quot;...Xh 1-X Xs X XX?&quot; 5.5.10 {n} Find exactly \\(n\\) matches gsub(&quot;\\\\w{3}&quot;,&quot;X&quot;,&quot;...which 1-100 words get replaced?&quot;) ## [1] &quot;...Xch 1-X Xds X XXed?&quot; 5.5.11 {n,} Fomd \\(n\\) or more matches gsub(&quot;\\\\w{4,}&quot;,&quot;X&quot;,&quot;...which 1-100 words get replaced?&quot;) ## [1] &quot;...X 1-100 X get X?&quot; 5.5.12 {}? As above, we cau use ? for the lazy versions of these searches gsub(&quot;\\\\w{4,}?&quot;,&quot;X&quot;,&quot;...which 1-100 words get replaced?&quot;) ## [1] &quot;...Xh 1-100 Xs get XX?&quot; 5.6 [] Square brackets allow us to find any of the values listed within them. We can also use the dash - to specify a range of numbers or letters. gsub(&quot;[aceihw-z]&quot;,&quot;X&quot;,&quot;...which 1-100 words get replaced?&quot;) ## [1] &quot;...XXXXX 1-100 Xords gXt rXplXXXd?&quot; In the above example, we search for 1 of any of the listed letters: a, c, e, i h, w, x, y, z. Note that x and y are included in the x-z statement. What if we want to find 1 or more of these characters in a row? gsub(&quot;[aceihw-z]+&quot;,&quot;X&quot;,&quot;...which 1-100 words get replaced?&quot;) ## [1] &quot;...X 1-100 Xords gXt rXplXd?&quot; 5.7 ^ and $ Use these characters to specify searches at the start ^ or end $ of the input string. 5.7.1 ^ Find species starting with the letter s grep(&quot;^s&quot;,Species) ## [1] 3 IMPORTANT: ^ Also means negate when used within [] Find species containing any letter other than s grep(&quot;[^a]&quot;,Species) ## [1] 1 2 3 4 Replace every letter except s gsub(&quot;[^a]&quot;,&quot;X&quot;,Species) ## [1] &quot;XXXXXXaXa&quot; &quot;XXXXXXXXXaXXX&quot; &quot;XaXXXaXXa&quot; &quot;XXXXX&quot; 5.7.2 $ Find species ending with a grep(&quot;a$&quot;,Species) ## [1] 1 3 5.8 () Regular parentheses are used to capture text, which can then be specified in the replacement string using \\\\1. Or you can capture multiple pieces of text and reorganize them by using the corresponding number  \\\\1 for the first set of(), \\\\2 for the second set of (), etc. Some examples should help. Replace each word with its first letter gsub(&quot;(\\\\w)\\\\w+&quot;,&quot;\\\\1&quot;,&quot;...which 1-100 words get replaced?&quot;) ## [1] &quot;...w 1-1 w g r?&quot; Pull out only the numbers and reverse their order gsub(&quot;.*([0-9]+)-([0-9]+).*&quot;,&quot;\\\\2-\\\\1&quot;,&quot;...which 1-100 words get replaced?&quot;) ## [1] &quot;100-1&quot; Reverse first two letters of each word gsub(&quot;(\\\\w)(\\\\w)(\\\\w+)&quot;,&quot;\\\\2\\\\1\\\\3&quot;,&quot;...which 1-100 words get replaced?&quot;) ## [1] &quot;...hwich 1-010 owrds egt erplaced?&quot; 5.9 Scraping Scraping is a method for collecting data from online sources. In R, we can use the functions readLines and curl(), both from the curl library, to scrape data from websites. Websites with the .html extension are a special kind of text file. We can use regular expressions to pull out text from the website. Heres an example where we will scrape a record for the Green Fluorescent Protein (GFP) from the Protein Data Bank (PDB). Note that this is a file with the extension .pdb but this is a human-readable text file that can be opened in any text editor First, well import the text into an R object. library(curl) ## Using libcurl 7.64.1 with Schannel You will have to use install.packages(\"curl\") to download this package to your computer. You only need to do this once but you will have to use library(curl) whenever you want to use the commands, as explained in the R Fundamentals Tutorial Now we can download a file to play with. Prot&lt;-readLines(curl(&quot;http://www.rcsb.org/pdb/files/1ema.pdb&quot;)) HINT: Download this link to your computer and open with a text file. This hint is a simple trick to understand what kind of file(s) you are working with. This is a tab-delimited file, which we could import as a data frame using read.delim but well keep it this way to see how we can use regular expressions. The Prot object we have made is a simple vector of strings, with each cell corresponding to a different row of text: length(Prot) ## [1] 2363 Prot[grep(&quot;TITLE&quot;,Prot)] ## [1] &quot;TITLE GREEN FLUORESCENT PROTEIN FROM AEQUOREA VICTORIA &quot; We can pull out the amino acid sequences, which are rows that start with the word ATOM AAseq&lt;-Prot[grep(&quot;^ATOM&quot;,Prot)] length(AAseq) ## [1] 1717 AAseq[1] ## [1] &quot;ATOM 1 N SER A 2 28.888 9.409 52.301 1.00 85.05 N &quot; Try to isolate the 3-letter amino acid code There are lots of possibilities. Take the time to try a few. Heres one good option, since we know its a tab-delimited file with the amino acid in the 4th column: gsub(&quot;ATOM\\\\t\\\\w+\\\\t\\\\w+\\\\t(\\\\w+).*&quot;,&quot;\\\\1&quot;,AAseq[1]) ## [1] &quot;ATOM 1 N SER A 2 28.888 9.409 52.301 1.00 85.05 N &quot; That didnt work. Sometimes the tabs are actually just multiple spaces AAchain&lt;-gsub(&quot;ATOM\\\\s+\\\\w+\\\\s+\\\\w+\\\\s+(\\\\w+).*&quot;,&quot;\\\\1&quot;,AAseq) AAchain[1:100] ## [1] &quot;SER&quot; &quot;SER&quot; &quot;SER&quot; &quot;SER&quot; &quot;SER&quot; &quot;SER&quot; &quot;LYS&quot; &quot;LYS&quot; &quot;LYS&quot; &quot;LYS&quot; &quot;LYS&quot; &quot;LYS&quot; ## [13] &quot;LYS&quot; &quot;LYS&quot; &quot;LYS&quot; &quot;GLY&quot; &quot;GLY&quot; &quot;GLY&quot; &quot;GLY&quot; &quot;GLU&quot; &quot;GLU&quot; &quot;GLU&quot; &quot;GLU&quot; &quot;GLU&quot; ## [25] &quot;GLU&quot; &quot;GLU&quot; &quot;GLU&quot; &quot;GLU&quot; &quot;GLU&quot; &quot;GLU&quot; &quot;GLU&quot; &quot;GLU&quot; &quot;GLU&quot; &quot;GLU&quot; &quot;LEU&quot; &quot;LEU&quot; ## [37] &quot;LEU&quot; &quot;LEU&quot; &quot;LEU&quot; &quot;LEU&quot; &quot;LEU&quot; &quot;LEU&quot; &quot;PHE&quot; &quot;PHE&quot; &quot;PHE&quot; &quot;PHE&quot; &quot;PHE&quot; &quot;PHE&quot; ## [49] &quot;PHE&quot; &quot;PHE&quot; &quot;PHE&quot; &quot;PHE&quot; &quot;PHE&quot; &quot;THR&quot; &quot;THR&quot; &quot;THR&quot; &quot;THR&quot; &quot;THR&quot; &quot;THR&quot; &quot;THR&quot; ## [61] &quot;GLY&quot; &quot;GLY&quot; &quot;GLY&quot; &quot;GLY&quot; &quot;VAL&quot; &quot;VAL&quot; &quot;VAL&quot; &quot;VAL&quot; &quot;VAL&quot; &quot;VAL&quot; &quot;VAL&quot; &quot;VAL&quot; ## [73] &quot;VAL&quot; &quot;VAL&quot; &quot;VAL&quot; &quot;VAL&quot; &quot;VAL&quot; &quot;VAL&quot; &quot;PRO&quot; &quot;PRO&quot; &quot;PRO&quot; &quot;PRO&quot; &quot;PRO&quot; &quot;PRO&quot; ## [85] &quot;PRO&quot; &quot;ILE&quot; &quot;ILE&quot; &quot;ILE&quot; &quot;ILE&quot; &quot;ILE&quot; &quot;ILE&quot; &quot;ILE&quot; &quot;ILE&quot; &quot;LEU&quot; &quot;LEU&quot; &quot;LEU&quot; ## [97] &quot;LEU&quot; &quot;LEU&quot; &quot;LEU&quot; &quot;LEU&quot; 5.10 Examples Lets try practicing with a couple of examples 5.10.1 Transect Data Regular expressions are also useful with data objects Imagine you have a repeated measures design. 3 transects (A-C) and 3 positions along each transect (1-3) Transect&lt;-data.frame(Species=letters[1:20],A1=rnorm(20),A2=rnorm(20),A3=rnorm(20),B1=rnorm(20),B2=rnorm(20),B3=rnorm(20),C1=rnorm(20),C2=rnorm(20),C3=rnorm(20)) head(Transect) ## Species A1 A2 A3 B1 B2 B3 ## 1 a 0.07139707 -0.7728001 0.81305648 -0.6098756 0.3799136 0.8451857 ## 2 b -0.85109159 -0.5640395 -0.88588115 -0.7857094 1.5084828 0.5826571 ## 3 c 1.08841353 1.3048859 0.05254901 -0.6883161 -1.0110300 -0.3930457 ## 4 d -0.62425975 -0.4979739 -0.80039790 2.0192492 0.7369518 0.7150064 ## 5 e -2.10014932 -1.1267024 -0.14952315 1.9066553 -0.7954435 1.5053513 ## 6 f -1.96116164 -0.9376691 -1.00747944 -0.5799077 -3.2586303 0.4925379 ## C1 C2 C3 ## 1 -2.6729185 -2.1552864 -2.0309665 ## 2 -0.6006691 -0.7511939 -0.1027611 ## 3 1.5251702 1.6607134 -0.9350379 ## 4 0.1715294 3.4725070 0.2424075 ## 5 -0.1584703 -1.6796146 -1.2852899 ## 6 0.9523366 0.5827346 0.1407577 TIP: the object letters contains lower-case letter, while LETTERS contains upper case. 5.10.1.1 Challenge Use your knowledged gained above with substting data outlined in the R Fundamentals Tutorial to do the following: Subset only the columns that have an A in their name Subset the data for species D Take the time to do this on your own. It will take you a while and you will make a lot of mistakes. Thats all part of the learning process. The longer you struglle, the faster you will learn. Now here is a more challenging example: 5.10.2 Genbank Lythrum_18S&lt;-scan(&quot;https://colauttilab.github.io/RCrashCourse/sequence.gb&quot;,what=&quot;character&quot;,sep=&quot;\\n&quot;) This is the sequence of the 18S subunit from the ribosome gene of Lythrum salicaria (from Genbank) print(Lythrum_18S) ## [1] &quot;LOCUS AF206955 1740 bp DNA linear PLN 18-APR-2003&quot; ## [2] &quot;DEFINITION Lythrum salicaria 18S ribosomal RNA gene, complete sequence.&quot; ## [3] &quot;ACCESSION AF206955&quot; ## [4] &quot;VERSION AF206955.1&quot; ## [5] &quot;KEYWORDS .&quot; ## [6] &quot;SOURCE Lythrum salicaria&quot; ## [7] &quot; ORGANISM Lythrum salicaria&quot; ## [8] &quot; Eukaryota; Viridiplantae; Streptophyta; Embryophyta; Tracheophyta;&quot; ## [9] &quot; Spermatophyta; Magnoliopsida; eudicotyledons; Gunneridae;&quot; ## [10] &quot; Pentapetalae; rosids; malvids; Myrtales; Lythraceae; Lythrum.&quot; ## [11] &quot;REFERENCE 1 (bases 1 to 1740)&quot; ## [12] &quot; AUTHORS Soltis,P.S., Soltis,D.E. and Chase,M.W.&quot; ## [13] &quot; TITLE Direct Submission&quot; ## [14] &quot; JOURNAL Submitted (19-NOV-1999) School of Biological Sciences, Washington&quot; ## [15] &quot; State University, Pullman, WA 99164-4236, USA&quot; ## [16] &quot;FEATURES Location/Qualifiers&quot; ## [17] &quot; source 1..1740&quot; ## [18] &quot; /organism=\\&quot;Lythrum salicaria\\&quot;&quot; ## [19] &quot; /mol_type=\\&quot;genomic DNA\\&quot;&quot; ## [20] &quot; /db_xref=\\&quot;taxon:13129\\&quot;&quot; ## [21] &quot; /note=\\&quot;Lythrum salicaria L.\\&quot;&quot; ## [22] &quot; rRNA 1..1740&quot; ## [23] &quot; /product=\\&quot;18S ribosomal RNA\\&quot;&quot; ## [24] &quot;ORIGIN &quot; ## [25] &quot; 1 gtcatatgct tgtctcaaag attaagccat gcatgtgtaa gtatgaacaa attcagactg&quot; ## [26] &quot; 61 tgaaactgcg aatggctcat taaatcagtt atagtttgtt tgatggtatc tgctactcgg&quot; ## [27] &quot; 121 ataaccgtag taattctaga gctaatacgt gcaacaaacc ccgacttctg gaagggacgc&quot; ## [28] &quot; 181 atttattaga taaaaggtcg acgcgggctt tgcccgatgc tctgatgatt catgataact&quot; ## [29] &quot; 241 tgacggatcg cacggccatc gtgccggcga cgcatcattc aaatttctgc cctatcaact&quot; ## [30] &quot; 301 ttcgatggta ggatagtggc ctaccatggt gtttacgggt aacggagaat tagggttcga&quot; ## [31] &quot; 361 ttccggagag ggagcctgag aaacggctac cacatccaag gaaggcagca ggcgcgcaaa&quot; ## [32] &quot; 421 ttacccaatc ctgacacggg gaggtagtga caataaataa caatactggg ctctttgagt&quot; ## [33] &quot; 481 ctggtaattg gaatgagtac aatctaaatc ccttaacgag gatccattgg agggcaagtc&quot; ## [34] &quot; 541 tggtgccagc agccgcggta attccagctc caatagcgta tatttaagtt gttgcagtta&quot; ## [35] &quot; 601 aaaagctcgt agttggacct tgggttgggt cgaccggtcc gcctttggtg tgcaccgatc&quot; ## [36] &quot; 661 ggctcgtccc ttctaccggc gatgcgcgcc tggccttaat tggccgggtc gttcctccgg&quot; ## [37] &quot; 721 tgctgttact ttgaagaaat tagagtgctc aaagcaagca ttagctatga atacattagc&quot; ## [38] &quot; 781 atgggataac attataggat tccgatccta ttatgttggc cttcgggatc ggagtaatga&quot; ## [39] &quot; 841 ttaacaggga cagtcggggg cattcgtatt tcatagtcag aggtgaaatt cttggattta&quot; ## [40] &quot; 901 tgaaagacga acaactgcga aagcatttgc caaggatgtt ttcattaatc aagaacgaaa&quot; ## [41] &quot; 961 gttgggggct cgaagacgat cagataccgt cctagtctca accataaacg atgccgacca&quot; ## [42] &quot; 1021 gggatcagcg aatgttactt ttaggacttc gctggcacct tatgagaaat caaagttttt&quot; ## [43] &quot; 1081 gggttccggg gggagtatgg tcgcaaggct gaaacttaaa ggaattgacg gaagggcacc&quot; ## [44] &quot; 1141 accaggagtg gagcctgcgg cttaatttga ctcaacacgg ggaaacttac caggtccaga&quot; ## [45] &quot; 1201 catagtaagg attgacagac tgagagctct ttcttgattc tatgggtggt ggtgcatggc&quot; ## [46] &quot; 1261 cgttcttagt tggtggagcg atttgtctgg ttaattccgt taacgaacga gacctcagcc&quot; ## [47] &quot; 1321 tgctaactag ctatgtggag gtacacctcc acggccagct tcttagaggg actatggccg&quot; ## [48] &quot; 1381 cttaggccaa ggaagtttga ggcaataaca ggtctgtgat gcccttagat gttctgggcc&quot; ## [49] &quot; 1441 gcacgcgcgc tacactgatg tattcaacga gtctatagcc ttggccgaca ggcccgggta&quot; ## [50] &quot; 1501 atctttgaaa tttcatcgtg atggggatag atcattgcaa ttgttggtct tcaacgagga&quot; ## [51] &quot; 1561 attcctagta agcgcgagtc atcagctcgc gttgactacg tccctgccct ttgtacacac&quot; ## [52] &quot; 1621 cgcccgtcgc tcctaccgat tgaatggtcc ggtgaaatgt tcggatcgcg gcgacgtggg&quot; ## [53] &quot; 1681 cgcttcgtcg ccgacgacgt cgcgagaagt ccattgaacc ttatcattta gaggaaggag&quot; ## [54] &quot;//&quot; Notice that each line is read in as a separate cell in a vector, with sequences beginning with a number ending with 1. We can take advantage of this to extract just the sequence data 5.10.2.1 Challenge Before proceeding try to do the following: Isolate only the rows containing DNA sequences. This should include a. Removing all of the characters that are not a, t, g, or c. b. Combining separate cells/lines into a single string. You can do this with using the `paste()` function with the `collapse=&quot;&quot;` parameter Convert lower-case to upper-case. To do this, you can use gsub(\"([actg])\",\"\\\\U\\\\1\",Seq,perl=T). The \\\\U\\\\\\1 means paste brackets as upper-case, and is only available as a Perl command, which is accessible in gsub with the perl=T parameter. Replace start codons (ATG) with &gt;START&gt;ATG Replace stop codons (TAA or TAG or TGA) with TAA or TAG or TGA followed by &gt;STOP| Take the time to stuggle with this and try different combinations until you find a way through. The more you struggle, the faster you will learn. A cool thing about regular expressions is that there is rarely a single right answer, especially for complicated problems. When you are ready, Continue on to see one possible solution. 5.11 Solutions 5.11.1 Transects Imagine you have a repeated measures design. 3 transects (A-C) and 3 positions along each transect (1-3) Transect&lt;-data.frame(Species=1:20,A1=rnorm(20),A2=rnorm(20),A3=rnorm(20),B1=rnorm(20),B2=rnorm(20),B3=rnorm(20),C1=rnorm(20),C2=rnorm(20),C3=rnorm(20)) head(Transect) ## Species A1 A2 A3 B1 B2 B3 ## 1 1 -0.3551728 1.5574030 0.92831524 1.2809810 -0.1825205 -1.81648927 ## 2 2 -0.5005998 1.8180958 -2.69323529 0.9405535 -0.3922514 0.06811127 ## 3 3 -0.4393575 -0.4473246 0.02226106 0.6968660 -0.4779725 -0.11903021 ## 4 4 1.9956463 0.8015969 0.06578602 1.7468116 0.7371601 0.14762524 ## 5 5 1.2568587 1.2727379 -0.10217342 0.6973361 2.4661032 0.88846771 ## 6 6 2.2362467 -0.4398664 -1.08099609 0.6642294 -0.2111424 -0.25869663 ## C1 C2 C3 ## 1 0.3888588 -0.53862615 1.63044736 ## 2 -0.7136629 -0.27674505 0.23562220 ## 3 1.1601536 -0.64381623 1.20883465 ## 4 1.8521279 0.17199073 0.61716530 ## 5 0.3304053 -0.05247375 0.15312470 ## 6 1.2250694 -1.26948339 0.07721129 You want to look at only transect A for the first 3 species Transect[1:3,grep(&quot;A&quot;,names(Transect))] ## A1 A2 A3 ## 1 -0.3551728 1.5574030 0.92831524 ## 2 -0.5005998 1.8180958 -2.69323529 ## 3 -0.4393575 -0.4473246 0.02226106 Subset the data for species D Transect[grep(&quot;1&quot;,names(Transect)),] ## Species A1 A2 A3 B1 B2 B3 ## 2 2 -0.5005998 1.8180958 -2.6932353 0.9405535 -0.3922514 0.06811127 ## 5 5 1.2568587 1.2727379 -0.1021734 0.6973361 2.4661032 0.88846771 ## 8 8 -0.5934295 -0.3563004 0.6264754 -0.3666217 0.2624573 1.59699670 ## C1 C2 C3 ## 2 -0.7136629 -0.27674505 0.2356222 ## 5 0.3304053 -0.05247375 0.1531247 ## 8 0.8995420 -1.49135884 -1.3148355 5.11.2 Genbank Use .* with () to delete everything before the DNA sequence Seq&lt;-gsub(&quot;.*(1 [gatc])&quot;,&quot;&quot;,Lythrum_18S) paste(Seq,collapse=&quot;&quot;) ## [1] &quot;LOCUS AF206955 1740 bp DNA linear PLN 18-APR-2003DEFINITION Lythrum salicaria 18S ribosomal RNA gene, complete sequence.ACCESSION AF206955VERSION AF206955.1KEYWORDS .SOURCE Lythrum salicaria ORGANISM Lythrum salicaria Eukaryota; Viridiplantae; Streptophyta; Embryophyta; Tracheophyta; Spermatophyta; Magnoliopsida; eudicotyledons; Gunneridae; Pentapetalae; rosids; malvids; Myrtales; Lythraceae; Lythrum.o 1740) AUTHORS Soltis,P.S., Soltis,D.E. and Chase,M.W. TITLE Direct Submission JOURNAL Submitted (19-NOV-1999) School of Biological Sciences, Washington State University, Pullman, WA 99164-4236, USAFEATURES Location/Qualifiers source 1..1740 /organism=\\&quot;Lythrum salicaria\\&quot; /mol_type=\\&quot;genomic DNA\\&quot; /db_xref=\\&quot;taxon:13129\\&quot; /note=\\&quot;Lythrum salicaria L.\\&quot; rRNA 1..1740 /product=\\&quot;18S ribosomal RNA\\&quot;ORIGIN tcatatgct tgtctcaaag attaagccat gcatgtgtaa gtatgaacaa attcagactggaaactgcg aatggctcat taaatcagtt atagtttgtt tgatggtatc tgctactcggtaaccgtag taattctaga gctaatacgt gcaacaaacc ccgacttctg gaagggacgctttattaga taaaaggtcg acgcgggctt tgcccgatgc tctgatgatt catgataactgacggatcg cacggccatc gtgccggcga cgcatcattc aaatttctgc cctatcaacttcgatggta ggatagtggc ctaccatggt gtttacgggt aacggagaat tagggttcgatccggagag ggagcctgag aaacggctac cacatccaag gaaggcagca ggcgcgcaaatacccaatc ctgacacggg gaggtagtga caataaataa caatactggg ctctttgagttggtaattg gaatgagtac aatctaaatc ccttaacgag gatccattgg agggcaagtcggtgccagc agccgcggta attccagctc caatagcgta tatttaagtt gttgcagttaaaagctcgt agttggacct tgggttgggt cgaccggtcc gcctttggtg tgcaccgatcgctcgtccc ttctaccggc gatgcgcgcc tggccttaat tggccgggtc gttcctccgggctgttact ttgaagaaat tagagtgctc aaagcaagca ttagctatga atacattagctgggataac attataggat tccgatccta ttatgttggc cttcgggatc ggagtaatgataacaggga cagtcggggg cattcgtatt tcatagtcag aggtgaaatt cttggatttagaaagacga acaactgcga aagcatttgc caaggatgtt ttcattaatc aagaacgaaattgggggct cgaagacgat cagataccgt cctagtctca accataaacg atgccgaccaggatcagcg aatgttactt ttaggacttc gctggcacct tatgagaaat caaagtttttggttccggg gggagtatgg tcgcaaggct gaaacttaaa ggaattgacg gaagggcaccccaggagtg gagcctgcgg cttaatttga ctcaacacgg ggaaacttac caggtccagaatagtaagg attgacagac tgagagctct ttcttgattc tatgggtggt ggtgcatggcgttcttagt tggtggagcg atttgtctgg ttaattccgt taacgaacga gacctcagccgctaactag ctatgtggag gtacacctcc acggccagct tcttagaggg actatggccgttaggccaa ggaagtttga ggcaataaca ggtctgtgat gcccttagat gttctgggcccacgcgcgc tacactgatg tattcaacga gtctatagcc ttggccgaca ggcccgggtatctttgaaa tttcatcgtg atggggatag atcattgcaa ttgttggtct tcaacgaggattcctagta agcgcgagtc atcagctcgc gttgactacg tccctgccct ttgtacacacgcccgtcgc tcctaccgat tgaatggtcc ggtgaaatgt tcggatcgcg gcgacgtggggcttcgtcg ccgacgacgt cgcgagaagt ccattgaacc ttatcattta gaggaaggag//&quot; Use the .* and space with + to eliminate all text before the sequence : Seq&lt;-gsub(&quot;.*ORIGIN +&quot;,&quot;&quot;,paste(Seq,collapse=&quot;&quot;)) Seq ## [1] &quot;tcatatgct tgtctcaaag attaagccat gcatgtgtaa gtatgaacaa attcagactggaaactgcg aatggctcat taaatcagtt atagtttgtt tgatggtatc tgctactcggtaaccgtag taattctaga gctaatacgt gcaacaaacc ccgacttctg gaagggacgctttattaga taaaaggtcg acgcgggctt tgcccgatgc tctgatgatt catgataactgacggatcg cacggccatc gtgccggcga cgcatcattc aaatttctgc cctatcaacttcgatggta ggatagtggc ctaccatggt gtttacgggt aacggagaat tagggttcgatccggagag ggagcctgag aaacggctac cacatccaag gaaggcagca ggcgcgcaaatacccaatc ctgacacggg gaggtagtga caataaataa caatactggg ctctttgagttggtaattg gaatgagtac aatctaaatc ccttaacgag gatccattgg agggcaagtcggtgccagc agccgcggta attccagctc caatagcgta tatttaagtt gttgcagttaaaagctcgt agttggacct tgggttgggt cgaccggtcc gcctttggtg tgcaccgatcgctcgtccc ttctaccggc gatgcgcgcc tggccttaat tggccgggtc gttcctccgggctgttact ttgaagaaat tagagtgctc aaagcaagca ttagctatga atacattagctgggataac attataggat tccgatccta ttatgttggc cttcgggatc ggagtaatgataacaggga cagtcggggg cattcgtatt tcatagtcag aggtgaaatt cttggatttagaaagacga acaactgcga aagcatttgc caaggatgtt ttcattaatc aagaacgaaattgggggct cgaagacgat cagataccgt cctagtctca accataaacg atgccgaccaggatcagcg aatgttactt ttaggacttc gctggcacct tatgagaaat caaagtttttggttccggg gggagtatgg tcgcaaggct gaaacttaaa ggaattgacg gaagggcaccccaggagtg gagcctgcgg cttaatttga ctcaacacgg ggaaacttac caggtccagaatagtaagg attgacagac tgagagctct ttcttgattc tatgggtggt ggtgcatggcgttcttagt tggtggagcg atttgtctgg ttaattccgt taacgaacga gacctcagccgctaactag ctatgtggag gtacacctcc acggccagct tcttagaggg actatggccgttaggccaa ggaagtttga ggcaataaca ggtctgtgat gcccttagat gttctgggcccacgcgcgc tacactgatg tattcaacga gtctatagcc ttggccgaca ggcccgggtatctttgaaa tttcatcgtg atggggatag atcattgcaa ttgttggtct tcaacgaggattcctagta agcgcgagtc atcagctcgc gttgactacg tccctgccct ttgtacacacgcccgtcgc tcctaccgat tgaatggtcc ggtgaaatgt tcggatcgcg gcgacgtggggcttcgtcg ccgacgacgt cgcgagaagt ccattgaacc ttatcattta gaggaaggag//&quot; Elimminate spaces and the two // at the end Seq&lt;-gsub(&quot; |//&quot;,&quot;&quot;,Seq) Seq ## [1] &quot;tcatatgcttgtctcaaagattaagccatgcatgtgtaagtatgaacaaattcagactggaaactgcgaatggctcattaaatcagttatagtttgtttgatggtatctgctactcggtaaccgtagtaattctagagctaatacgtgcaacaaaccccgacttctggaagggacgctttattagataaaaggtcgacgcgggctttgcccgatgctctgatgattcatgataactgacggatcgcacggccatcgtgccggcgacgcatcattcaaatttctgccctatcaacttcgatggtaggatagtggcctaccatggtgtttacgggtaacggagaattagggttcgatccggagagggagcctgagaaacggctaccacatccaaggaaggcagcaggcgcgcaaatacccaatcctgacacggggaggtagtgacaataaataacaatactgggctctttgagttggtaattggaatgagtacaatctaaatcccttaacgaggatccattggagggcaagtcggtgccagcagccgcggtaattccagctccaatagcgtatatttaagttgttgcagttaaaagctcgtagttggaccttgggttgggtcgaccggtccgcctttggtgtgcaccgatcgctcgtcccttctaccggcgatgcgcgcctggccttaattggccgggtcgttcctccgggctgttactttgaagaaattagagtgctcaaagcaagcattagctatgaatacattagctgggataacattataggattccgatcctattatgttggccttcgggatcggagtaatgataacagggacagtcgggggcattcgtatttcatagtcagaggtgaaattcttggatttagaaagacgaacaactgcgaaagcatttgccaaggatgttttcattaatcaagaacgaaattgggggctcgaagacgatcagataccgtcctagtctcaaccataaacgatgccgaccaggatcagcgaatgttacttttaggacttcgctggcaccttatgagaaatcaaagtttttggttccggggggagtatggtcgcaaggctgaaacttaaaggaattgacggaagggcaccccaggagtggagcctgcggcttaatttgactcaacacggggaaacttaccaggtccagaatagtaaggattgacagactgagagctctttcttgattctatgggtggtggtgcatggcgttcttagttggtggagcgatttgtctggttaattccgttaacgaacgagacctcagccgctaactagctatgtggaggtacacctccacggccagcttcttagagggactatggccgttaggccaaggaagtttgaggcaataacaggtctgtgatgcccttagatgttctgggcccacgcgcgctacactgatgtattcaacgagtctatagccttggccgacaggcccgggtatctttgaaatttcatcgtgatggggatagatcattgcaattgttggtcttcaacgaggattcctagtaagcgcgagtcatcagctcgcgttgactacgtccctgccctttgtacacacgcccgtcgctcctaccgattgaatggtccggtgaaatgttcggatcgcggcgacgtggggcttcgtcgccgacgacgtcgcgagaagtccattgaaccttatcatttagaggaaggag&quot; Capital letters look nicer, but requires a PERL qualifier \\\\U that is not standard in R Seq&lt;-gsub(&quot;([actg])&quot;,&quot;\\\\U\\\\1&quot;,Seq,perl=T) print(Seq) ## [1] &quot;TCATATGCTTGTCTCAAAGATTAAGCCATGCATGTGTAAGTATGAACAAATTCAGACTGGAAACTGCGAATGGCTCATTAAATCAGTTATAGTTTGTTTGATGGTATCTGCTACTCGGTAACCGTAGTAATTCTAGAGCTAATACGTGCAACAAACCCCGACTTCTGGAAGGGACGCTTTATTAGATAAAAGGTCGACGCGGGCTTTGCCCGATGCTCTGATGATTCATGATAACTGACGGATCGCACGGCCATCGTGCCGGCGACGCATCATTCAAATTTCTGCCCTATCAACTTCGATGGTAGGATAGTGGCCTACCATGGTGTTTACGGGTAACGGAGAATTAGGGTTCGATCCGGAGAGGGAGCCTGAGAAACGGCTACCACATCCAAGGAAGGCAGCAGGCGCGCAAATACCCAATCCTGACACGGGGAGGTAGTGACAATAAATAACAATACTGGGCTCTTTGAGTTGGTAATTGGAATGAGTACAATCTAAATCCCTTAACGAGGATCCATTGGAGGGCAAGTCGGTGCCAGCAGCCGCGGTAATTCCAGCTCCAATAGCGTATATTTAAGTTGTTGCAGTTAAAAGCTCGTAGTTGGACCTTGGGTTGGGTCGACCGGTCCGCCTTTGGTGTGCACCGATCGCTCGTCCCTTCTACCGGCGATGCGCGCCTGGCCTTAATTGGCCGGGTCGTTCCTCCGGGCTGTTACTTTGAAGAAATTAGAGTGCTCAAAGCAAGCATTAGCTATGAATACATTAGCTGGGATAACATTATAGGATTCCGATCCTATTATGTTGGCCTTCGGGATCGGAGTAATGATAACAGGGACAGTCGGGGGCATTCGTATTTCATAGTCAGAGGTGAAATTCTTGGATTTAGAAAGACGAACAACTGCGAAAGCATTTGCCAAGGATGTTTTCATTAATCAAGAACGAAATTGGGGGCTCGAAGACGATCAGATACCGTCCTAGTCTCAACCATAAACGATGCCGACCAGGATCAGCGAATGTTACTTTTAGGACTTCGCTGGCACCTTATGAGAAATCAAAGTTTTTGGTTCCGGGGGGAGTATGGTCGCAAGGCTGAAACTTAAAGGAATTGACGGAAGGGCACCCCAGGAGTGGAGCCTGCGGCTTAATTTGACTCAACACGGGGAAACTTACCAGGTCCAGAATAGTAAGGATTGACAGACTGAGAGCTCTTTCTTGATTCTATGGGTGGTGGTGCATGGCGTTCTTAGTTGGTGGAGCGATTTGTCTGGTTAATTCCGTTAACGAACGAGACCTCAGCCGCTAACTAGCTATGTGGAGGTACACCTCCACGGCCAGCTTCTTAGAGGGACTATGGCCGTTAGGCCAAGGAAGTTTGAGGCAATAACAGGTCTGTGATGCCCTTAGATGTTCTGGGCCCACGCGCGCTACACTGATGTATTCAACGAGTCTATAGCCTTGGCCGACAGGCCCGGGTATCTTTGAAATTTCATCGTGATGGGGATAGATCATTGCAATTGTTGGTCTTCAACGAGGATTCCTAGTAAGCGCGAGTCATCAGCTCGCGTTGACTACGTCCCTGCCCTTTGTACACACGCCCGTCGCTCCTACCGATTGAATGGTCCGGTGAAATGTTCGGATCGCGGCGACGTGGGGCTTCGTCGCCGACGACGTCGCGAGAAGTCCATTGAACCTTATCATTTAGAGGAAGGAG&quot; Look for start codons? gsub(&quot;ATG&quot;,&quot;--&gt;START--&gt;ATG&quot;,Seq) ## [1] &quot;TCAT--&gt;START--&gt;ATGCTTGTCTCAAAGATTAAGCC--&gt;START--&gt;ATGC--&gt;START--&gt;ATGTGTAAGT--&gt;START--&gt;ATGAACAAATTCAGACTGGAAACTGCGA--&gt;START--&gt;ATGGCTCATTAAATCAGTTATAGTTTGTTTG--&gt;START--&gt;ATGGTATCTGCTACTCGGTAACCGTAGTAATTCTAGAGCTAATACGTGCAACAAACCCCGACTTCTGGAAGGGACGCTTTATTAGATAAAAGGTCGACGCGGGCTTTGCCCG--&gt;START--&gt;ATGCTCTG--&gt;START--&gt;ATGATTC--&gt;START--&gt;ATGATAACTGACGGATCGCACGGCCATCGTGCCGGCGACGCATCATTCAAATTTCTGCCCTATCAACTTCG--&gt;START--&gt;ATGGTAGGATAGTGGCCTACC--&gt;START--&gt;ATGGTGTTTACGGGTAACGGAGAATTAGGGTTCGATCCGGAGAGGGAGCCTGAGAAACGGCTACCACATCCAAGGAAGGCAGCAGGCGCGCAAATACCCAATCCTGACACGGGGAGGTAGTGACAATAAATAACAATACTGGGCTCTTTGAGTTGGTAATTGGA--&gt;START--&gt;ATGAGTACAATCTAAATCCCTTAACGAGGATCCATTGGAGGGCAAGTCGGTGCCAGCAGCCGCGGTAATTCCAGCTCCAATAGCGTATATTTAAGTTGTTGCAGTTAAAAGCTCGTAGTTGGACCTTGGGTTGGGTCGACCGGTCCGCCTTTGGTGTGCACCGATCGCTCGTCCCTTCTACCGGCG--&gt;START--&gt;ATGCGCGCCTGGCCTTAATTGGCCGGGTCGTTCCTCCGGGCTGTTACTTTGAAGAAATTAGAGTGCTCAAAGCAAGCATTAGCT--&gt;START--&gt;ATGAATACATTAGCTGGGATAACATTATAGGATTCCGATCCTATT--&gt;START--&gt;ATGTTGGCCTTCGGGATCGGAGTA--&gt;START--&gt;ATGATAACAGGGACAGTCGGGGGCATTCGTATTTCATAGTCAGAGGTGAAATTCTTGGATTTAGAAAGACGAACAACTGCGAAAGCATTTGCCAAGG--&gt;START--&gt;ATGTTTTCATTAATCAAGAACGAAATTGGGGGCTCGAAGACGATCAGATACCGTCCTAGTCTCAACCATAAACG--&gt;START--&gt;ATGCCGACCAGGATCAGCGA--&gt;START--&gt;ATGTTACTTTTAGGACTTCGCTGGCACCTT--&gt;START--&gt;ATGAGAAATCAAAGTTTTTGGTTCCGGGGGGAGT--&gt;START--&gt;ATGGTCGCAAGGCTGAAACTTAAAGGAATTGACGGAAGGGCACCCCAGGAGTGGAGCCTGCGGCTTAATTTGACTCAACACGGGGAAACTTACCAGGTCCAGAATAGTAAGGATTGACAGACTGAGAGCTCTTTCTTGATTCT--&gt;START--&gt;ATGGGTGGTGGTGC--&gt;START--&gt;ATGGCGTTCTTAGTTGGTGGAGCGATTTGTCTGGTTAATTCCGTTAACGAACGAGACCTCAGCCGCTAACTAGCT--&gt;START--&gt;ATGTGGAGGTACACCTCCACGGCCAGCTTCTTAGAGGGACT--&gt;START--&gt;ATGGCCGTTAGGCCAAGGAAGTTTGAGGCAATAACAGGTCTGTG--&gt;START--&gt;ATGCCCTTAG--&gt;START--&gt;ATGTTCTGGGCCCACGCGCGCTACACTG--&gt;START--&gt;ATGTATTCAACGAGTCTATAGCCTTGGCCGACAGGCCCGGGTATCTTTGAAATTTCATCGTG--&gt;START--&gt;ATGGGGATAGATCATTGCAATTGTTGGTCTTCAACGAGGATTCCTAGTAAGCGCGAGTCATCAGCTCGCGTTGACTACGTCCCTGCCCTTTGTACACACGCCCGTCGCTCCTACCGATTGA--&gt;START--&gt;ATGGTCCGGTGAA--&gt;START--&gt;ATGTTCGGATCGCGGCGACGTGGGGCTTCGTCGCCGACGACGTCGCGAGAAGTCCATTGAACCTTATCATTTAGAGGAAGGAG&quot; Look for stop codons? gsub(&quot;(TAA|TAG|TGA)&quot;,&quot;\\\\1&gt;--STOP--|&quot;,Seq) ## [1] &quot;TCATATGCTTGTCTCAAAGATTAA&gt;--STOP--|GCCATGCATGTGTAA&gt;--STOP--|GTATGA&gt;--STOP--|ACAAATTCAGACTGGAAACTGCGAATGGCTCATTAA&gt;--STOP--|ATCAGTTATAG&gt;--STOP--|TTTGTTTGA&gt;--STOP--|TGGTATCTGCTACTCGGTAA&gt;--STOP--|CCGTAG&gt;--STOP--|TAA&gt;--STOP--|TTCTAG&gt;--STOP--|AGCTAA&gt;--STOP--|TACGTGCAACAAACCCCGACTTCTGGAAGGGACGCTTTATTAG&gt;--STOP--|ATAA&gt;--STOP--|AAGGTCGACGCGGGCTTTGCCCGATGCTCTGA&gt;--STOP--|TGA&gt;--STOP--|TTCATGA&gt;--STOP--|TAA&gt;--STOP--|CTGA&gt;--STOP--|CGGATCGCACGGCCATCGTGCCGGCGACGCATCATTCAAATTTCTGCCCTATCAACTTCGATGGTAG&gt;--STOP--|GATAG&gt;--STOP--|TGGCCTACCATGGTGTTTACGGGTAA&gt;--STOP--|CGGAGAATTAG&gt;--STOP--|GGTTCGATCCGGAGAGGGAGCCTGA&gt;--STOP--|GAAACGGCTACCACATCCAAGGAAGGCAGCAGGCGCGCAAATACCCAATCCTGA&gt;--STOP--|CACGGGGAGGTAG&gt;--STOP--|TGA&gt;--STOP--|CAATAA&gt;--STOP--|ATAA&gt;--STOP--|CAATACTGGGCTCTTTGA&gt;--STOP--|GTTGGTAA&gt;--STOP--|TTGGAATGA&gt;--STOP--|GTACAATCTAA&gt;--STOP--|ATCCCTTAA&gt;--STOP--|CGAGGATCCATTGGAGGGCAAGTCGGTGCCAGCAGCCGCGGTAA&gt;--STOP--|TTCCAGCTCCAATAG&gt;--STOP--|CGTATATTTAA&gt;--STOP--|GTTGTTGCAGTTAA&gt;--STOP--|AAGCTCGTAG&gt;--STOP--|TTGGACCTTGGGTTGGGTCGACCGGTCCGCCTTTGGTGTGCACCGATCGCTCGTCCCTTCTACCGGCGATGCGCGCCTGGCCTTAA&gt;--STOP--|TTGGCCGGGTCGTTCCTCCGGGCTGTTACTTTGA&gt;--STOP--|AGAAATTAG&gt;--STOP--|AGTGCTCAAAGCAAGCATTAG&gt;--STOP--|CTATGA&gt;--STOP--|ATACATTAG&gt;--STOP--|CTGGGATAA&gt;--STOP--|CATTATAG&gt;--STOP--|GATTCCGATCCTATTATGTTGGCCTTCGGGATCGGAGTAA&gt;--STOP--|TGA&gt;--STOP--|TAA&gt;--STOP--|CAGGGACAGTCGGGGGCATTCGTATTTCATAG&gt;--STOP--|TCAGAGGTGA&gt;--STOP--|AATTCTTGGATTTAG&gt;--STOP--|AAAGACGAACAACTGCGAAAGCATTTGCCAAGGATGTTTTCATTAA&gt;--STOP--|TCAAGAACGAAATTGGGGGCTCGAAGACGATCAGATACCGTCCTAG&gt;--STOP--|TCTCAACCATAA&gt;--STOP--|ACGATGCCGACCAGGATCAGCGAATGTTACTTTTAG&gt;--STOP--|GACTTCGCTGGCACCTTATGA&gt;--STOP--|GAAATCAAAGTTTTTGGTTCCGGGGGGAGTATGGTCGCAAGGCTGA&gt;--STOP--|AACTTAA&gt;--STOP--|AGGAATTGA&gt;--STOP--|CGGAAGGGCACCCCAGGAGTGGAGCCTGCGGCTTAA&gt;--STOP--|TTTGA&gt;--STOP--|CTCAACACGGGGAAACTTACCAGGTCCAGAATAG&gt;--STOP--|TAA&gt;--STOP--|GGATTGA&gt;--STOP--|CAGACTGA&gt;--STOP--|GAGCTCTTTCTTGA&gt;--STOP--|TTCTATGGGTGGTGGTGCATGGCGTTCTTAG&gt;--STOP--|TTGGTGGAGCGATTTGTCTGGTTAA&gt;--STOP--|TTCCGTTAA&gt;--STOP--|CGAACGAGACCTCAGCCGCTAA&gt;--STOP--|CTAG&gt;--STOP--|CTATGTGGAGGTACACCTCCACGGCCAGCTTCTTAG&gt;--STOP--|AGGGACTATGGCCGTTAG&gt;--STOP--|GCCAAGGAAGTTTGA&gt;--STOP--|GGCAATAA&gt;--STOP--|CAGGTCTGTGA&gt;--STOP--|TGCCCTTAG&gt;--STOP--|ATGTTCTGGGCCCACGCGCGCTACACTGA&gt;--STOP--|TGTATTCAACGAGTCTATAG&gt;--STOP--|CCTTGGCCGACAGGCCCGGGTATCTTTGA&gt;--STOP--|AATTTCATCGTGA&gt;--STOP--|TGGGGATAG&gt;--STOP--|ATCATTGCAATTGTTGGTCTTCAACGAGGATTCCTAG&gt;--STOP--|TAA&gt;--STOP--|GCGCGAGTCATCAGCTCGCGTTGA&gt;--STOP--|CTACGTCCCTGCCCTTTGTACACACGCCCGTCGCTCCTACCGATTGA&gt;--STOP--|ATGGTCCGGTGA&gt;--STOP--|AATGTTCGGATCGCGGCGACGTGGGGCTTCGTCGCCGACGACGTCGCGAGAAGTCCATTGA&gt;--STOP--|ACCTTATCATTTAG&gt;--STOP--|AGGAAGGAG&quot; 5.12 More Exercises Here are some more exercises to practice your skils. No solutions are given for these, you will have to solve them on your own. Note that they may find their way onto a test, assignment or quiz. 5.12.1 1. Consider a vector of email addresses scraped from the internet: robert dot colautti at queensu dot ca chris.eckert[at]queensu.ca lonnie.aarssen at queensu.ca Use regular expressions to convert all email addresses to the standard format: name@queensu.ca 5.12.2 2. Create a random sequence of DNA: My.Seq&lt;-sample(c(&quot;A&quot;,&quot;T&quot;,&quot;G&quot;,&quot;C&quot;),1000,replace=T) * Replace T with U * Find all start codons (AUG) and stop codons (UAA, UAG, UGA) * Find all open reading frames (hint: consider each sequence beginning with AUG and ending with a stop codon; how do you know if both sequences are in the same reading frame?) * Count the length of bp for all open reading frames 5.12.3 3. More online examples http://regex.sketchengine.co.uk/extra_regexps.html 5.12.4 4. Regex Golf Have fun! LINK "],["data-science-intro.html", "Chapter 6 Data Science Intro 6.1 Setup 6.2 Introduction to Data Science 6.3 2D Data Wrangling 6.4 Missing Data 6.5 Naughty Data", " Chapter 6 Data Science Intro 6.1 Setup If you dont have it installed, then run install.packages(\"dplyr\")  it can take a while to download and install. 6.2 Introduction to Data Science Data Science is a relatively new field of study that merges computer science and statistics to answer questions in other domains (e.g. business, medicine, biology, psychology). Data Science as a discipline has grown in popularity in response to the rapid rate of increase in data collection and publication. Data Science often involves Big Data, which doesnt have a strict quantitative definition but will usually have one or more of the following characteristics: High Volume  large file sizes with lots of observations. Wide Variety  lots of different types High Velocity  accumulating at a high rate Compromised Veracity  variable quality that must be dealt otherwise downstream analyses will be compromised. What are some examples of big data in Biology? Medical records, remote sensing data (e.g. climate stations, satellite images), and omics data are good examples of big data in biology. In biology, it can be helpful to think of Data Science as a continuous life-cycle with multiple stages: 6.2.1 Data Science Life-Cycle Hypothesize  Make initial observations of about the natural world, or insights from other data, that lead to testable hypotheses. Your core biology training is crucial here. Collect  This may involve taking measurements yourself, manually entering data that is not yet in electronic format, requesting data from authors of published studies, or importing data from online sources. Collecting data is a crucial step that is often done poorly. Some tips on this are provided in a paper by Wu et al Correct  Investigate the data for quality assurance, to identify and fix potential errors. Start to visualize the data to look for outliers or nonsensical relationships (or lack thereof). Explore  Try to understand the data, where they come from, and potential limitations on their use. Continue visualizing data; this may cause you to modify your hypotheses slightly. Model  Now that hypotheses are clearly defined, apply statistical tests of their validity. Report  Use visualizations along with the results of your statistical tests to summarize your findings. Repeat  Return to step 1. In this tutorial, we focus mainly on coding in R for steps 2, 3, and 6. Step 5 requires a firm understanding of statistics. Step 4 is covered in the tutorials on qplot and ggplot. Step 1 is everything covered in a typical degree in the biological sciences. Data collection and management are crucial steps in the Data Science Life-Cycle. Read the paper by Wu et al. called baRcodeR with PyTrackDat: Open-source labelling and tracking of biological samples for repeatable science. Pay particular attention to the Data Standards section. The baRcodeR and PyTrackDat programs and their application to current projects may also be of interest. 6.2.2 Data Science in R The book R for Data Science by Hadley Wickham &amp; Garrett Grolemund is an excellent resource using R in Data Science projects. TIP: In general, any book by Hadley Wickham that you come across is worth reading if you want to be proficient in R. Here well be focusing on the dplyr packages from Wickham et al. 6.3 2D Data Wrangling The dplyr library in R has many useful features for importing and reorganizing your data for steps 2, 3 and 4 in the Data Science Life-Cycle outlined above. Dont forget to install the dplyr library and load it into memory. library(dplyr) ## ## Attaching package: &#39;dplyr&#39; ## The following objects are masked from &#39;package:stats&#39;: ## ## filter, lag ## The following objects are masked from &#39;package:base&#39;: ## ## intersect, setdiff, setequal, union Note: This error message just informs you that dplyr uses function or parameter names that are the same as other base or stats packages in R. These base/stats functions are masked meaning that when you run one (e.g. filter) then R will run the dplyr version rather than the stats version. Well work with our FallopiaData.csv dataset, and remind ourselves of the structure of the data Fallo&lt;-read.csv(&quot;https://colauttilab.github.io/RCrashCourse/FallopiaData.csv&quot;) str(Fallo) ## &#39;data.frame&#39;: 123 obs. of 13 variables: ## $ PotNum : int 1 2 3 5 6 7 8 9 10 11 ... ## $ Scenario : chr &quot;low&quot; &quot;low&quot; &quot;low&quot; &quot;low&quot; ... ## $ Nutrients : chr &quot;low&quot; &quot;low&quot; &quot;low&quot; &quot;low&quot; ... ## $ Taxon : chr &quot;japon&quot; &quot;japon&quot; &quot;japon&quot; &quot;japon&quot; ... ## $ Symphytum : num 9.81 8.64 2.65 1.44 9.15 ... ## $ Silene : num 36.4 29.6 36 21.4 23.9 ... ## $ Urtica : num 16.08 5.59 17.09 12.39 5.19 ... ## $ Geranium : num 4.68 5.75 5.13 5.37 0 9.05 3.51 9.64 7.3 6.36 ... ## $ Geum : num 0.12 0.55 0.09 0.31 0.17 0.97 0.4 0.01 0.47 0.33 ... ## $ All_Natives : num 67 50.2 61 40.9 38.4 ... ## $ Fallopia : num 0.01 0.04 0.09 0.77 3.4 0.54 2.05 0.26 0 0 ... ## $ Total : num 67.1 50.2 61.1 41.7 41.8 ... ## $ Pct_Fallopia: num 0.01 0.08 0.15 1.85 8.13 1.12 3.7 0.61 0 0 ... This file is an example of a 2-dimensional data set, which is common in biology. 2D datasets have the familiar row x column layout used by spreadsheet programs like Microsoft Excel or Google Sheets. There are some exceptions, but data in this format should typically follows 3 rules: Each cell contains a single value Each variable must have its own column Each observation must have its own row Making sure your data are arranged this way will usually make it much easier to work with. 6.3.1 filter() Lets subset observations based on value Pot1&lt;-filter(Fallo,PotNum==1) head(Pot1) ## PotNum Scenario Nutrients Taxon Symphytum Silene Urtica Geranium Geum ## 1 1 low low japon 9.81 36.36 16.08 4.68 0.12 ## All_Natives Fallopia Total Pct_Fallopia ## 1 67.05 0.01 67.06 0.01 6.3.2 rename() Its possible to change the names of columns in your data. In base R you can use the names() function with the square bracket index []: X&lt;-Fallo names(X) ## [1] &quot;PotNum&quot; &quot;Scenario&quot; &quot;Nutrients&quot; &quot;Taxon&quot; &quot;Symphytum&quot; ## [6] &quot;Silene&quot; &quot;Urtica&quot; &quot;Geranium&quot; &quot;Geum&quot; &quot;All_Natives&quot; ## [11] &quot;Fallopia&quot; &quot;Total&quot; &quot;Pct_Fallopia&quot; names(X)[12]&lt;-&quot;Total_Biomass&quot; names(X) ## [1] &quot;PotNum&quot; &quot;Scenario&quot; &quot;Nutrients&quot; &quot;Taxon&quot; ## [5] &quot;Symphytum&quot; &quot;Silene&quot; &quot;Urtica&quot; &quot;Geranium&quot; ## [9] &quot;Geum&quot; &quot;All_Natives&quot; &quot;Fallopia&quot; &quot;Total_Biomass&quot; ## [13] &quot;Pct_Fallopia&quot; X&lt;-rename(Fallo, Total_Biomass = Total) names(X) ## [1] &quot;PotNum&quot; &quot;Scenario&quot; &quot;Nutrients&quot; &quot;Taxon&quot; ## [5] &quot;Symphytum&quot; &quot;Silene&quot; &quot;Urtica&quot; &quot;Geranium&quot; ## [9] &quot;Geum&quot; &quot;All_Natives&quot; &quot;Fallopia&quot; &quot;Total_Biomass&quot; ## [13] &quot;Pct_Fallopia&quot; There is also a simple dplyr function to do this: 6.3.3 arrange() Use the arrange() function to sort the rows of your data based on the columns of your data. For example, lets re-arrange our FallopiaData.csv dataset based on Taxon (a string denoting the species of Fallopia used) and Total (a float denoting the total biomass in each pot). X&lt;-arrange(Fallo, Taxon, Total) head(X) ## PotNum Scenario Nutrients Taxon Symphytum Silene Urtica Geranium Geum ## 1 26 low low bohem 13.25 18.11 0.00 0.00 0.10 ## 2 17 low low bohem 4.90 29.52 1.36 0.00 0.19 ## 3 80 gradual high bohem 11.92 17.16 8.92 0.94 0.18 ## 4 18 low low bohem 3.51 27.61 8.14 3.81 0.21 ## 5 28 low low bohem 10.59 18.78 7.19 6.73 0.17 ## 6 22 low low bohem 0.76 22.66 9.85 10.60 0.74 ## All_Natives Fallopia Total Pct_Fallopia ## 1 31.46 0.00 31.46 0.00 ## 2 35.97 0.00 35.97 0.00 ## 3 39.12 3.35 42.47 7.89 ## 4 43.28 0.00 43.28 0.00 ## 5 43.46 0.00 43.46 0.00 ## 6 44.61 0.00 44.61 0.00 use the desc() function with arrange() to change to descending order X&lt;-arrange(Fallo, Taxon, desc(Total)) head(X) ## PotNum Scenario Nutrients Taxon Symphytum Silene Urtica Geranium Geum ## 1 148 fluctuations high bohem 4.15 38.70 23.59 5.11 1.36 ## 2 86 gradual high bohem 2.93 60.93 4.11 6.67 1.27 ## 3 60 high high bohem 7.77 51.45 5.13 10.10 0.37 ## 4 85 gradual high bohem 10.19 26.66 15.01 3.07 0.14 ## 5 53 high high bohem 7.05 56.29 1.14 4.07 0.00 ## 6 118 extreme high bohem 14.21 25.15 12.69 8.06 0.29 ## All_Natives Fallopia Total Pct_Fallopia ## 1 72.91 5.89 78.80 7.47 ## 2 75.91 0.00 75.91 0.00 ## 3 74.82 0.00 74.82 0.00 ## 4 55.07 14.47 69.54 20.81 ## 5 68.55 0.00 68.55 0.00 ## 6 60.40 7.46 67.86 10.99 6.3.4 select() The select() function can be used to select a subset of columns (i.e. variables) from your data. Suppose we only want to look at total biomass, but keep all the treatment columns: X&lt;-select(Fallo, PotNum, Scenario, Nutrients, Taxon, Total) head(X) ## PotNum Scenario Nutrients Taxon Total ## 1 1 low low japon 67.06 ## 2 2 low low japon 50.22 ## 3 3 low low japon 61.08 ## 4 5 low low japon 41.71 ## 5 6 low low japon 41.81 ## 6 7 low low japon 48.27 You can also use the colon : to select a range of columns: X&lt;-select(Fallo, PotNum:Taxon, Total) head(X) ## PotNum Scenario Nutrients Taxon Total ## 1 1 low low japon 67.06 ## 2 2 low low japon 50.22 ## 3 3 low low japon 61.08 ## 4 5 low low japon 41.71 ## 5 6 low low japon 41.81 ## 6 7 low low japon 48.27 Exclude columns with - X&lt;-select(Fallo, -PotNum:Taxon, -Total) ## Warning in x:y: numerical expression has 12 elements: only the first used Oops, what generated that error? Take a careful look at the error message and see if you can figure it out. The problem is we are using the range of columns between PotNum and Taxon, but in one case we are excluding and the other we are including. We need to keep both the same: X&lt;-select(Fallo, -PotNum:-Taxon, Total) head(X) ## Symphytum Silene Urtica Geranium Geum All_Natives Fallopia Total Pct_Fallopia ## 1 9.81 36.36 16.08 4.68 0.12 67.05 0.01 67.06 0.01 ## 2 8.64 29.65 5.59 5.75 0.55 50.18 0.04 50.22 0.08 ## 3 2.65 36.03 17.09 5.13 0.09 60.99 0.09 61.08 0.15 ## 4 1.44 21.43 12.39 5.37 0.31 40.94 0.77 41.71 1.85 ## 5 9.15 23.90 5.19 0.00 0.17 38.41 3.40 41.81 8.13 ## 6 6.31 24.40 7.00 9.05 0.97 47.73 0.54 48.27 1.12 Or a bit more clear: X&lt;-select(Fallo, -(PotNum:Taxon), Total) head(X) ## Symphytum Silene Urtica Geranium Geum All_Natives Fallopia Total Pct_Fallopia ## 1 9.81 36.36 16.08 4.68 0.12 67.05 0.01 67.06 0.01 ## 2 8.64 29.65 5.59 5.75 0.55 50.18 0.04 50.22 0.08 ## 3 2.65 36.03 17.09 5.13 0.09 60.99 0.09 61.08 0.15 ## 4 1.44 21.43 12.39 5.37 0.31 40.94 0.77 41.71 1.85 ## 5 9.15 23.90 5.19 0.00 0.17 38.41 3.40 41.81 8.13 ## 6 6.31 24.40 7.00 9.05 0.97 47.73 0.54 48.27 1.12 6.3.5 everything() Use the everything() function with select() to rearrange your columns without losing any: X&lt;-select(Fallo, Taxon, Scenario, Nutrients, PotNum, Pct_Fallopia, everything()) head(X) ## Taxon Scenario Nutrients PotNum Pct_Fallopia Symphytum Silene Urtica Geranium ## 1 japon low low 1 0.01 9.81 36.36 16.08 4.68 ## 2 japon low low 2 0.08 8.64 29.65 5.59 5.75 ## 3 japon low low 3 0.15 2.65 36.03 17.09 5.13 ## 4 japon low low 5 1.85 1.44 21.43 12.39 5.37 ## 5 japon low low 6 8.13 9.15 23.90 5.19 0.00 ## 6 japon low low 7 1.12 6.31 24.40 7.00 9.05 ## Geum All_Natives Fallopia Total ## 1 0.12 67.05 0.01 67.06 ## 2 0.55 50.18 0.04 50.22 ## 3 0.09 60.99 0.09 61.08 ## 4 0.31 40.94 0.77 41.71 ## 5 0.17 38.41 3.40 41.81 ## 6 0.97 47.73 0.54 48.27 6.3.6 mutate() Suppose we want to make a new column (variable) to our data.frame object (dataset) that is the sum of biomass of Urtica and Geranium only. In base R you would use $: X&lt;-Fallo X$UrtSil&lt;-X$Urtica+X$Silene In the dplyr package you can use mutate X&lt;-mutate(Fallo, UrtSil = Urtica + Silene) head(X) ## PotNum Scenario Nutrients Taxon Symphytum Silene Urtica Geranium Geum ## 1 1 low low japon 9.81 36.36 16.08 4.68 0.12 ## 2 2 low low japon 8.64 29.65 5.59 5.75 0.55 ## 3 3 low low japon 2.65 36.03 17.09 5.13 0.09 ## 4 5 low low japon 1.44 21.43 12.39 5.37 0.31 ## 5 6 low low japon 9.15 23.90 5.19 0.00 0.17 ## 6 7 low low japon 6.31 24.40 7.00 9.05 0.97 ## All_Natives Fallopia Total Pct_Fallopia UrtSil ## 1 67.05 0.01 67.06 0.01 52.44 ## 2 50.18 0.04 50.22 0.08 35.24 ## 3 60.99 0.09 61.08 0.15 53.12 ## 4 40.94 0.77 41.71 1.85 33.82 ## 5 38.41 3.40 41.81 8.13 29.09 ## 6 47.73 0.54 48.27 1.12 31.40 This is a lot more readable, especially when you have complicated equations or you want to add lots of new columns. What if you only wanted to retain the new columns and delete everything else? Try it. Which functions did you use? 6.3.7 transmute() You can also use transmute() instead of mutate() + select() X&lt;-transmute(Fallo, UrtSil = Urtica + Silene) head(X) ## UrtSil ## 1 52.44 ## 2 35.24 ## 3 53.12 ## 4 33.82 ## 5 29.09 ## 6 31.40 6.3.8 summarize() + group_by() This can be useful for quickly summarizing your data, for example to find the mean or standard deviation based on a particular treatment or group. TrtGrp&lt;-group_by(Fallo,Taxon,Scenario,Nutrients) summarize(TrtGrp, Mean=mean(Total), SD=sd(Total)) ## `summarise()` has grouped output by &#39;Taxon&#39;, &#39;Scenario&#39;. You can override using the `.groups` argument. ## # A tibble: 10 x 5 ## # Groups: Taxon, Scenario [10] ## Taxon Scenario Nutrients Mean SD ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 bohem extreme high 58.3 7.34 ## 2 bohem fluctuations high 58.4 9.20 ## 3 bohem gradual high 57.5 9.34 ## 4 bohem high high 60.3 8.68 ## 5 bohem low low 48.0 8.86 ## 6 japon extreme high 57.2 10.9 ## 7 japon fluctuations high 56.4 13.7 ## 8 japon gradual high 59.7 9.57 ## 9 japon high high 56.4 8.20 ## 10 japon low low 52.0 8.29 6.3.9 Weighted Mean In our dataset, the Taxon column shows which of two species of Fallopia were used in the competition experiments. We might want to take the mean total biomass for each of the two Fallopia species: X&lt;-group_by(Fallo,Taxon) summarize(X, Mean=mean(Total), SD=sd(Total)) ## # A tibble: 2 x 3 ## Taxon Mean SD ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 bohem 56.3 9.54 ## 2 japon 56.4 10.4 However, there are other factors in our experiment that may affect biomass. The Nutrients column tells us whether pots received high or low nutrients, and this also affects biomass: X&lt;-group_by(Fallo,Nutrients) summarize(X, Mean=mean(Total), SD=sd(Total)) ## # A tibble: 2 x 3 ## Nutrients Mean SD ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 high 58.0 9.61 ## 2 low 49.9 8.66 Now imagine if our sampling design is unbalanced. For example, maybe we had some plant mortality or lost some plants to a tornado. If one of the two species in the Taxon column had more high-nutrient pots, then it would have a higher mean. BUT, the higher mean is not an effect of the Taxon, but is simply due to the unbalanced nature of the design. We can simulate this effect by re-shuffling the species names: RFallo&lt;-Fallo set.seed(256) RFallo$Taxon&lt;-rbinom(nrow(RFallo),size=1,prob=0.7) X&lt;-group_by(RFallo,Taxon) summarize(X, Mean=mean(Total)) ## # A tibble: 2 x 2 ## Taxon Mean ## &lt;int&gt; &lt;dbl&gt; ## 1 0 56.1 ## 2 1 56.5 To fix this problem, we may want to take a weighted mean: X1&lt;-group_by(RFallo,Taxon,Scenario,Nutrients) Y1&lt;-summarize(X1,Mean=mean(Total)) ## `summarise()` has grouped output by &#39;Taxon&#39;, &#39;Scenario&#39;. You can override using the `.groups` argument. X2&lt;-group_by(Y1,Taxon,Scenario) Y2&lt;-summarize(X2,Mean=mean(Mean)) ## `summarise()` has grouped output by &#39;Taxon&#39;. You can override using the `.groups` argument. X3&lt;-group_by(Y2,Taxon) Y3&lt;-summarize(X3, Mean=mean(Mean)) arrange(Y3,desc(Mean)) ## # A tibble: 2 x 2 ## Taxon Mean ## &lt;int&gt; &lt;dbl&gt; ## 1 1 56.6 ## 2 0 55.8 6.3.10 %&gt;% (pipe) The combination %&gt;% is called pipe for short. Be careful though  in Unix, pipe is slightly different and uses the vertical line (often shift-backslash): | The pipe is useful to combine operations without creating a whole bunch of new objects. This can save on memory use. For example, we can re-write the weighted mean example using pipes: RFallo %&gt;% group_by(Taxon,Scenario,Nutrients) %&gt;% summarize(Mean=mean(Total)) %&gt;% group_by(Taxon,Scenario) %&gt;% summarize(Mean=mean(Mean)) %&gt;% group_by(Taxon) %&gt;% summarize(Mean=mean(Mean)) %&gt;% arrange(desc(Mean)) ## `summarise()` has grouped output by &#39;Taxon&#39;, &#39;Scenario&#39;. You can override using the `.groups` argument. ## `summarise()` has grouped output by &#39;Taxon&#39;. You can override using the `.groups` argument. ## # A tibble: 2 x 2 ## Taxon Mean ## &lt;int&gt; &lt;dbl&gt; ## 1 1 56.6 ## 2 0 55.8 This also avoids potential for bugs in our program. Imagine if we mis-spelled Taxon in our second line by accidentialy pressing s along with x. Compare the output: X&lt;-group_by(Fallo,Taxon,Scenario,Nutrients) X&lt;-group_by(X,Tasxon,Scenario) ## Error: Must group by variables found in `.data`. ## * Column `Tasxon` is not found. X&lt;-group_by(X,Taxon) X&lt;-summarize(X, Mean=mean(Total), SD=sd(Total)) arrange(X,desc(Mean)) ## # A tibble: 2 x 3 ## Taxon Mean SD ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 japon 56.4 10.4 ## 2 bohem 56.3 9.54 Fallo %&gt;% group_by(Taxon,Scenario,Nutrients) %&gt;% group_by(Tasxon,Scenario) %&gt;% group_by(Taxon) %&gt;% summarize(Mean=mean(Total), SD=sd(Total)) %&gt;% arrange(desc(Mean)) ## Error: Must group by variables found in `.data`. ## * Column `Tasxon` is not found. In both cases we get an error, but in one case we still calculate the means and sd of the two species. A bug that produces no output is much less dangerous than an error that gives an output. Why? 6.4 Missing Data So far we have worked on a pristine data set that has already been edited for errors. More often datasets will contain missing values. 6.4.1 NA and na.rm() The R language uses a special object NA to denote missing data. Vec&lt;-c(1,2,3,NA,5,6,7) Vec ## [1] 1 2 3 NA 5 6 7 When a function is run on a vector or other object containing NA, the function will often return NA or give an error message: mean(Vec) ## [1] NA This is by design, because it is not always clear what NA means. Many functions in R include an na.rm parameter that is set to FALSE by default. Setting it to true tells the function to ignore the NA mean(Vec, na.rm=T) ## [1] 4 6.4.2 NA vs 0 A common mistake students make is to put 0 for missing data. This can be a big problem when analyzing the data since the calculations are very different. Vec1&lt;-c(1,2,3,NA,5,6,7) mean(Vec1, na.rm=T) ## [1] 4 Vec2&lt;-c(1,2,3,0,5,6,7) mean(Vec2, na.rm=T) ## [1] 3.428571 6.4.3 is.na() In large datasets you might want to check for missing values. Lets simulate this in our FallopiaData.csv dataset. To set up a test dataset, randomly select 10 rows and replace the value for Total with NA. The sample function is a X&lt;-round(runif(10,min=1,max=nrow(Fallo)),0) Fallo$Total[X]&lt;-NA Fallo$Total ## [1] 67.06 50.22 61.08 41.71 41.81 48.27 55.42 42.68 NA 45.89 59.02 57.66 ## [13] 48.98 35.97 43.28 52.27 45.92 44.61 59.13 58.97 55.36 31.46 43.46 44.65 ## [25] 59.69 60.82 57.21 34.09 58.57 66.74 63.18 NA 54.09 55.27 61.31 53.56 ## [37] 52.66 64.71 61.06 45.34 64.20 57.50 68.55 49.55 56.70 54.06 66.60 74.82 ## [49] 53.71 49.75 58.45 66.06 67.01 70.41 NA 63.43 77.05 47.50 61.79 54.96 ## [61] 48.99 52.01 NA 57.18 42.47 46.18 62.56 54.36 69.54 75.91 56.34 64.97 ## [73] 60.71 57.80 41.72 67.44 58.78 NA NA 58.42 55.35 NA 55.04 39.56 ## [85] 71.07 45.23 57.20 67.70 52.46 60.86 NA 65.53 48.19 60.89 48.13 60.37 ## [97] 67.86 56.40 49.13 56.11 49.78 69.00 65.40 50.73 63.08 60.93 NA 49.12 ## [109] 68.73 31.90 69.88 69.48 47.88 51.42 58.13 50.51 54.83 66.80 50.31 56.12 ## [121] 62.96 78.80 64.25 Use is.na() to check for missing values: is.na(Fallo$Total) ## [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE TRUE FALSE FALSE FALSE ## [13] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## [25] FALSE FALSE FALSE FALSE FALSE FALSE FALSE TRUE FALSE FALSE FALSE FALSE ## [37] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## [49] FALSE FALSE FALSE FALSE FALSE FALSE TRUE FALSE FALSE FALSE FALSE FALSE ## [61] FALSE FALSE TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## [73] FALSE FALSE FALSE FALSE FALSE TRUE TRUE FALSE FALSE TRUE FALSE FALSE ## [85] FALSE FALSE FALSE FALSE FALSE FALSE TRUE FALSE FALSE FALSE FALSE FALSE ## [97] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE TRUE FALSE ## [109] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## [121] FALSE FALSE FALSE Note that the output is a vector of True/False. Each cell corresponds to a value of Total with TRUE indicating missing values. This is an example of a boolean variable, which has some handy properties in R. First, we can use it as an index. For example, lets see which pots have missing Total values: Missing&lt;-is.na(Fallo$Total) Fallo$PotNum[Missing] ## [1] 10 39 68 78 95 96 100 111 129 Another handy trick to count missing values is: sum(is.na(Fallo$Total)) ## [1] 9 This takes advantage of the fact that the boolean TRUE/FALSE variable is equivalent to the binary 1/0 values. 6.5 Naughty Data Naughty data contain the same information as a standard row x column (i.e. 2-dimensional) dataset but break the rules outlined above: Each cell contains a single value Each variable must have its own column Each observation must have its own row Examples of Naughty Data are shown in Figure 2A of the Wu et al. manuscript. : Naughty data can be very time consuming to fix, but regular expressions can make this a bit easier (see the Regex tutorial). "],["advanced-r.html", "Chapter 7 Advanced R 7.1 Introduction 7.2 Getting Started 7.3 R Markdown 7.4 Tables 7.5 Custom Functions 7.6 Custom R Package 7.7 Make it public", " Chapter 7 Advanced R 7.1 Introduction By now you have mastered the fundamentals of base R, visualizations, and data science! In this tutorial, we will cover some a few of the more advanced but extremely useful topics. 7.2 Getting Started Before beginning this tutorial, make sure you have installed these packages: install.packages(&#39;rmarkdown&#39;) install.packages(&#39;dplyr&#39;) install.packages(&#39;knitr&#39;) 7.3 R Markdown R Markdown is a powerful format for quickly making high-quality reports of your analysis. You can embed code and all kinds of output, including graphs, and output them to a Word Document, PDF or website. In fact, all of our tutorial webpages are written in R Markdown, including this one! Here well cover just the basics, but a complete guide to R Markdown is available online from Yihui Xie, J. J. Allaire and Garrett Grolemund. You can also check out the R Markdown documents that we use to make our tutorial websites on our GitHub Pages (the website files have .html extension and the R Markdown files have the same name with .Rmd extensions): Main Colautti Lab Resources Website and GitHub Repository R Tutorials and GitHub Repository 7.3.1 Cheat Sheet There is a very handy 2-page cheat sheet that you can print out to help you remember some of the main commands. I use R Markdown for all kinds of documents  including course tutorials like this one  so I have the 2-page cheat sheet printed out and taped to my wall next to my computer. You can also access cheat sheets for R Markdown and several others R Studio also includes a number of cheat sheets under the Help menu: Help -&gt; Cheatsheets 7.3.2 Create In RStudio: File-&gt; New-&gt; R Markdown Choose Document from the left-hand side menu Make sure html is selected Then click OK Very few elements are needed for a basic markdown file, and these are provided when you create a new file. 7.3.3 YAML Header This is generated automatically when you make a new .Rmd file in RStudio. Depending on what options you choose, it might look something like this: --- title: &quot;Untitled&quot; author: &quot;Robert I. Colautti&quot; date: &quot;January 20, 2019&quot; output: html_document --- There are other options available for YAML, and you can includes a separate _output.yml to set other aspects of the layoug. 7.3.4 Markdown R Markdown is based on the markdown language, which was created as a quick and easy way to encode formatted websites in a simple text document. R Markdown has a few additions, including the ability to easily incorporate R code, graphs, and equations. 7.3.5 Basic elements: 7.3.5.1 Plain text Plain text is converted into paragraph format. To start a new paragraph, press enter twice, so to skip a line in the .Rmd file. 7.3.5.2 Formatted text You can format text with * or _ *italics* or _italics_: italics **bold** or __bold__: bold Use greater-than sign for block quotes, eg. &gt; TIP: quote TIP: quote 7.3.6 Headers Add headers with up to 6x #  more headers = subheadings: # Header 1 ## Sub-Header = Header 2 ### Sub-Sub Header = Header 3 #### Sub-Sub-Sub Header = Header 4 7.3.7 Other Elements superscript^2 superscript^2 -- for shortdash:  --- for long  dash:  7.3.8 Links Links have a special format. The text you want the user to see goes in square brackets, followed immediately by the file or html link in regular brackets, with no space in between: [Colautti Lab Website](https://colauttilab.github.io/): Colautti Lab Website You can also use this to link a file in the same project folder: [Linked jpeg file](./ColauttiLabLogo.png): Linked jpeg file 7.3.9 Images Or you can embed the image directly by adding an exclamation point. You can leave the linked text blank or keep it to use as a caption. ![Linked jpeg file](./ColauttiLabLogo.png): Linked jpeg file 7.3.10 Lists and tables Lists are easy to create, simply start a line with * or + for unordered lists or a number for ordered lists. Add tab characters for sub-lists: + Unordered list item 1 * Item 2 + sub item 2.1 * sub item 2.2 * Item 3 Unordered list item 1 Item 2 sub item 2.1 sub item 2.2 Item 3 1. Ordered list item 1 2. Item 2 + sub item 2.1 * sub item 2.2 3. Item 3 Ordered list item 1 Item 2 sub item 2.1 sub item 2.2 Item 3 The fun thing about ordered lists is the numbers you use dont really matter  R Markdown will automatically start at 1 and increase for each item. 1. Ordered list item 1 1. Item 2 + sub item 2.1 * sub item 2.2 1. Item 3 Ordered list item 1 Item 2 sub item 2.1 sub item 2.2 Item 3 Tables are added using vertical pipe | to denote columns, and a line of horizontal dashes to separate the title of the table, and dashes with pipes to separate the header row from the rest of the table. For example, this code: Tables ----------------------- Date | Length | Width ------|---------|------ 09/09/09 | 14 | 27 10/09/09 | 15 | 29 11/09/09 | 16 | 31 Produces this output: 7.4 Tables Date Length Width 09/09/09 14 27 10/09/09 15 29 11/09/09 16 31 7.4.1 Embed R Code Embed R code inline using the back-tick ` character: embedded code Note that the back-tick is not the single quotation mark. Its often on the same key as ~ on North American keyboards. You can add larger blocks of code (multiple lines) using three back ticks ` and r in curly brackets. Then add three more tick marks after the code chunk: # ```{r} # &lt;&lt;your code goes here&gt;&gt; # ``` Ctl-Alt-i is a nice shortcut in R Studio for adding code chunks quickly 7.4.1.1 Code Chunk Names You can name your code chunks, which becomes useful when making custom packages or other knitr uses. The name is added after the r separated only by spaces. The name cannot contain spaces. E.g. ```{r code-chunk-name, eval=F} 7.4.1.2 Suppress code You can use different options for your R code chunks, as shown on the cheatsheet. Three main ones are: eval=F  show the code but dont run it. include=F  run the code but dont show it and and dont produce any output, plots, messages or warnings. echo=F  dont show the code but run it and include any output, plots, messages and warnings. 7.4.2 Dynamic tables Making tables from data is a bit more complicated. For example, if we wanted to summarize the FallopiaData.csv data, we could read in the file and then summarize with dplyr as we did in the Data Science Tutorial: library(dplyr) Fallo&lt;-read.csv(&quot;https://colauttilab.github.io/RCrashCourse/FallopiaData.csv&quot;) SumTable&lt;-Fallo %&gt;% group_by(Taxon,Scenario,Nutrients) %&gt;% summarize(Mean=mean(Total), SD=sd(Total)) %&gt;% arrange(desc(Mean)) print(SumTable) ## # A tibble: 10 x 5 ## # Groups: Taxon, Scenario [10] ## Taxon Scenario Nutrients Mean SD ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 bohem high high 60.3 8.68 ## 2 japon gradual high 59.7 9.57 ## 3 bohem fluctuations high 58.4 9.20 ## 4 bohem extreme high 58.3 7.34 ## 5 bohem gradual high 57.5 9.34 ## 6 japon extreme high 57.2 10.9 ## 7 japon high high 56.4 8.20 ## 8 japon fluctuations high 56.4 13.7 ## 9 japon low low 52.0 8.29 ## 10 bohem low low 48.0 8.86 The output is legible but not very attractive for a final report. To make it look better, we can use the kable function from the knitr package: library(knitr) kable(SumTable, caption = &quot;Summary Table&quot;) Table 7.1: Summary Table Taxon Scenario Nutrients Mean SD bohem high high 60.28091 8.677075 japon gradual high 59.72917 9.565376 bohem fluctuations high 58.36455 9.202334 bohem extreme high 58.30917 7.337015 bohem gradual high 57.46154 9.338311 japon extreme high 57.23643 10.903133 japon high high 56.44833 8.204091 japon fluctuations high 56.43692 13.724906 japon low low 52.02917 8.287938 bohem low low 47.98077 8.862164 7.4.3 Embed Graphs Use R code to embed graphs. qplot(rnorm(100)) 7.4.4 Options for header output: html_document: # Add options for html output toc: true # Add table of contents (TOC) number_sections: true # Add section numbers toc_float: # Have TOC floating at the side, rather than at the beginning collapsed: false # Expand subsections 7.4.5 Content as tabs ## Quarterly Results {.tabset} ### By Product (Product tab content) ### By Region (Region tab content) Looks like this: 7.4.6 Quarterly Results 7.4.6.1 By Product (Product tab content) 7.4.6.2 By Region (Region tab content) 7.4.7 Equations Insert equations using LaTeX. Here is a handy cheat sheet Use single dollar signs for in-line equations, like $Y ~ X$, which will print as \\(Y ~ X\\) Use double dollar signs on a new line for full-line equations, for example: $$\\idotsint_V \\mu(u_1,\\dots,u_k) \\,du_1 \\dots du_k$$ will produce: \\[\\idotsint_V \\mu(u_1,\\dots,u_k) \\,du_1 \\dots du_k\\] and $$sum_{n=1}^{\\infty} 2^{-n} = 1$$ will produce: \\[\\sum_{n=1}^{\\infty} 2^{-n} = 1\\] Notice the use of special characters with the backslash \\, along with subscripts _ and superscripts _ with the super/subscripted text in curly brackets {} 7.5 Custom Functions 7.5.1 General form: functionName&lt;-function(var1=Default1,var2=Default2){ ## Meat and potatoes script } 7.5.2 Example function User inputs two objects; the function outputs a list of functions applied to the inputs my.function&lt;-function(var1=0,var2=0){ # You can make new variables within a function add&lt;-var1+var2 subt&lt;-var1-var2 mult&lt;-var1*var2 div&lt;-var1/var2 outlist&lt;-list(input1=var1,input2=var2,addition=add,subtraction=subt,multiplication=mult,division=div) # So far, everything is contained within the function. # Use return() to generate output return(outlist) } Note: Nothing output when the funciton is run. This just loads the function into memory. 7.5.2.1 Run the function my.function(var1=10,var2=0.1) ## $input1 ## [1] 10 ## ## $input2 ## [1] 0.1 ## ## $addition ## [1] 10.1 ## ## $subtraction ## [1] 9.9 ## ## $multiplication ## [1] 1 ## ## $division ## [1] 100 my.function(var1=c(1:10),var2=c(10:1)) ## $input1 ## [1] 1 2 3 4 5 6 7 8 9 10 ## ## $input2 ## [1] 10 9 8 7 6 5 4 3 2 1 ## ## $addition ## [1] 11 11 11 11 11 11 11 11 11 11 ## ## $subtraction ## [1] -9 -7 -5 -3 -1 1 3 5 7 9 ## ## $multiplication ## [1] 10 18 24 28 30 30 28 24 18 10 ## ## $division ## [1] 0.1000000 0.2222222 0.3750000 0.5714286 0.8333333 1.2000000 ## [7] 1.7500000 2.6666667 4.5000000 10.0000000 Protip #1: Consider annotating long or complex script with cat() to help with troubleshooting. The cat function is similar to print but lets you print directly to screen rather than passing through a data object. Note that \\n is a new line` character; try removing them and compare the output. my.function&lt;-function(var1=0,var2=0,verbose=FALSE){ cat(&quot;\\nInput variables:\\nvar1 =&quot;,var1,&quot;\\nvar2 =&quot;,var2,&quot;\\n&quot;) cat(&quot;\\nCalculating functions...\\n&quot;) cat(&quot;\\nAdding...\\n&quot;) add&lt;-var1+var2 cat(&quot;\\nSubtracting...\\n&quot;) subt&lt;-var1-var2 cat(&quot;\\nMultiplying...\\n&quot;) mult&lt;-var1*var2 cat(&quot;\\nDividing...\\n&quot;) div&lt;-var1/var2 cat(&quot;\\nGenerating output...\\n\\n&quot;) outlist&lt;-list(input1=var1,input2=var2,addition=add,subtraction=subt,multiplication=mult,division=div) return(outlist) } ## Run my.function(var1=10,var2=0.1) ## ## Input variables: ## var1 = 10 ## var2 = 0.1 ## ## Calculating functions... ## ## Adding... ## ## Subtracting... ## ## Multiplying... ## ## Dividing... ## ## Generating output... ## $input1 ## [1] 10 ## ## $input2 ## [1] 0.1 ## ## $addition ## [1] 10.1 ## ## $subtraction ## [1] 9.9 ## ## $multiplication ## [1] 1 ## ## $division ## [1] 100 Better yet, make it an option: my.function&lt;-function(var1=0,var2=0,verbose=FALSE){ if (verbose==T){ cat(&quot;\\nInput variables:\\nvar1 =&quot;,var1,&quot;\\nvar2 =&quot;,var2,&quot;\\n&quot;) cat(&quot;\\nCalculating functions...\\n&quot;) cat(&quot;\\nAdding...\\n&quot;) } add&lt;-var1+var2 if (verbose==T){ cat(&quot;\\nSubtracting...\\n&quot;) } subt&lt;-var1-var2 if (verbose==T){ cat(&quot;\\nMultiplying...\\n&quot;) } mult&lt;-var1*var2 if (verbose==T){ cat(&quot;\\nDividing...\\n&quot;) } div&lt;-var1/var2 if (verbose==T){ cat(&quot;\\nGenerating output...\\n&quot;) } outlist&lt;-list(input1=var1,input2=var2,addition=add,subtraction=subt,multiplication=mult,division=div) return(outlist) } # Run my.function(var1=10,var2=0.1,verbose=FALSE) ## $input1 ## [1] 10 ## ## $input2 ## [1] 0.1 ## ## $addition ## [1] 10.1 ## ## $subtraction ## [1] 9.9 ## ## $multiplication ## [1] 1 ## ## $division ## [1] 100 my.function(var1=10,var2=0.1,verbose=TRUE) ## ## Input variables: ## var1 = 10 ## var2 = 0.1 ## ## Calculating functions... ## ## Adding... ## ## Subtracting... ## ## Multiplying... ## ## Dividing... ## ## Generating output... ## $input1 ## [1] 10 ## ## $input2 ## [1] 0.1 ## ## $addition ## [1] 10.1 ## ## $subtraction ## [1] 9.9 ## ## $multiplication ## [1] 1 ## ## $division ## [1] 100 Protip #2: If you have a custom function, theme, script, etc., that you use repeatedly: Save in a separate file * e.g. make new &quot;myfunction.R&quot; file containing just my.function Load using source(\"PathName.FileName.R\") * e.g. `source(&quot;C:/Users/Colautti/Documents/RFunctions/myfunction.R&quot;)` if save Protip #3: We have already been using functions that somebody else wrote in R. To see under the hood type a function without the bracktes: my.function ## function(var1=0,var2=0,verbose=FALSE){ ## if (verbose==T){ ## cat(&quot;\\nInput variables:\\nvar1 =&quot;,var1,&quot;\\nvar2 =&quot;,var2,&quot;\\n&quot;) ## cat(&quot;\\nCalculating functions...\\n&quot;) ## cat(&quot;\\nAdding...\\n&quot;) ## } ## ## add&lt;-var1+var2 ## ## if (verbose==T){ ## cat(&quot;\\nSubtracting...\\n&quot;) ## } ## ## subt&lt;-var1-var2 ## ## if (verbose==T){ ## cat(&quot;\\nMultiplying...\\n&quot;) ## } ## ## mult&lt;-var1*var2 ## ## if (verbose==T){ ## cat(&quot;\\nDividing...\\n&quot;) ## } ## ## div&lt;-var1/var2 ## ## if (verbose==T){ ## cat(&quot;\\nGenerating output...\\n&quot;) ## } ## ## outlist&lt;-list(input1=var1,input2=var2,addition=add,subtraction=subt,multiplication=mult,division=div) ## ## return(outlist) ## } ## &lt;bytecode: 0x000000001e5a6c78&gt; library(ggplot2) qplot ## function (x, y, ..., data, facets = NULL, margins = FALSE, geom = &quot;auto&quot;, ## xlim = c(NA, NA), ylim = c(NA, NA), log = &quot;&quot;, main = NULL, ## xlab = NULL, ylab = NULL, asp = NA, stat = NULL, position = NULL) ## { ## caller_env &lt;- parent.frame() ## if (!missing(stat)) ## warn(&quot;`stat` is deprecated&quot;) ## if (!missing(position)) ## warn(&quot;`position` is deprecated&quot;) ## if (!is.character(geom)) { ## abort(&quot;`geom` must be a character vector&quot;) ## } ## exprs &lt;- enquos(x = x, y = y, ...) ## is_missing &lt;- vapply(exprs, quo_is_missing, logical(1)) ## is_constant &lt;- (!names(exprs) %in% ggplot_global$all_aesthetics) | ## vapply(exprs, quo_is_call, logical(1), name = &quot;I&quot;) ## mapping &lt;- new_aes(exprs[!is_missing &amp; !is_constant], env = parent.frame()) ## consts &lt;- exprs[is_constant] ## aes_names &lt;- names(mapping) ## mapping &lt;- rename_aes(mapping) ## if (is.null(xlab)) { ## if (quo_is_missing(exprs$x)) { ## xlab &lt;- &quot;&quot; ## } ## else { ## xlab &lt;- as_label(exprs$x) ## } ## } ## if (is.null(ylab)) { ## if (quo_is_missing(exprs$y)) { ## ylab &lt;- &quot;&quot; ## } ## else { ## ylab &lt;- as_label(exprs$y) ## } ## } ## if (missing(data)) { ## data &lt;- new_data_frame() ## facetvars &lt;- all.vars(facets) ## facetvars &lt;- facetvars[facetvars != &quot;.&quot;] ## names(facetvars) &lt;- facetvars ## facetsdf &lt;- as.data.frame(mget(facetvars, envir = caller_env)) ## if (nrow(facetsdf)) ## data &lt;- facetsdf ## } ## if (&quot;auto&quot; %in% geom) { ## if (&quot;sample&quot; %in% aes_names) { ## geom[geom == &quot;auto&quot;] &lt;- &quot;qq&quot; ## } ## else if (missing(y)) { ## x &lt;- eval_tidy(mapping$x, data, caller_env) ## if (is.discrete(x)) { ## geom[geom == &quot;auto&quot;] &lt;- &quot;bar&quot; ## } ## else { ## geom[geom == &quot;auto&quot;] &lt;- &quot;histogram&quot; ## } ## if (is.null(ylab)) ## ylab &lt;- &quot;count&quot; ## } ## else { ## if (missing(x)) { ## mapping$x &lt;- quo(seq_along(!!mapping$y)) ## } ## geom[geom == &quot;auto&quot;] &lt;- &quot;point&quot; ## } ## } ## p &lt;- ggplot(data, mapping, environment = caller_env) ## if (is.null(facets)) { ## p &lt;- p + facet_null() ## } ## else if (is.formula(facets) &amp;&amp; length(facets) == 2) { ## p &lt;- p + facet_wrap(facets) ## } ## else { ## p &lt;- p + facet_grid(facets = deparse(facets), margins = margins) ## } ## if (!is.null(main)) ## p &lt;- p + ggtitle(main) ## for (g in geom) { ## params &lt;- lapply(consts, eval_tidy) ## p &lt;- p + do.call(paste0(&quot;geom_&quot;, g), params) ## } ## logv &lt;- function(var) var %in% strsplit(log, &quot;&quot;)[[1]] ## if (logv(&quot;x&quot;)) ## p &lt;- p + scale_x_log10() ## if (logv(&quot;y&quot;)) ## p &lt;- p + scale_y_log10() ## if (!is.na(asp)) ## p &lt;- p + theme(aspect.ratio = asp) ## if (!missing(xlab)) ## p &lt;- p + xlab(xlab) ## if (!missing(ylab)) ## p &lt;- p + ylab(ylab) ## if (!missing(xlim) &amp;&amp; !all(is.na(xlim))) ## p &lt;- p + xlim(xlim) ## if (!missing(ylim) &amp;&amp; !all(is.na(ylim))) ## p &lt;- p + ylim(ylim) ## p ## } ## &lt;bytecode: 0x0000000020211688&gt; ## &lt;environment: namespace:ggplot2&gt; 7.6 Custom R Package Most of the general content can be found in Hadley Wickhams R Packages book. It goes into detail on almost everything you would need to know to make a package. For a quick tutorial, see Hilary Parkers post on a cat function. Install packages first and then read on. install.packages(c(&quot;devtools&quot;, &quot;roxygen2&quot;, &quot;testthat&quot;, &quot;knitr&quot;)) Tutorial objectives: Make a basic package in RStudio and make 1 function. Make documentation for the function. Installing the package and input checking. 7.6.1 Introduction When should you use a function vs write a package? Start with a piece of code, and be sure to add a comment to explain what the code does. # take x, square it and add one to it y &lt;- x^2 + 1 If you are going to use that piece of code multiple times, its easier to make it into a function and call it, rather than copying and pasting the same cod multiple times. (See functions tutorial LINK) square_plus&lt;-function(x){ # take x, square it and add one to it y &lt;-x^2 + 1 return(y) } square_plus(2) ## [1] 5 square_plus(4) ## [1] 17 square_plus(1:10) ## [1] 2 5 10 17 26 37 50 65 82 101 If you want to use the function across many scripts, you can save the function in its own .R file, and then load it into each script source(&quot;/Path/To/CustomScript/Script.R&quot;) When you have many functions that you use frequently, you might want to make your own R package so that you can load all the functions easily and quickly. This also makes it easy to share the functions. square_plus&lt;-function(x){ # take x, square it and add one to it y &lt;- x^2 + 1 return(y) } cube_plus&lt;-function(x){ # take x, cube it and add one to it y &lt;-x^3 + 1 return(y) } quartic_plus&lt;-function(x){ # raise x to the power of 4 and add one to it y &lt;-x^4 + 1 return(y) } 7.6.2 Getting started R Studio makes it easy to create your own packages for R. Once you have installed devtools (see above), create a new R package in R Studio File -&gt; New Project -&gt; New Directory -&gt; R Package You can also use the R Package option but delete the NAMESPACE file as it will be automatically generated later. Give the package a name and then click create. RStudio should load and there will be a file structure with several files and two folders, R and man. The R folder is for code, and there is a hello.R file in it. Save all of your custom functions here. The man folder is for manual pages, the documents that show up when you use the ? for help ?some_function. 7.6.3 Add functions We are going to make a function to get public references from the Crossref API. Crossref is one of the organizations for Digital Object Identifiers and is frequently the one used for scientific journals. Crossref has metadata on digital objects such as type of object, author, dates etc etc. We can access this information through the Crossref page. For example, the link below shows the result of a search for the title of a paper by Primack and Miller-Rushing (2011). https://search.crossref.org/?q=Broadening+the+study+of+phenology+and+climate+change The DOI for the first paper (by Primack &amp; Miller-Rushing) is 10.1111/j.1469-8137.2011.03773.x Clicking on the Actions button for this paper, and then Metadata as JSON, brings up a json file including citation information, and also citations for the papers referenced in the paper. Theres been times where we read a paper and then go through the references of the paper, especially for literature reviews/meta-analyses. Automating the extraction of references from a paper of interest might be useful. We can access the json file in R using the doi and using the Crossref api (documentation LINK). Doing this will give us a list of the citations: # download jsonlite to parse json files library(jsonlite) url&lt;-&quot;https://api.crossref.org/works/10.1111/j.1469-8137.2011.03773.x&quot; result&lt;-fromJSON(url) result is a list containing a variety of information names(result) ## [1] &quot;status&quot; &quot;message-type&quot; &quot;message-version&quot; &quot;message&quot; result$message$reference is a data frame of citations containing 17 references that we can extract this. references&lt;-as.data.frame(result$message$reference) This can be easily writen to csv or other formats. But we can also make this a function for any DOI of interest. get_work_references&lt;-function(DOI){ url&lt;-paste0(&quot;https://api.crossref.org/works/&quot;,DOI) result&lt;-fromJSON(url) return(as.data.frame(result$message$reference)) } We can save the script above in the R folder to make it part of the package. Of course, we would want to add more functions in order to make this a useful package. If we want to run the function, we can use the source() function as described above. But as a package this still lack two important pieces: Documentation for this function (and any other functions we add) A library that would let us load all functions using the library() function 7.6.4 Adding documentation The first piece of documentation is the DESCRIPTION file. There are several fields to fill in for this. The package name is already filled automatically. We should add a title (ie. This Package Gets References). Change the Author to Authors@R and add yourself as the author and creator. Authors@R: person(&quot;First Name&quot;, &quot;Last Name&quot;, email=&quot;email@email.com&quot;, role=c(&quot;aut&quot;, cre)) # Two authors Authors@R: c(person(&quot;First Name&quot;, &quot;Last Name&quot;, email=&quot;email@email.com&quot;, role=c(&quot;aut&quot;, cre)), person(&quot;Second person name&quot;, &quot;second person last name&quot;, email=&quot;email@email.com&quot;, role=&quot;aut&quot;)) Write a description: Interfacing with Crossrefs API to get citation information using DOI. This package uses jsonlite and contains only one function. etc Choose one of the public licenses such as GPL-3, MIT etc. (see Wikipedia) Save the DESCRIPTION file. 7.6.5 Add a Manual The roxygen2 package can be used to make manuals for R packages. This greatly simplifies the writing process, which otherwise would be written in LaTeX. The roxygen2 package allows us to make comments directly in the script, and then roxygen2 automatically generates the manual pages from these comments. First, take out any library(*) commands and use packagename::function() for any functions from other libraries. Read R Packages - R code for more details on why. When writing your comments, follow this logic: Roxygen2 commands start with #'. The first line is automatically the title field and should cover only one line. The next text paragraph goes into the description. The usage field is automatically generated. Use @param tags for arguments. (Only 1 in this case). Use the next line to write a longer description. Use @return to write what is expected output and @example to write example code that will be run when creating the man page. We also want to use a @export tag so that the function will be available for use when the library is loaded. We need to add details such as description, useage, arguments. The script would look something like this: #&#39; Takes a DOI and returns references for the object. #&#39; #&#39; This function queries the Crossref API to obtain a data frame of references for the DOI. We use the paste0 function from base and the fromJSON function from jsonlite. #&#39; #&#39; @param DOI String. Digital object identifier. #&#39; #&#39; @return data frame of references. #&#39; @example #&#39; get_work_references(&quot;10.1111/j.1469-8137.2011.03773.x&quot;) #&#39; @export get_work_references&lt;-function(DOI){ url&lt;-paste0(&quot;https://api.crossref.org/works/&quot;,DOI) result&lt;-jsonlite::fromJSON(url) return(as.data.frame(result$message$reference)) } Save the file and use devtools::document(). We will now have a NAMESPACE file, and a new file within the man folder. The NAMESPACE file shows the function we have which will be available in the environment when the library is loaded. Open get_work_references.Rd and then click preview to see how it looks. However, our man page is a bit dull, and lacks the links most pages have. We have to add the links using code. For example, linking the paste0 function will be \\code{\\link[base]{paste0}}. Use document() again. Now the functions are in monospace font. The actual links only appear when the package is built. We can use the CHECK button on the Build Pane to check for any issues in the package. We did not import the jsonlite package. To do this, go back to the DESCRIPTION file and add: jsonlite Another CHECK will tell you that the package curl is required. Add this to the imports as well. 7.6.6 Installing the package Once you pass the check, click Install and Restart to install the package. The package should be in your Packages pane. Doing ?get_work_references will bring up the help page with working links. We can successfully run the example. But if input is not a character, the function doesnt work. 7.6.7 Input checking You cannot account for every possible scenario where the function doesnt work. Or there are certain variables you know have to be in a specific form. You can add checks for inputs within the function. For example, the DOI should be a character string. We can add a test for the input and stop the function with an error if the input isnt a character string. get_work_references&lt;-function(DOI){ if (!is.character(DOI)) stop(&quot; &#39;DOI&#39; must be a character string&quot;) url&lt;-paste0(&quot;https://api.crossref.org/works/&quot;,DOI) result&lt;-jsonlite::fromJSON(url) return(as.data.frame(result$message$reference)) } Reinstall and you have a working package! 7.7 Make it public Before going public: Create a public GitHub repository and push your project Flesh out documentation and meta-data Error checking with devtools library * spell_check() * check_rhub()  use rhub to check for errors. More about RHub. * check_win_release()  check for errors on Windows with latest release version of R * check_win_devel()  check for errors on Windows with latest pre-release of R * release()  release to the world! Tag the latest release on GitHub For details on this and more: http://r-pkgs.had.co.nz/release.html 7.7.1 References: Hadley Wickham, R packages http://r-pkgs.had.co.nz/ Hilary Parker, Writing an R package from scratch, https://hilaryparker.com/2014/04/29/writing-an-r-package-from-scratch/ "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
